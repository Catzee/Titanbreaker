if _G.GameMechanics == nil then
	_G.GameMechanics = class({}) -- put COverthrowGameMode in the global scope
	--print("global maker called")
	--refer to: http://stackoverflow.com/questions/6586145/lua-require-with-global-local
end

totalAttributes = 9
STR = 1
AGI = 2
INT = 3
ARM = 4
AS = 5
AA = 6
MANA = 7
HP = 8
AAA = 9

function GameMechanics:PeriodicDebug(hero)
	local caster = hero
    Timers:CreateTimer(0.5, function()
	   	--print("iscastervalue")
	   	--print(caster.IsCasting)
	    GameMechanics:PeriodicDebug(caster)
	end)
end

function GetSpellpower(event)
	local spelldamagefromitem = 0
	local factor = 1
	local caster = event.caster
    if not caster:IsRealHero() then
        return 0
    end
    if caster:HasModifier("modifier_wandwisdom") then
        return 0
    end
	local mods = caster:GetModifierCount()-1
	for i=0, mods do
		local name = caster:GetModifierNameByIndex(i)
		--print(name)
		if name == "modifier_item_set_int_dmg_full" then
    		factor = factor + 0.1
	    end
        if name == "modifier_item_set_int_dmg_full_2" then
            factor = factor + 0.1
        end
        if name == "modifier_hptosp2" then
            spelldamagefromitem = spelldamagefromitem + 200
        end
        if name == "modifier_hptosp" then
            spelldamagefromitem = spelldamagefromitem + 50
        end
        if name == "modifier_item_set_int_dmg_full_2_dream" then
            factor = factor + 0.15
            spelldamagefromitem = spelldamagefromitem + 125
        end
        if name == "modifier_item_set_int_dmg_full_2_dream_2" then
            factor = factor + 0.15
            spelldamagefromitem = spelldamagefromitem + 250
        end
        if name == "modifier_item_set_int_dmg_full_2" then
            spelldamagefromitem = spelldamagefromitem + 25
        end
        if name == "modifier_item_sp25" then
            spelldamagefromitem = spelldamagefromitem + 50
        end
        if name == "modifier_stormrider" then
            spelldamagefromitem = spelldamagefromitem + 75
        end
        if name == "modifier_item_shadowstrike" then
            spelldamagefromitem = spelldamagefromitem + 75
        end
        if name == "modifier_pathbuff_003" then
            spelldamagefromitem = spelldamagefromitem + 100
        end
        if name == "modifier_item_ancient_dragon" then
            spelldamagefromitem = spelldamagefromitem + 80
        end
        if name == "modifier_ancient_allstats" then
            spelldamagefromitem = spelldamagefromitem + 100
        end
        if name == "modifier_item_dreihander_2" then
            spelldamagefromitem = spelldamagefromitem + 200
        end
        if name == "modifier_arcanabracers" then
            spelldamagefromitem = spelldamagefromitem + 100
        end
        if name == "modifier_arcanabracers2" then
            spelldamagefromitem = spelldamagefromitem + 400
        end
        --if name == "modifier_pathbuff_064" then
        --    spelldamagefromitem = spelldamagefromitem + 250
        --end
		if name == "modifier_item_caster5" then
    		spelldamagefromitem = spelldamagefromitem + 12
	    end
	    if name == "modifier_item_sprecipe" then
    		spelldamagefromitem = spelldamagefromitem + 5
	    end
	    if name == "modifier_item_sp" then
    		spelldamagefromitem = spelldamagefromitem + 2
	    end
	    if name == "modifier_item_caster55" then
	    	spelldamagefromitem = spelldamagefromitem + 10*caster:GetMana()/caster:GetMaxMana()
	    end
        if name == "modifier_item_active9up" then
            spelldamagefromitem = spelldamagefromitem + 10*caster:GetMana()/caster:GetMaxMana()
        end
        if name == "modifier_item_ring_arcane_full" then
            spelldamagefromitem = spelldamagefromitem + 0.01*(caster:GetMana()+caster:GetHealth())
        end
        if name == "modifier_item_ring_arcane_full_2" then
            spelldamagefromitem = spelldamagefromitem + 0.01*(caster:GetMana()+caster:GetHealth())
        end
        if name == "modifier_item_winterbreeze3" then
            spelldamagefromitem = spelldamagefromitem + 0.03 * caster:GetMana()
        end
	    if name == "modifier_item_endgame4" then
	    	spelldamagefromitem = spelldamagefromitem + 50
	    end
	    if name == "modifier_item_nova_blade_shadow" then
	    	spelldamagefromitem = spelldamagefromitem + 40
	    end
	    if name == "modifier_item_active5" then
	    	spelldamagefromitem = spelldamagefromitem + 10
	    end
        if name == "modifier_item_active5up" then
            spelldamagefromitem = spelldamagefromitem + 10
        end
	    if name == "modifier_active5" then
	    	spelldamagefromitem = spelldamagefromitem + 10
	    end
        if name == "modifier_active5up_haste" then
            spelldamagefromitem = spelldamagefromitem + 10
        end
	    if name == "modifier_item_aura_sp" then
	    	spelldamagefromitem = spelldamagefromitem + 5
	    end
        if name == "modifier_item_ringofflames" then
            spelldamagefromitem = spelldamagefromitem + 4
        end
	    if name == "modifier_inner_int" then
	    	spelldamagefromitem = spelldamagefromitem + 4
	    end
	    if name == "modifier_item_fireball" then
	    	spelldamagefromitem = spelldamagefromitem + 4
	    end
	    if name == "modifier_item_curseblade" then
	    	spelldamagefromitem = spelldamagefromitem + 3
	    end
	    if name == "modifier_item_allrecipe4" then
	    	spelldamagefromitem = spelldamagefromitem + 4
	    end
        if name == "modifier_item_shield1up" then
            spelldamagefromitem = spelldamagefromitem + 5
        end
	    if name == "modifier_item_aether_lens2" then
	    	spelldamagefromitem = spelldamagefromitem + 12
	    end
	    if name == "modifier_item_shadowmourne" then
	    	spelldamagefromitem = spelldamagefromitem + 25
	    end
        if name == "modifier_aura_sp_immo" then
            spelldamagefromitem = spelldamagefromitem + 50
        end
        if name == "modifier_item_elements3" then
            spelldamagefromitem = spelldamagefromitem + 25
        end
        if name == "modifier_item_elements4" then
            spelldamagefromitem = spelldamagefromitem + 75
        end
        if name == "modifier_item_aura_ancient" then
            spelldamagefromitem = spelldamagefromitem + 25
        end
        if name == "modifier_item_aura_sp_immo" then
            spelldamagefromitem = spelldamagefromitem + 50
        end
        if name == "modifier_item_sp4" then
            spelldamagefromitem = spelldamagefromitem + 125
        end
        if name == "modifier_item_set_int_t3_2_full" then
            spelldamagefromitem = spelldamagefromitem + 60
        end
        if name == "modifier_item_set_int_t3_1_2" then
            spelldamagefromitem = spelldamagefromitem + 50
        end
	    if name == "modifier_shaman_sp_buff" then
	    	spelldamagefromitem = spelldamagefromitem + 5
            factor = factor + 0.15
	    end
	    if name == "modifier_elemental_sp" then
	    	spelldamagefromitem = spelldamagefromitem + caster:GetModifierStackCount("modifier_elemental_sp", nil)
	    end
        if name == "modifier_mythic_sp" then
            spelldamagefromitem = spelldamagefromitem + caster:GetModifierStackCount("modifier_mythic_sp", nil)
        end
	    if name == "modifier_item_set_int_dmg_1" then
	    	spelldamagefromitem = spelldamagefromitem + 10
	    end
	    if name == "modifier_item_set_int_dmg_3" then
	    	spelldamagefromitem = spelldamagefromitem + 10
	    end
        if name == "modifier_item_wolf_cloak_aura_2" then
            spelldamagefromitem = spelldamagefromitem + 8
        end
        if name == "modifier_item_frostfire" then
            spelldamagefromitem = spelldamagefromitem + 20
        end
        if name == "modifier_item_frostfire2" then
            spelldamagefromitem = spelldamagefromitem + 30
        end
        if name == "modifier_item_spellhaste_2" then
            spelldamagefromitem = spelldamagefromitem + 20
        end
        if name == "modifier_itemhaste50" then
            spelldamagefromitem = spelldamagefromitem + 20
        end
        if name == "modifier_spellblood" then
            spelldamagefromitem = spelldamagefromitem + 100
            factor = factor + 0.1
        end
        if name == "modifier_item_item_set_t4_sp_1" then
            spelldamagefromitem = spelldamagefromitem + 50
        end
        if name == "modifier_item_item_set_t4_sp_2" then
            spelldamagefromitem = spelldamagefromitem + 50
        end
        if name == "modifier_item_item_set_t4_sp_3" then
            spelldamagefromitem = spelldamagefromitem + 100
        end
        if name == "modifier_item_item_set_t4_new_3" then
            spelldamagefromitem = spelldamagefromitem + 85
        end
        if name == "modifier_item_item_set_t4_new_4" then
            spelldamagefromitem = spelldamagefromitem + 85
        end
        if name == "modifier_item_spellpower_stack" then
            local spproc = caster:GetModifierStackCount("modifier_item_spellpower_stack", nil)
            spelldamagefromitem = spelldamagefromitem + spproc
        end
        if name == "modifier_pathbuff_031" then
            spelldamagefromitem = spelldamagefromitem + 100
        end
        if name == "modifier_item_myth_sp" then
            spelldamagefromitem = spelldamagefromitem + 400
        end
        if name == "modifier_pathbuff_080" then
            spelldamagefromitem = spelldamagefromitem + 150
        end
	end
    --talents
    local astral_talent_allstats = caster:FindAbilityByName("moon6")
    if not astral_talent_allstats then
        astral_talent_allstats = caster:FindAbilityByName("moon6Temple")
    end
    if astral_talent_allstats and astral_talent_allstats:GetLevel() >= 3 then
        spelldamagefromitem = spelldamagefromitem + (GetStrengthCustom(caster) + GetAgilityCustom(caster)) * 1.5
    end
    astral_talent_allstats = caster:FindAbilityByName("Guardian")
    if astral_talent_allstats and astral_talent_allstats:GetLevel() >= 4 then
        spelldamagefromitem = spelldamagefromitem + 0.75 * GetStrengthCustom(caster)
    end
    astral_talent_allstats = caster:FindAbilityByName("Shadowfury")
    if astral_talent_allstats and astral_talent_allstats:GetLevel() >= 3 then
        spelldamagefromitem = spelldamagefromitem + GetStrengthCustom(caster)
    end
    astral_talent_allstats = caster:FindAbilityByName("Agony2")
    if astral_talent_allstats and astral_talent_allstats:GetLevel() >= 2 then
        spelldamagefromitem = spelldamagefromitem + 0.02 * caster:GetHealth()
    end
    astral_talent_allstats = caster:FindAbilityByName("Lavaburst")
    if astral_talent_allstats and astral_talent_allstats:GetLevel() >= 3 and caster.spellhaste then
        spelldamagefromitem = spelldamagefromitem + caster.spellhaste * 100
    end
    --runeword
    if caster.runeword and caster.runeword[7] then
        spelldamagefromitem = spelldamagefromitem + caster.runeword[7]
    end
    if caster:HasModifier("modifier_item_item_set_t4_sp_4") then
        spelldamagefromitem = spelldamagefromitem + 200
        factor = factor + 0.1
    end
    if caster:HasModifier("modifier_class_ds2") then
        spelldamagefromitem = spelldamagefromitem + 75
    end
    if caster:HasModifier("modifier_rune") then
        spelldamagefromitem = spelldamagefromitem + 75 + 10 * caster:GetModifierStackCount("modifier_rune_sp", nil)
    end
    spelldamagefromitem = spelldamagefromitem + GetInterstellarStat(caster) * 0.5
    if caster:HasModifier("modifier_rune2") then
        spelldamagefromitem = spelldamagefromitem + 250 + 25 * caster:GetModifierStackCount("modifier_rune_sp2", nil)
    end
    if caster:HasModifier("modifier_hptosp2") then
        spelldamagefromitem = spelldamagefromitem + caster:GetHealth() * 0.02 + GetAgilityCustom(caster) * 0.2
    end
    if caster:HasModifier("modifier_hptosp") then
        spelldamagefromitem = spelldamagefromitem + caster:GetHealth() * 0.01 + GetAgilityCustom(caster) * 0.1
    end
    if HeroHasNeutralItem(caster, "item_neutral_39") then
        spelldamagefromitem = spelldamagefromitem + 100
    end
    if caster:HasModifier("modifier_class_winter2") then
        spelldamagefromitem = spelldamagefromitem + 150
        if caster:GetModifierStackCount("modifier_ice_shatter", nil) >= 5 then
            local armor = caster:GetPhysicalArmorValue(false)
            if armor > 0 then
                factor = factor + 0.03 * armor
            end
        end
    end
    if caster:HasModifier("modifier_item_item_set_t4_sp_5") then
        spelldamagefromitem = spelldamagefromitem + 300
        factor = factor + 0.1
    end
    if caster:HasModifier("modifier_path_shadowform") and caster:HasModifier("modifier_pathbuff_073") then
        factor = factor + 0.15
    end
    if caster:HasModifier("modifier_item_spellpower_knowledge") then
        factor = factor + 1
    end
    if caster:HasModifier("modifier_spv") then
        factor = factor + 0.5
    end
    if GetThunderGiantStat(caster) >= 1 then
        factor = factor + GetManaPercentageBonus( caster ) * 0.01 * GetThunderGiantStat(caster)
    end
    if caster.talents then
        if caster.talents[36] then
            spelldamagefromitem = spelldamagefromitem + 100 * caster.talents[36]
        end
        if caster.talents[114] then
            spelldamagefromitem = spelldamagefromitem + 0.1 * caster.talents[114] * GetIntellectCustom(caster)
        end
        if caster.talents[31] then
            factor = factor + 0.25 * caster.talents[31]
        end
        if caster.talents[62] then
            spelldamagefromitem = spelldamagefromitem + 0.04 * caster.talents[62] * (GetStrengthCustom(caster) + GetAgilityCustom(caster) + GetIntellectCustom(caster))
        end
        if caster.talents[2] and caster.talents[2] > 0 then
            spelldamagefromitem = spelldamagefromitem + 25 * caster.talents[2]
        end
        if caster.talents[80] and caster.talents[80] > 0 then
            local bonusfromms = caster:GetMoveSpeedModifier(caster:GetBaseMoveSpeed(), true) - 300
            bonusfromms = bonusfromms * caster.talents[80]
            if bonusfromms > 0 then
                --print(bonusfromms)
                spelldamagefromitem = spelldamagefromitem + bonusfromms
            end
        end
        spelldamagefromitem = spelldamagefromitem + caster:GetMana() * (0.03 * caster.talents[34])
    end
	spelldamagefromitem = spelldamagefromitem * factor
    return spelldamagefromitem
end

function HasDamageReflect(target)
    if target:HasModifier("modifier_shieldreflect") or target:HasModifier("modifier_shieldreflect_only_dmg") then
        return true
    end
    return false
end

function HasBuffReflect( caster, target )
    if target:HasModifier("modifier_shieldreflect") or target:HasModifier("modifier_shieldreflect_charges") or target:HasModifier("modifier_buffreflect") or caster:HasModifier("modifier_dark_mirror") then
        return true
    end
    return false
end

function EchoProc( caster, target )
    local chance = 10
    if caster.ech and caster.ech >= 1 and math.random(1,100) <= chance then
        return 0.01 * caster.ech
    end
    return false
end

function DeepCopyTable(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[DeepCopyTable(orig_key)] = DeepCopyTable(orig_value)
        end
        setmetatable(copy, DeepCopyTable(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function DamageUnit( event )
    local caster = event.caster
	local target = event.target
    --[[
    local echoProc = EchoProc( caster, target )
    if echoProc and not event.is_echo_proc then
        local newEvent = DeepCopyTable(event)
        newEvent.is_echo_proc = echoProc
        Timers:CreateTimer(0.25,function()
            DamageUnit( newEvent )
        end)
    end]]
    local damage = event.damage
    if not damage then
        damage = 0
    end
    local real_caster = caster
	local ability = event.ability
    local elemental_bonus = 1
    local ability_bonus = 1
    local isaoe = false
    local pure_dmg = false
    if event.puredmg then
    	pure_dmg = true
    end
    local is_pet_dmg = false
    if (event.fromsummon or event.fromcompanion or event.ComesFromPet) then
        is_pet_dmg = true
    end
    --if is_pet_dmg and caster and caster.talents and caster.talents[104] > 0 and math.random(1,100) <= 20 + 10 * caster.talents[104] then
    --    event.frostdmg = 1
    --end
    local pvescale = 1
    if caster and not caster:IsNull() and caster.pvescale then
        pvescale = caster.pvescale
    end
    if event.isaoe and event.isaoe >= 1 then
        isaoe = true
    end
    if event.changedamagetoselfcaused then
        caster = target
    end
    if caster == nil then
        return
    else
        if caster:IsNull() then
            return
        end
    end
    if caster and caster.triumpABPGiven and not HeroHasNeutralItem(caster, "item_neutral_31") then
        return
    end
    if event.ComesFromPet and caster.owner then
        caster = caster.owner
    end
	if event.ondealdamagetarget then
		target = event.unit
	end
	if event.ignore_when_target_has_reflect and HasDamageReflect(target) then
		return
	end
    if is_pet_dmg and target and (target:HasModifier("modifier_shieldreflect") or target:HasModifier("modifier_thunder_shield")) then
        return
    end

    --elemental changes
    if event.changefiredmgtoarcane then
        if event.changefiredmgtoarcane == 1 then
            event.firedmg = nil
            event.arcanedmg = 1
            EmitSoundOn("Hero_Invoker.EMP.Cast", target)
        else
            EmitSoundOn("Hero_Invoker.ChaosMeteor.Impact", target)
        end
    end
    if event.firedmg and ability and caster and GetLevelOfAbility(caster, "Molten_Lava") >= 3 then
        event.holydmg = 1
    end
    if caster:HasModifier("modifier_fusion") then
        --color wheel: red(fire) yellow(holy) lightgreen(chaos) darkgreen(nature) blue(frost) pink(arcane) purple(shadow)
        --example: fire holy -> shadow holy fire chaos

        local hasFire = event.firedmg
        local hasHoly = event.holydmg
        local hasChaos = event.chaosdmg
        local hasNature = event.naturedmg
        local hasFrost = event.frostdmg
        local hasArcane = event.arcanedmg
        local hasShadow = event.shadowdmg

        local getsFire = false
        local getsHoly = false
        local getsChaos = false
        local getsNature = false
        local getsFrost = false
        local getsArcane = false
        local getsShadow = false

        -- determine result
        if hasFire then
            getsHoly = true
            getsShadow = true
        end

        if hasHoly then
            getsFire = true
            getsChaos = true
        end

        if hasChaos then
            getsHoly = true
            getsNature = true
        end

        if hasNature then
            getsChaos = true
            getsFrost = true
        end

        if hasFrost then
            getsNature = true
            getsArcane = true
        end

        if hasArcane then
            getsFrost = true
            getsShadow = true
        end

        if hasShadow then
            getsArcane = true
            getsFire = true
        end

        -- apply result
        if getsFire then
            event.firedmg = 1
        else
            event.firedmg = nil
        end

        if getsHoly then
            event.holydmg = 1
        else
            event.holydmg = nil
        end

        if getsChaos then
            event.chaosdmg = 1
        else
            event.chaosdmg = nil
        end

        if getsNature then
            event.naturedmg = 1
        else
            event.naturedmg = nil
        end

        if getsFrost then
            event.frostdmg = 1
        else
            event.frostdmg = nil
        end

        if getsArcane then
            event.arcanedmg = 1
        else
            event.arcanedmg = nil
        end

        if getsShadow then
            event.shadowdmg = 1
        else
            event.shadowdmg = nil
        end

        --print(getsFire)
        --print(getsHoly)
        --print( getsChaos)
        --print(getsNature)
        --print(getsFrost)
        --print(getsArcane)
        --print(getsShadow)
    end
    if event.isdot and caster:HasModifier("modifier_plague_form") then
        event.chaosdmg = 1
    end
    if event.holydmg and caster:HasModifier("modifier_firestone") then
        event.holydmg = nil
        event.firedmg = 1
        event.firestone = 1
    end
    if caster:HasModifier("modifier_icelotus") then
        local frost = event.frostdmg
        local arcane = event.arcanedmg
        if frost then
            event.arcanedmg = 1
            event.frostdmg = nil
            event.icelotus1 = 1
        end
        if arcane then
            event.arcanedmg = nil
            event.frostdmg = 1
            event.icelotus2 = 1
        end
    end
    if event.islavaimp and caster:HasModifier("modifier_class_pugna2") then
        event.chaosdmg = 1
    end
    if caster and caster.talents and caster.talents[139] > 0 and ability and ability:GetLevel() == 4 and math.random(1,100) <= 10 * caster.talents[139] then
        event.chaosdmg = 1
        --print("chaosdm")
    end
    if caster then
        if HeroHasNeutralItem(caster, "item_neutral_6") then
            event.chaosdmg = 1
        end
    end

    --if (event.fromcompanion or event.fromsummon) and target and HasDamageReflect(target) then
    --    return
    --end
    if event.ontakedamage or event.ontakedamagenew then
        caster = event.unit
        target = event.attacker
        if event.ontakedamagenew then
            caster = event.caster
        end
        if (target == caster) or event.isreflected or target:HasModifier("modifier_shieldreflect") or target:HasModifier("modifier_shieldreflect_only_dmg") or caster:HasModifier("modifier_shieldreflect") or caster:HasModifier("modifier_shieldreflect_only_dmg") then
            return
        end
        event.isreflected = true
    end
	if event.targetchangeattacker then
		target = event.attacker
	end
    if event.pveownerbased and event.caster and event.caster.owner then
        caster = event.caster.owner
    end
    if caster == nil then
        return
    else
        if caster:IsNull() then
            return
        end
    end
    if caster and caster:IsNull() then
        return
    end
    if not caster:IsAlive() then
    	if not event.whiledead then
        	return
        end
        if caster:IsNull() then
        	return
        end
    end
    if event.movedenydmg and target:IsMoving() then
        return
    end
    if event.onlywhenmoving then
        if not caster:IsMoving() then
            return
        else
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
    if event.movedenydmg then
        local particle = ParticleManager:CreateParticle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        EmitSoundOn("Hero_Lina.DragonSlave", target)
    end
    if event.nodmgbuffcondition and target and target:HasModifier("fire_save_zone") then
        EmitSoundOn("Item.CrimsonGuard.Cast", target)
        local particle = ParticleManager:CreateParticle("particles/items3_fx/lotus_orb_reflect.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        return
    end
    if event.dmgonbuffcondition and target then
        if not caster:HasModifier(event.dmgonbuffcondition) or caster:GetAbilityByIndex(1):GetLevel() < 4 then
            return
        end
    end
    if event.zonecondition and target and ((target:HasModifier("modifier_farring_buff") and not target:HasModifier("modifier_midring_buff")) or ( not target:HasModifier("modifier_farring_buff") and target:HasModifier("modifier_midring_buff")) ) then
        EmitSoundOn("Item.CrimsonGuard.Cast", target)
        local particle = ParticleManager:CreateParticle("particles/items3_fx/lotus_orb_reflect.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        return
    end
    if event.shadowchance then
        local hawk6 = caster:FindAbilityByName(event.shadowchance)
        if hawk6 and hawk6:GetLevel() >= 2 then
            event.shadowdmg = 1
        end
    end

    local dmgtype = 1
    if ability ~= nil and not ability:IsNull() then
        dmgtype = ability:GetAbilityDamageType()
    end
    if event.changedmgtypetophys then
        dmgtype = 1
    end
    if event.changedmgtypetomagical then
        dmgtype = 2
    end
    if event.poisondmg then
        event.naturedmg = 1
    end
    if event.naturedmg then
        event.poisondmg = 1
    end
    if event.arcanedmg and (caster:HasModifier("modifier_dark") or caster:HasModifier("modifier_dark2")) then
        event.arcanedmg = nil
        event.shadowdmg = 1
        local particle = ParticleManager:CreateParticle("particles/econ/items/witch_doctor/wd_ti8_immortal_head/wd_ti8_immortal_maledict_dark_b.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    local passive_ability
    if caster.talents then
        passive_ability = caster.combat_system_ability
    end
    local distance = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
    if distance > 2500 and not caster.trap_timer and caster:IsRealHero() then
        return
    end
    if target:HasModifier("modifier_pve_act_affix_reflexes") and distance > 600 then
        return
    end
    local behindtarget = false
    local angleDiff = target:GetAngles()[2]-caster:GetAngles()[2]
    if angleDiff < 0.0 then
        angleDiff = -angleDiff
    end

    if (angleDiff <= 90.0 or angleDiff >= 270.0) then
        behindtarget = true
    end

    local attribute_scaling = 0
    local damage_scaling = 0
    local auto_attack_damage_scaling = 0
    local spelldamage_scaling = 0
    if event.attributefactor then
        attribute_scaling = event.attributefactor
    end
    if event.includeauto then
        damage_scaling = event.includeauto
    end
    if event.includefullauto then
        auto_attack_damage_scaling = event.includefullauto
    end
    if event.spelldamagefactor then
        spelldamage_scaling = event.spelldamagefactor
    end


    --update scalings before calc, important for threshold based triggers
    local scaling_factor = 1
    if event.deadlypoisonstack ~= nil then
        local stack = target:GetModifierStackCount("modifier_deadlypoison", nil)
        scaling_factor = scaling_factor * stack
    end
    if event.talentscale and caster.talents[event.talentscale] and caster.talents[event.talentscale] > 0 then
        scaling_factor = scaling_factor * caster.talents[event.talentscale]
    end
    -- based on bleed dot stacks
    if event.feralbleedstack ~= nil then
        scaling_factor = scaling_factor * event.feralbleedstack
    end
    if event.feralcombopointbased ~= nil then
        scaling_factor = scaling_factor * caster.FeralFinisher
    end
    if scaling_factor > 1 then
        attribute_scaling = attribute_scaling * scaling_factor
        damage_scaling = damage_scaling * scaling_factor
        auto_attack_damage_scaling = auto_attack_damage_scaling * scaling_factor
        spelldamage_scaling = spelldamage_scaling * scaling_factor
    end

    if event.enemyhealth then
    	if not target:HasModifier("modifier_pvebosssystem") then
    		damage = target:GetHealth()*event.enemyhealth/100.0
    	else
    		damage = target:GetHealth()*event.enemyhealth/100.0
    	end
    end

    -- warlock souls
    --[[
    if event.generatesoul and event.generatesoul >= 1 then
    	if caster.souls ~= nil then
    		caster.souls = caster.souls + event.generatesoul
    		if caster.souls > event.maxsouls then
    			caster.souls = event.maxsouls
    		end
    	else
    		caster.souls = event.generatesoul
    	end
    	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_souls", nil)
    	caster:SetModifierStackCount("modifier_souls", event.ability, caster.souls)
    end]]
    -- consume
    local nodamageatall = 1
    if event.consumesouls ~= nil then
    	if caster.souls == nil then
    		caster.souls = 0
    	end
    	if ConsumeComboPoints(caster, target) then
            if caster.souls >= event.consumesouls then
                caster.souls = caster.souls - event.consumesouls
                caster:SetModifierStackCount("modifier_souls", event.ability, caster.souls)
                if caster.souls == 0 then
                    caster:RemoveModifierByName("modifier_souls")
                end
                GlobalOnConsumeSoul(caster)
            else
                nodamageatall = 0
            end
        end
    end

    -- add auto attack damage?
	if damage_scaling > 0 then
    	damage = caster:GetAttackDamage() * damage_scaling / 100
    end
    --include green aa damage
    if auto_attack_damage_scaling > 0 then
        damage = damage + caster:GetAverageTrueAttackDamage(caster) * auto_attack_damage_scaling / 100 
    end

    if event.strikeofvengeance and event.strikeofvengeance > 0 then
        if caster.lastdamagetaken then
            damage = damage + caster.lastdamagetaken * event.strikeofvengeance / 100
            if damage > caster:GetMaxHealth() * 10 then
                damage = caster:GetMaxHealth() * 10
            end
            caster.lastdamagetaken = nil
            caster:RemoveModifierByName("modifier_strikeofvengeance")
        end
    end

    if event.difficultyscale and pvescale and COverthrowGameMode.player_count_scale then
        local weaken = 1.0
        if COverthrowGameMode.jungledifficulty >= 20.0 then 
            weaken = 0.75
        end
        --if COverthrowGameMode.jungledifficulty >= 500.0 then 
        --    weaken = weaken * 0.6
        --end
        damage = event.difficultyscale * 0.75 + (event.difficultyscale * pvescale * 0.5)
        damage = damage * COverthrowGameMode.player_count_scale * weaken * GetDifficultyModeDamageFactor()
    end
    if event.difficultyscalelinear and pvescale and COverthrowGameMode.player_count_scale then
        local weaken = 1.0
        --if COverthrowGameMode.jungledifficulty >= 10 then
        --    weaken = 2
        --end
        --if COverthrowGameMode.jungledifficulty >= 100 then
        --    weaken = 3
        --end
        --if COverthrowGameMode.jungledifficulty >= 20.0 then
        --    weaken = 0.75
        --end
        --if COverthrowGameMode.jungledifficulty >= 500.0 then 
        --    weaken = weaken * 0.6
        --end
        damage = event.difficultyscalelinear * pvescale
        damage = damage * COverthrowGameMode.player_count_scale * weaken * GetDifficultyModeDamageFactor()
    end

    local finaldamage = damage

    if event.adjustdamage then
        finaldamage = finaldamage * event.adjustdamage
    end

    -- Spelldamage
    local spelldamagefromitem = 0
    if caster and caster.spelldamage == nil then
    	caster.spelldamage = 0.0
    end
    if spelldamage_scaling > 0.0 and caster.spellpower then
    	spelldamagefromitem = caster.spellpower
    	finaldamage = finaldamage + spelldamage_scaling * spelldamagefromitem / 100.0
    end
    --stat scaling
    if caster:IsHero() then
        local shapeshifter = GetShapeshifterStat(caster)
    	if event.attributechangeint ~= nil then
    		finaldamage = finaldamage + GetIntellectCustom(caster)*attribute_scaling/100.0
    	elseif event.attributechangestr ~= nil then
    		finaldamage = finaldamage + (GetStrengthCustom(caster) + 0.01 * shapeshifter * GetAgilityCustom(caster))*attribute_scaling/100.0
    	elseif event.attributechangeagi ~= nil then
    		finaldamage = finaldamage + GetAgilityCustom(caster)*attribute_scaling/100.0
    	elseif event.attributechangeall ~= nil then
    		finaldamage = finaldamage + GetAgilityCustom(caster)*attribute_scaling/100.0 + GetStrengthCustom(caster)*attribute_scaling/100.0 + GetIntellectCustom(caster)*attribute_scaling/100.0
        elseif event.attributechangestragi ~= nil then
            finaldamage = finaldamage + GetAgilityCustom(caster)*attribute_scaling/100.0 + GetStrengthCustom(caster)*attribute_scaling/100.0
    	else
    		finaldamage = finaldamage + GetPrimaryStatValueCustom(caster) * attribute_scaling / 100
            if caster:GetPrimaryAttribute() == 0 then
                finaldamage = finaldamage + 0.01 * shapeshifter * GetAgilityCustom(caster) * attribute_scaling / 100
            end
    	end
        if caster.talents[75] > 0 then
            local scale = 0.15 * caster.talents[75]
            finaldamage = finaldamage + (GetAgilityCustom(caster) + GetStrengthCustom(caster) + GetIntellectCustom(caster)) * scale
        end
        if caster:HasModifier("modifier_npc_dota_hero_dh2") and caster:HasModifier("modifier_metamorph_dh") then
            finaldamage = finaldamage + 2 * GetStrengthCustom(caster)
        end
        if distance <= 300 and caster:HasModifier("modifier_pikepower") then
            finaldamage = finaldamage + 2.5 * GetStrengthCustom(caster)
        end
	end


    if event.furyexedamage then
        local lifepercent = target:GetHealth()/target:GetMaxHealth()
        local inversed_percent = 1 - lifepercent
        finaldamage = caster:GetAttackDamage()*event.furyexedamage*inversed_percent/100
        if event.furyexecutetalent and event.furyexecutetalent == 1 and caster:GetMana() >= 40 and lifepercent > 0.50 then
            finaldamage = caster:GetAttackDamage()*event.furyexedamage*0.5/100
        end
    end

    if event.counterblow and event.counterblow > 0 then
    	if event.missinghp ~= nil then
    		local missinghealth = target:GetMaxHealth()-target:GetHealth()
    		finaldamage = missinghealth*event.counterblow/100
            if event.ownerhealthcap and caster.owner then
                if finaldamage > caster.owner:GetMaxHealth() * event.ownerhealthcap / 100 then
                    finaldamage = caster.owner:GetMaxHealth() * event.ownerhealthcap / 100
                end
            end
    	else
    		finaldamage = caster:GetHealth()*event.counterblow/100
    		if event.counterblowmax and event.counterblowmax == 1 then
    			finaldamage = caster:GetMaxHealth()*event.counterblow/100
    		end
    	end
    end

    if event.currenthp then
        finaldamage = target:GetHealth()*event.currenthp/100
        if event.cap then
            local cap = caster:GetMaxHealth()*event.cap/100
            if finaldamage > cap then
                finaldamage = cap
            end
        end
    end

    if event.arcanepowerbonus ~= nil then
        if caster:HasModifier("modifier_arcanepower") and not caster:HasModifier("modifier_burning_nether") then
            local stack = caster:GetModifierStackCount("modifier_arcanepower", caster)
            if stack <= event.apcharges then
                caster:RemoveModifierByName("modifier_arcanepower")
            else
                caster:SetModifierStackCount("modifier_arcanepower", event.ability, stack-event.apcharges)
                stack = event.apcharges
            end
            if event.maxmanabonus and event.maxmanabonus > 0 then
                finaldamage = finaldamage + caster:GetMana()*event.maxmanabonus/100
            end
            finaldamage = finaldamage*stack
            caster.ArcanePowerDot = finaldamage
        else
            -- in burning nether, no new dot applied
            if event.maxmanabonus and event.maxmanabonus > 0 then
                finaldamage = finaldamage + caster:GetMana()*event.maxmanabonus/100
            end
            finaldamage = (finaldamage * (1 + event.netherwizarddot / 25) ) * event.apcharges
            --caster.ArcanePowerDot = finaldamage
            -- no resources
            if not caster:HasModifier("modifier_burning_nether") and not caster:HasModifier("modifier_arcanepower") then
                finaldamage = 0
                caster.ArcanePowerDot = 0
            end
        end 
    end

    if event.maxmanabonus and event.maxmanabonus > 0 then
        finaldamage = finaldamage + caster:GetMana()*event.maxmanabonus/100
    end

    if event.shieldbashbonus then
        finaldamage = finaldamage * ( 1 + 0.1*event.shieldbashbonus)
    end
    local fury_stacks = caster:GetModifierStackCount("modifier_furyas", nil)
    if event.furyexedamage and fury_stacks > 0 then
        finaldamage = finaldamage * (1 + 0.05 * fury_stacks)
    end
    if event.arcanepowerbonusdot ~= nil then
        finaldamage = caster.ArcanePowerDot * event.arcanepowerbonusdot / 100
    end

    if event.shadoworb then
        local bonusfactor = target:GetModifierStackCount("modifier_swd", nil)
        finaldamage = finaldamage*bonusfactor
    end

    if event.stackbased then
        local bonusfactor = 2*(target:GetModifierStackCount("modifier_dragon_dot", nil)-1)
        finaldamage = finaldamage + finaldamage*bonusfactor
    end

    if event.buffstackbasedbuff then
        local bonusfactor = target:GetModifierStackCount(event.buffstackbasedbuff, nil)
        finaldamage = finaldamage*bonusfactor
    end

    if event.stackthresholdbased then
        local max = event.stackthresholdbased
        local bonusfactor = target:GetModifierStackCount(event.stackbasedbuff, nil) / max
        if bonusfactor < 1.0 then
            finaldamage = 0.0
        end
    end
    
    if event.stackthresholdbasedfactor then
        local max = event.stackthresholdbasedfactor
        local bonusfactor = target:GetModifierStackCount(event.stackbasedbuff, nil) / max
        if bonusfactor >= 1.0 then
            finaldamage = finaldamage * event.stackthresholdbaseddamagefactor
        end
    end

    if event.rangerexecute then
        if  target:GetHealth()/target:GetMaxHealth() < 0.5 then
            finaldamage = finaldamage * (1 + event.rangerexecute/100)
            local particle = ParticleManager:CreateParticle("particles/econ/items/gyrocopter/hero_gyrocopter_gyrotechnics/gyro_death_explosion.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
            particle = ParticleManager:CreateParticle("particles/units/heroes/hero_skeletonking/skeletonking_mortalstrike_explosion.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
    if event.execute ~= nil then
        if target:GetHealth()/target:GetMaxHealth() < 0.5 then
            finaldamage = finaldamage * (1 + event.execute/100)
        end 
    end

    if event.warlockagony ~= nil then
        finaldamage = 0.1*finaldamage*caster.AgonyCounter
    end

    local winter_chills = caster:GetModifierStackCount("modifier_winterschill", nil)
    if event.icelance and (winter_chills >= 2 or target:HasModifier("modifier_icenova") or target:HasModifier("modifier_deepfreeze") or target:HasModifier("modifier_icenova_slow")) then
        if not (target:HasModifier("modifier_icenova") or target:HasModifier("modifier_deepfreeze") or target:HasModifier("modifier_icenova_slow")) then
            caster:RemoveModifierByName("modifier_winterschill")
        end
        finaldamage = finaldamage * 3
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ancient_apparition/ancient_apparition_ice_blast_death.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
    end

    --cp based scaling
    if event.cpbaseddmg then
        finaldamage = finaldamage * caster.cpbaseddmg
    end
    --pve scaling
    if event.pvescale then
        finaldamage = finaldamage * pvescale
    end
    if event.damage_scale then
        finaldamage = finaldamage * event.damage_scale
    end
    if event.missing_hp_scale then
        finaldamage = finaldamage * (1 - (caster:GetHealth() / caster:GetMaxHealth()))
        if finaldamage == 0 then
            return
        end
    end
    if caster:HasModifier("modifier_temple_tower") and not caster:IsMoving() then
        finaldamage = finaldamage * 1.45
    end
    
    --[[unused
    if event.stackpercentbased then
        local max = event.stackpercentbased
        local bonusfactor = target:GetModifierStackCount(event.stackbasedbuff, nil) / max
        finaldamage = finaldamage*bonusfactor
    end
    --]]

    --test
    --print(caster:GetAttackSpeed())
    --print(caster:GetAttacksPerSecond())
    --print(caster:GetIncreasedAttackSpeed())
    --local is_big_hit = false
    --if caster:IsRealHero() and finaldamage >= caster:GetPrimaryStatValue() * 6 then
    --    is_big_hit = true
    --end
    local is_very_big_hit = false
    local is_500_big_hit = false
    local very_big_hit_threshold = 600
    local big_hit_500_threshold = 500
    if (damage_scaling >= very_big_hit_threshold) or (attribute_scaling >= very_big_hit_threshold) or (spelldamage_scaling >= very_big_hit_threshold) or (auto_attack_damage_scaling >= very_big_hit_threshold) then
    --if GetHighestAbilityScaling(event) >= very_big_hit_threshold then
        is_very_big_hit = true
    end
    if (damage_scaling > big_hit_500_threshold) or (attribute_scaling > big_hit_500_threshold) or (spelldamage_scaling > big_hit_500_threshold) or (auto_attack_damage_scaling > big_hit_500_threshold) then
        is_500_big_hit = true
    end
    if event.furyexedamage and event.furyexedamage >= very_big_hit_threshold then
    	is_very_big_hit = true
    end
    local damageBasedOnHPFactor = 1
    if caster:HasModifier("modifier_big") then
        damageBasedOnHPFactor = damageBasedOnHPFactor * 1.25
    elseif caster:HasModifier("modifier_big2") then
        damageBasedOnHPFactor = damageBasedOnHPFactor * 1.5
    end
    if event.shadowdmg and GetBlackMirrorStat(caster) >= 1 then
        finaldamage = finaldamage + (caster:GetAttackDamage() + GetSpellpower(event)) * 0.01 * GetBlackMirrorStat(caster)
    end
    if caster.talents then
        if caster.talents[2] then
            finaldamage = finaldamage + (caster:GetAttackDamage() + GetSpellpower(event)) * 0.1 * caster.talents[2]
        end
        if caster.talents[128] > 0 and event.isaoe then
            finaldamage = finaldamage + (GetAllStats(caster) + GetSpellpower(event)) * (0.5 + 0.5 * caster.talents[128])
        end
        --if caster.talents[148] > 0 then
        --    finaldamage = finaldamage + (GetStrengthCustom(caster) + GetAgilityCustom(caster)) * 0.25 * caster.talents[148]
        --end
        --if caster.talents[49] then
        --    finaldamage = finaldamage + caster:GetPrimaryStatValue() * 0.15 * caster.talents[49]
        --end
        if caster.talents[8] then
            local ancient = 1
            if caster:HasModifier("modifier_item_silverblood4") then
                ancient = 2
            end
            finaldamage = finaldamage + caster:GetHealth() * 0.005 * caster.talents[8] * ancient * damageBasedOnHPFactor
        end
        if caster.talents[115] and event.isaoe then
            finaldamage = finaldamage + caster:GetHealth() * 0.01 * caster.talents[115] * damageBasedOnHPFactor
        end
    end
    if ability and ability:GetAbilityIndex() == 1 then
        if caster:HasModifier("modifier_coloss") then
            finaldamage = finaldamage + caster:GetHealth() * 0.03 * damageBasedOnHPFactor
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti8/blink_dagger_ti8_end_ray.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
        end
        if caster:HasModifier("modifier_coloss2") then
            finaldamage = finaldamage + caster:GetHealth() * 0.05 * damageBasedOnHPFactor
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti8/blink_dagger_ti8_end_ray.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
    --pet base health bonuses
    if is_pet_dmg then
        if caster:HasModifier("modifier_beastrage") then
            local beast_rage = caster:FindAbilityByName("Beastrage")
            if beast_rage and beast_rage:GetLevel() >= 4 then
                finaldamage = finaldamage + caster:GetHealth() * 0.1 * damageBasedOnHPFactor
            end
        end
        if caster:HasModifier("modifier_tamerbond") then
            finaldamage = finaldamage + caster:GetHealth() * 0.05 * damageBasedOnHPFactor
        end
    end

    -- range based
    if event.rangeinverted and event.rangeinverted > 0.0 then
        local r = event.rangeinverted - 150
        local dist = (caster:GetAbsOrigin() - target:GetAbsOrigin()):Length()-150
        if dist < 0.0 then
            dist = 1.0
        end
        if r < 0.0 then
            r = 1.0
        end
        local bonusfactor = dist / r
        if bonusfactor > 1.0 then
            bonusfactor = 1.0
        end
        finaldamage = finaldamage*bonusfactor
    end
    if finaldamage == 0 then 
        return
    end
    if event.damage_factor_single_target then
        finaldamage = finaldamage * event.damage_factor_single_target
    end

    --new artifact ele dmg attribute
    if event.firedmg then
    	local eledmg_bonus = 0
    	local constant_ele_dmg_factor = 1
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
	    if caster:HasModifier("modifier_pathbuff_029") then
	    	eledmg_bonus = eledmg_bonus + 150
	    end
        local wind5 = caster:FindAbilityByName("wind5")
        if wind5 and wind5:GetLevel() >= 4 and caster:GetIncreasedAttackSpeed(false) > 0 then
            eledmg_bonus = eledmg_bonus + 100 * caster:GetIncreasedAttackSpeed(false)
        end
        if caster:HasModifier("modifier_pathbuff_062") then
            eledmg_bonus = eledmg_bonus + 400
        end
        if caster:HasModifier("modifier_firebow") or caster:HasModifier("modifier_firebow2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 3
        end
        if caster:HasModifier("modifier_crown3") or caster:HasModifier("modifier_crown2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 3
        end
        finaldamage = finaldamage + (caster:GetModifierStackCount("modifier_mythic_firedmgd", nil) + eledmg_bonus) * constant_ele_dmg_factor
    end
    if event.arcanedmg then
    	local constant_ele_dmg_factor = 1
    	local eledmg_bonus = 0
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
	    if caster:HasModifier("modifier_pathbuff_025") then
	    	eledmg_bonus = eledmg_bonus + 750
	    end
        if caster:HasModifier("modifier_pathbuff_062") then
            eledmg_bonus = eledmg_bonus + 400
        end
        if caster:HasModifier("modifier_crown3") or caster:HasModifier("modifier_crown2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 3
        end
        finaldamage = finaldamage + (caster:GetModifierStackCount("modifier_mythic_arcanedmgd", nil) + eledmg_bonus) * constant_ele_dmg_factor
    end
    if event.naturedmg then
    	local constant_ele_dmg_factor = 1
    	local eledmg_bonus = 0
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
    	if caster:HasModifier("modifier_bladerush") and caster:HasModifier("modifier_item_rogueblades2") then
    		constant_ele_dmg_factor = constant_ele_dmg_factor * 2
    	end
    	if event.starfallbonus then
    		constant_ele_dmg_factor = constant_ele_dmg_factor * 2
    	end
    	if caster:HasModifier("modifier_pathbuff_056") then
	    	eledmg_bonus = eledmg_bonus + 150
	    end
        if caster:HasModifier("modifier_pathbuff_114") then
            eledmg_bonus = eledmg_bonus + 250
        end
        if caster:HasModifier("modifier_pathbuff_062") then
            eledmg_bonus = eledmg_bonus + 400
        end
        if caster:HasModifier("modifier_crown3") or caster:HasModifier("modifier_crown2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 3
        end
        finaldamage = finaldamage + (caster:GetModifierStackCount("modifier_mythic_naturedmgd", nil) + eledmg_bonus) * constant_ele_dmg_factor
    end
    if event.shadowdmg then
    	local constant_ele_dmg_factor = 1
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
    	if caster:HasModifier("modifier_class_warlock") and target:HasModifier("modifier_dot1") then
    		constant_ele_dmg_factor = constant_ele_dmg_factor * 2
    	end
    	local eledmg_bonus = 0
    	if caster:HasModifier("modifier_pathbuff_062") then
	        eledmg_bonus = eledmg_bonus + 400
	    end
        if caster:HasModifier("modifier_pathbuff_114") then
            eledmg_bonus = eledmg_bonus + 250
        end
        if caster.talents and caster.talents[95] and caster.talents[95] > 0 then
            eledmg_bonus = eledmg_bonus + 0.05 * (GetStrengthCustom(caster) + GetAgilityCustom(caster) + GetIntellectCustom(caster)) * caster.talents[95]
        end
        if caster:HasModifier("modifier_crown3") or caster:HasModifier("modifier_crown2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 3
        end
        finaldamage = finaldamage + (caster:GetModifierStackCount("modifier_mythic_shadowdmgd", nil) + eledmg_bonus) * constant_ele_dmg_factor
    end
    if event.frostdmg then
    	local constant_ele_dmg_factor = 1
        local eledmg_bonus = 0
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
        if caster:HasModifier("modifier_pathbuff_062") then
            eledmg_bonus = eledmg_bonus + 400
        end
        --if caster.talents and caster.talents[104] and caster.talents[104] > 0 then
        --    eledmg_bonus = eledmg_bonus + 0.5 * caster.talents[104] * GetStrengthCustom(caster)
        --end
    	if caster:HasModifier("modifier_pathbuff_055") then
    		constant_ele_dmg_factor = constant_ele_dmg_factor * 2
    	end
        if caster.talents and caster.talents[95] and caster.talents[95] > 0 then
            eledmg_bonus = eledmg_bonus + 0.05 * (GetStrengthCustom(caster) + GetAgilityCustom(caster) + GetIntellectCustom(caster)) * caster.talents[95]
        end
        if caster:HasModifier("modifier_crown3") or caster:HasModifier("modifier_crown2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 3
        end
        finaldamage = finaldamage + (caster:GetModifierStackCount("modifier_mythic_frostdmgd", nil) + eledmg_bonus) * constant_ele_dmg_factor
    end
    if event.holydmg then
    	local constant_ele_dmg_factor = 1
        local eledmg_bonus = 0
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
        local retri6 = caster:FindAbilityByName("Retri6")
        if retri6 and retri6:GetLevel() >= 3 then
            eledmg_bonus = eledmg_bonus + 5 * (GetAgilityCustom(caster) + GetIntellectCustom(caster))
        end
        if caster:HasModifier("modifier_pathbuff_062") then
            eledmg_bonus = eledmg_bonus + 400
        end
        if caster:HasModifier("modifier_crown3") or caster:HasModifier("modifier_crown2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 3
        end
        finaldamage = finaldamage + (caster:GetModifierStackCount("modifier_mythic_holydmgd", nil) + eledmg_bonus) * constant_ele_dmg_factor
    end
    if event.chaosdmg then
    	local constant_ele_dmg_factor = 1
        local eledmg_bonus = 0
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
        local dh5 = caster:FindAbilityByName("dh5")
        if dh5 and dh5:GetLevel() >= 3 then
            eledmg_bonus = eledmg_bonus + GetAgilityCustom(caster)
        end
        --if caster.talents and caster.talents[104] and caster.talents[104] > 0 and caster:HasModifier("modifier_pathbuff_068") then
        --    eledmg_bonus = eledmg_bonus + 0.5 * caster.talents[104] * GetStrengthCustom(caster)
        --end
        if caster:HasModifier("modifier_chaosshield") then
            eledmg_bonus = eledmg_bonus + 200
        end
        if caster:HasModifier("modifier_pathbuff_062") then
            eledmg_bonus = eledmg_bonus + 400
        end
        if caster:HasModifier("modifier_chaosshield2") then
            eledmg_bonus = eledmg_bonus + 750
        end
        if caster.talents and caster.talents[95] and caster.talents[95] > 0 and caster:HasModifier("modifier_pathbuff_095") then
            eledmg_bonus = eledmg_bonus + 0.05 * (GetStrengthCustom(caster) + GetAgilityCustom(caster) + GetIntellectCustom(caster)) * caster.talents[95]
        end
        if caster:HasModifier("modifier_crown3") or caster:HasModifier("modifier_crown2") then
            constant_ele_dmg_factor = constant_ele_dmg_factor * 2
        end
        finaldamage = finaldamage + (caster:GetModifierStackCount("modifier_mythic_chaosdmgd", nil) + eledmg_bonus) * constant_ele_dmg_factor
    end
    if dmgtype == 1 then
    	local constant_ele_dmg_factor = 1
    	if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    		local ice_storm_bonus = (1 + 0.3333 * caster.talents[127])
	        constant_ele_dmg_factor = constant_ele_dmg_factor * ice_storm_bonus
	    end
    	if caster:HasModifier("modifier_bladerush") and caster:HasModifier("modifier_item_rogueblades2") then
    		constant_ele_dmg_factor = constant_ele_dmg_factor * 2
    	end
        finaldamage = finaldamage + caster:GetModifierStackCount("modifier_mythic_physicaldmgd", nil) * constant_ele_dmg_factor
    end
    

    ------------------------------------------------------------------------------------------------------------------------
    --base damage calcs finished

    --dmgprocs
    if event.bloodwolf then
        ChannelProcs(caster)
    end

    --------------------------------------------------------------------------------------------------------------------------------
    --spellcrits ALL
    local critchance = 0
    local critchancefactor = 1.0
    local critdmgbonusfactor = 1.0
    local critpossible = true
    if event.cannotcrit then
        critpossible = false
    end
    
    if event.chaosbolt ~= nil then
        critdmgbonusfactor = 1.15
        critchancefactor = 2.5
    end
    if event.critchancefactor ~= nil then
        critchancefactor = event.critchancefactor
    end
    if event.critdmgbonusfactor ~= nil then
        critdmgbonusfactor = event.critdmgbonusfactor
    end
    local rangercritdmg = caster:FindAbilityByName("glacier_crack_spell")
    if rangercritdmg and rangercritdmg:GetLevel() >= 3 then
        critdmgbonusfactor = critdmgbonusfactor + 0.15
    end
    local shaolincritdmg = caster:FindAbilityByName("deadly1")
    if shaolincritdmg and shaolincritdmg:GetLevel() >= 3 then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster.is_monk then
        critdmgbonusfactor = critdmgbonusfactor + 0.1
    end
    if HeroHasNeutralItem(caster, "item_neutral_39") then
        critdmgbonusfactor = critdmgbonusfactor + 0.1
    end
    if caster:HasModifier("modifier_rogue_ambush_bonus2") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    local roguecritchance = caster:FindAbilityByName("Shadow_Walk")
    if roguecritchance and roguecritchance:GetLevel() >= 3 then
        critchancefactor = critchancefactor + 0.5
    end
    if caster:HasModifier("modifier_item_myth_aa") then
        critchancefactor = critchancefactor + 0.25
    end
    if event.starfallbonus and caster:HasModifier("modifier_pathbuff_023") then
        critchancefactor = critchancefactor + 0.25
    end
    if event.isdot and dmgtype == 1 and GetHemorrhageStat(caster) >= 1 then
        critchancefactor = critchancefactor + 0.01 * GetHemorrhageStat(caster)
    end
    if big_hit_500_threshold and GetMassiveMassacreStat(caster) >= 1 then
        critdmgbonusfactor = critdmgbonusfactor + 0.01 * GetMassiveMassacreStat(caster)
    end
    if event.ignitecritchancefactor and target:HasModifier("modifier_magmaburn2") then
        critchancefactor = critchancefactor + 1
    end
    if (event.fromsummon or event.fromcompanion or event.ComesFromPet) and caster:HasModifier("modifier_tamerbond") then
        critdmgbonusfactor = critdmgbonusfactor + 0.5
    end
    local stoneSkin = caster:GetModifierStackCount("modifier_stoneskin", nil)
    if stoneSkin >= 1 and caster:HasModifier("modifier_pathbuff_109") and caster.talents[109] then
        critdmgbonusfactor = critdmgbonusfactor + 0.01 * stoneSkin * caster.talents[109]
    end
    if ability then
        critdmgbonusfactor = critdmgbonusfactor + LunarEclipseProc(caster)
    end
    --local arcane_barrage_stacks = caster:GetModifierStackCount("modifier_arcane_barrage_bonus", nil)
    --local arcane_barrage_ability = caster:FindAbilityByName("Arcane2")
    --if arcane_barrage_stacks > 0 and arcane_barrage_ability and arcane_barrage_ability:GetLevel() >= 3 then
    --   critchancefactor = critchancefactor + 0.06 * arcane_barrage_stacks
    --end
    local dhcrittalent = caster:FindAbilityByName("dh4")
    if dhcrittalent and dhcrittalent:GetLevel() >= 3 then
        critdmgbonusfactor = critdmgbonusfactor + 0.15
    end
    --local riki_dance_shadows_crit_talent = caster:FindAbilityByName("hawk3")
    --if riki_dance_shadows_crit_talent and riki_dance_shadows_crit_talent:GetLevel() >= 4 then
    --    critdmgbonusfactor = critdmgbonusfactor + 0.5
    --end
    if caster:HasModifier("modifier_item_ancient_elune") then
        --local tiger_stack = caster:GetModifierStackCount("modifier_talent_tiger_prowl", nil)
        critdmgbonusfactor = critdmgbonusfactor + 0.15  -- + 0.05 * tiger_stack
    end
    if caster:HasModifier("modifier_crit_dmg_50") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    --agility stat
    if caster:IsRealHero() then
        local extra = 0
        if caster.talents[116] > 0 then
            extra = 0.0001 * caster.talents[116]
        end
        critdmgbonusfactor = critdmgbonusfactor + (0.0005 + extra) * GetAgilityCustom(caster)
    end
    if caster:HasModifier("modifier_class_sven2") and caster:GetModifierStackCount("modifier_froststr", nil) >= 5 and not event.isaoe then
        critdmgbonusfactor = critdmgbonusfactor + 0.003 * GetAgilityCustom(caster)
    end
    local axecrittalent = caster:FindAbilityByName("Wounding_Strike")
    if axecrittalent and axecrittalent:GetLevel() >= 4 then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    local artifact_crit_dmg = caster:GetModifierStackCount("modifier_mythic_critdmg", nil)
    if artifact_crit_dmg > 0 then
        critdmgbonusfactor = critdmgbonusfactor + 0.01 * artifact_crit_dmg
    end
    if caster:HasModifier("modifier_item_element_frost") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster.lifeblood and caster.lifeblood > 1 and caster.talents and caster.talents[74] and caster.talents[74] > 0 and caster.path_sacrifice_souls_paid and caster:HasModifier("modifier_pathbuff_074") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster:HasModifier("modifier_pathbuff_082") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster:HasModifier("modifier_element_chaos") then
        critdmgbonusfactor = critdmgbonusfactor + 0.3
    end
    if caster:HasModifier("modifier_item_crit_frost_immortal") then
        critdmgbonusfactor = critdmgbonusfactor + 0.4
    end
    if caster:HasModifier("modifier_item_crit_frost_immortal2") then
        critdmgbonusfactor = critdmgbonusfactor + 0.5
    end
    if caster:HasModifier("modifier_molten_blade") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster:HasModifier("modifier_crit_aura_dragon") then
        critdmgbonusfactor = critdmgbonusfactor + 0.2
    end
    if caster:HasModifier("modifier_crit_aura_dragon_2") then
        critdmgbonusfactor = critdmgbonusfactor + 0.3
    end
    if caster:HasModifier("modifier_item_windforce2") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster:HasModifier("modifier_item_bootscrit_2") then
        critdmgbonusfactor = critdmgbonusfactor + 0.1
    end
    if caster:HasModifier("modifier_pathbuff_049") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster:HasModifier("modifier_special_bonus_vision") then
        critdmgbonusfactor = critdmgbonusfactor + 0.1
    end
    if caster:HasModifier("modifier_item_bootscrit4") then
        critdmgbonusfactor = critdmgbonusfactor + 0.35
    elseif caster:HasModifier("modifier_item_bootscrit3") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    elseif caster:HasModifier("modifier_item_bootscrit2") then
        critdmgbonusfactor = critdmgbonusfactor + 0.15
    end
    if caster:HasModifier("modifier_crit_dmg_t3") then
        critdmgbonusfactor = critdmgbonusfactor + 0.15
    end
    if caster:HasModifier("modifier_crit_dmg_t3_2") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster:HasModifier("modifier_crit_dmg_riki_50") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25
    end
    if caster:HasModifier("modifier_path_shadowform") then
        critdmgbonusfactor = critdmgbonusfactor + 0.25 * caster.talents[73]
    end
    if caster:HasModifier("modifier_heartbreaker") then
        local dmgfactor = 0.0001
        if caster:HasModifier("modifier_path_shadowform") and caster:HasModifier("modifier_pathbuff_103") then
            dmgfactor = dmgfactor * 1.5
        end
        critdmgbonusfactor = critdmgbonusfactor + dmgfactor * caster.talents[103] * GetStrengthCustom(caster)
    end
    local armortocrit = caster:FindAbilityByName("Switch_Battle_Stance_Prot")
    if not armortocrit then
        armortocrit = caster:FindAbilityByName("temple_brawler_defstance")
    end
    if armortocrit and armortocrit:GetLevel() >= 3 then
        critdmgbonusfactor = critdmgbonusfactor + 0.005 * caster:GetPhysicalArmorValue(false)
    end
    armortocrit = caster:FindAbilityByName("Waterelemental")
    if armortocrit and armortocrit:GetLevel() >= 4 then
        critdmgbonusfactor = critdmgbonusfactor + 0.01 * caster:GetPhysicalArmorValue(false)
    end
    --local empowertocrit = caster:GetModifierStackCount("modifier_talent_onheal_armor", nil)
    --if empowertocrit and empowertocrit > 0 then
    --    critdmgbonusfactor = critdmgbonusfactor + 0.01 * empowertocrit
    --end
    
    if caster.talents and caster.talents[17] and caster.talents[17] > 0 then
        local fullmoon_critbonus = 0.05 + 0.05 * caster.talents[17]
        if event.starfallbonus and caster:HasModifier("modifier_pathbuff_023") then
            fullmoon_critbonus = fullmoon_critbonus * 2
        end
        critdmgbonusfactor = critdmgbonusfactor + fullmoon_critbonus
    end
    if caster.talents and caster.talents[79] and (event.fromcompanion or event.fromsummon or event.ComesFromPet) then
        critdmgbonusfactor = critdmgbonusfactor + 0.25 * caster.talents[79]
    end
    local flatCritChance = GetFlatCritChance(caster) * critchancefactor
    if critpossible == true and is_very_big_hit and caster.talents and caster.talents[62] and caster.talents[62] > 0 then
        critchance = critchancefactor * caster.talents[62] + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*3*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible and HeroHasNeutralItem(caster, "item_neutral_40") then
        critchance = critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*10*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and is_very_big_hit and caster.talents and caster.talents[22] and caster.talents[22] > 0 and caster.moonlightcrits and caster.moonlightcrits > 0 and not event.dragondmg then
        finaldamage = finaldamage * critdmgbonusfactor * (1.5 + 0.5 * caster.talents[22])
        critpossible = false
        if caster:HasModifier("modifier_item_windforce4") then
            finaldamage = finaldamage*1.25
        end
        caster.moonlightcrits = caster.moonlightcrits - 1
        StarsAlignFX(target)
        if caster:HasModifier("modifier_pathbuff_022") then
            event.arcanedmg = 1
        end
    end
    if critpossible == true and is_very_big_hit and caster.talents and caster.talents[22] and caster.talents[22] > 0 and not caster:HasModifier("modifier_crit_moon_cd") and not event.dragondmg then
        finaldamage = finaldamage * critdmgbonusfactor * (1.5 + 0.5 * caster.talents[22])
        critpossible = false
        local ancient = 0
        if caster:HasModifier("modifier_item_windforce4") then
            ancient = 5
            finaldamage = finaldamage*1.25
        end
        if not caster:HasModifier("modifier_pathbuff_017") or (caster:HasModifier("modifier_pathbuff_017") and math.random(1,100) <= 75) then
            local stars_aligned_cd = 15 - ancient
            if (not caster:IsRangedAttacker()) and caster:HasModifier("modifier_pathbuff_012") then
                stars_aligned_cd = stars_aligned_cd / 2
            end
            passive_ability:ApplyDataDrivenModifier(caster, caster, "modifier_crit_moon_cd", { Duration = stars_aligned_cd})
        end
        if caster:HasModifier("modifier_item_set_agi_t3_full_dream") then
            caster.moonlightcrits = 1 -- 1 extra crit
        end
        StarsAlignFX(target)
        event.was_stars_aligned_first_crit = true
        if caster:HasModifier("modifier_pathbuff_022") then
            event.arcanedmg = 1
        end
    end
    if critpossible == true and event.envenom and caster:HasModifier("modifier_coldblood") then
        local killdance = caster:FindAbilityByName("combat5")
        if killdance then
            local lvl = killdance:GetLevelSpecialValueFor("crit", (caster:GetAbilityByIndex(4):GetLevel() - 1))
            finaldamage = finaldamage*lvl*critdmgbonusfactor
            critpossible = false
            caster:RemoveModifierByName("modifier_coldblood")
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_set_agi_set_crit_t1_2") then
        critchance = 5*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*3*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible and GetLevelOfAbility(caster, "frostdk3") >= 4 then
        critchance = 5 * critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*3*critdmgbonusfactor
            critpossible = false
        end
    end
    local worldBreakerModifier = caster:FindModifierByName("modifier_item_crit_pure_immortal2")
    if critpossible == true and worldBreakerModifier then
        local worldBreakerModifierAbility = worldBreakerModifier:GetAbility()
        if(worldBreakerModifierAbility) then
            critchance = worldBreakerModifierAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor + flatCritChance
            local critDmgFactor = worldBreakerModifierAbility:GetSpecialValueFor("bonus_stat2") / 100
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible and event.icelotus1 then
        local iceLotusModifier = caster:FindModifierByName("modifier_icelotus")
        if(iceLotusModifier) then
            local iceLotusModifierAbility = iceLotusModifier:GetAbility()
            if(iceLotusModifierAbility) then
                local critDmgFactor = iceLotusModifierAbility:GetSpecialValueFor("stat3") / 100
                critchance = iceLotusModifierAbility:GetSpecialValueFor("stat2")*critchancefactor + flatCritChance
                if math.random(1,100) <= critchance then
                    finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                    critpossible = false
                end
            end
        end
        event.icelotus1 = nil
    end
    if critpossible and event.icelotus2 then
        local iceLotusModifier = caster:FindModifierByName("modifier_icelotus")
        if(iceLotusModifier) then
            local iceLotusModifierAbility = iceLotusModifier:GetAbility()
            if(iceLotusModifierAbility) then
                local critDmgFactor = iceLotusModifierAbility:GetSpecialValueFor("stat3") / 100
                critchance = iceLotusModifierAbility:GetSpecialValueFor("stat2")*critchancefactor + flatCritChance
                if math.random(1,100) <= critchance then
                    finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                    critpossible = false
                end
            end
        end
        event.icelotus2 = nil
    end
    if critpossible == true and caster.talents and caster.talents[94] and caster.talents[94] > 0 and ability and ability:GetCooldown(ability:GetLevel()) <= 3 then
        critchance = critchancefactor * 5 * caster.talents[94] + flatCritChance
        if caster.deadfury_crit_chance_factor then
            critchance = critchance * caster.deadfury_crit_chance_factor
        end
        if math.random(1,100) <= critchance then
            caster.deadfury_crit_chance_factor = nil
            finaldamage = finaldamage*3*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and is_pet_dmg and caster.bookofdeadCrit then
        caster.bookofdeadCrit = false
        finaldamage = finaldamage * 2.5 * critdmgbonusfactor
        critpossible = false
    end
    if critpossible == true and caster:HasModifier("modifier_mythic_abilcrit") then
        critchance = critchancefactor * caster:GetModifierStackCount("modifier_mythic_abilcrit", nil) + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.frostdmg and GetShiveringColdStat(caster) > 0 and GetHighestAbilityScaling(event) >= 500 then
        critchance = critchancefactor * GetShiveringColdStat(caster) + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2.5*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_fury_crit") then
        critchance = critchancefactor * caster:GetModifierStackCount("modifier_fury_crit", nil) + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2.5*critdmgbonusfactor
            critpossible = false
            caster:RemoveModifierByName("modifier_fury_crit")
        end
    end
    local riggedDiceModifier = caster:FindModifierByName("modifier_item_crit_myth")
    if critpossible == true and riggedDiceModifier then
        local riggedDiceModifierAbility = riggedDiceModifier:GetAbility()
        if(riggedDiceModifierAbility) then
            critchance = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor + flatCritChance
            local critDmgFactor = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat4") / 100
    
            if caster:HasModifier("modifier_crit_myth") then
                critchance = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat5")*critchancefactor + flatCritChance
                critDmgFactor = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat6") / 100
            end
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible == true and caster:HasModifier("modifier_pathbuff_069") and (event.fromcompanion or event.fromsummon or event.ComesFromPet) then
        critchance = 15 * critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    local maskOfHorrorModifier = caster:FindModifierByName("modifier_ancient_def")
    if critpossible == true and maskOfHorrorModifier then
        local maskOfHorrorModifierAbility = maskOfHorrorModifier:GetAbility()
        if(maskOfHorrorModifierAbility) then
            critchance = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat8")*critchancefactor + flatCritChance
            local critDmgFactor = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat9") / 100
            if caster:HasModifier("modifier_horror_proc") then
                critchance = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat10")*critchancefactor + flatCritChance
                critDmgFactor = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat11") / 100
            end
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_ancient_wolf") then
        critchance = 10*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster.talents and caster.talents[158] > 0 then
        local abIndex = ability:GetAbilityIndex() + 1
        if abIndex >= 1 and abIndex <= 6 then
            if not caster.deadlyArsenal then
                caster.deadlyArsenal = {true, true, true, true, true, true}
            end
            if caster.deadlyArsenal[abIndex] then
                caster.deadlyArsenal[abIndex] = false
                finaldamage = finaldamage* (1 + 0.5 * caster.talents[158]) * critdmgbonusfactor
                critpossible = false
                Timers:CreateTimer(20 * GetInnerCooldownFactor(caster),function()
                    caster.deadlyArsenal[abIndex] = true
                end)
            end
        end
    end
    if critpossible == true and caster:HasModifier("modifier_druid_sun_crit") then
        critchance = 10 + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_crit_pure_immortal_2") then
        critchance = 5*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    local templeArmorModifier = caster:FindModifierByName("modifier_item_crit_pure_immortal3")
    if critpossible == true and templeArmorModifier then
        local templeArmorModifierAbility = templeArmorModifier:GetAbility()
        if(templeArmorModifierAbility) then
            critchance = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor + flatCritChance
            local critDmgFactor = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat2") / 100
    
            if caster:HasModifier("modifier_item_crit_pure_5_lifesteal_no_ls") then
                critchance = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor + flatCritChance
                critDmgFactor = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat4") / 100
            end
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible == true and caster:HasModifier("modifier_element_shadow") then
        critchance = 5*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    local itemMultiElementShadowCrits = event.caster:FindModifierByName("modifier_element_shadow")
    if critpossible == true and itemMultiElementShadowCrits then
        local itemMultiElementShadowCritsAbility = itemMultiElementShadowCrits:GetAbility()
        if(itemMultiElementShadowCritsAbility) then
            local critDmgFactor = itemMultiElementShadowCritsAbility:GetSpecialValueFor("bonus_stat3") / 100
            critchance = itemMultiElementShadowCritsAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor + flatCritChance
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    local tributeOfBloodModifier = caster:FindModifierByName("modifier_item_crit_pure_5")
    if critpossible == true and tributeOfBloodModifier then
        local tributeOfBloodModifierAbility = tributeOfBloodModifier:GetAbility()
        if(tributeOfBloodModifierAbility) then
            critchance = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor + flatCritChance
            local critDmgFactor = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat4") / 100
    
            if caster:HasModifier("modifier_item_crit_pure_5_lifesteal") then
                critchance = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat6")*critchancefactor + flatCritChance
                critDmgFactor = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat7") / 100
            end
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    local armageddon = caster:FindModifierByName("modifier_item_crit_pure_immortal")
    if critpossible == true and armageddon then
        local armageddonAbility = armageddon:GetAbility()
        if(armageddonAbility) then
            critchance = armageddonAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor + flatCritChance
            local critDmgFactor = armageddonAbility:GetSpecialValueFor("bonus_stat2") / 100
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    local ebonyMasterBowModifier = caster:FindModifierByName("modifier_item_warglaive")
    if critpossible == true and ebonyMasterBowModifier then
        local ebonyMasterBowAbility = ebonyMasterBowModifier:GetAbility()
        if(ebonyMasterBowAbility) then
            critchance = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor + flatCritChance
            local critDmgFactor = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat4") / 100
            if caster:HasModifier("modifier_bow_crit_legendary") then
                critchance = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat6")*critchancefactor + flatCritChance
                critDmgFactor = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat7") / 100
            end
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_set_agi_set_crit_2") then
        critchance = 3*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_set_agi_set_crit_t1") then
        critchance = 5*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster.mortalSwingCrit and caster.mortalSwingCrit >= 0 and ability and ability:GetName() == "Mortal_Swing" and GetLevelOfAbility(caster, "Mortal_Swing") >= 2 then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.shadowdmg and caster:HasModifier("modifier_critsha") then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.voidhunter_crit and caster.voidhunter_crit then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*caster.voidhunter_crit*critdmgbonusfactor --2.5
            critpossible = false
            caster.voidhunter_crit = nil
        end
    end
    if critpossible == true and event.shadowimp_crit and caster.shadowimp_crit then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*caster.shadowimp_crit*critdmgbonusfactor --2.5
            critpossible = false
            caster.shadowimp_crit = nil
        end
    end
    if critpossible == true and event.hellguard_crit and caster.hellguard_crit then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*caster.hellguard_crit*critdmgbonusfactor --2.5
            critpossible = false
            caster.hellguard_crit = nil
        end
    end
    if critpossible == true and caster.talents and caster.talents[139] > 0 and ability and ability:GetLevel() == 3 then
        critchance = 5*critchancefactor*caster.talents[139] + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    local boneCollectorModifier = caster:FindModifierByName("modifier_item_crit_pure_3")
    if critpossible == true and boneCollectorModifier then
        local boneCollectorModifierAbility = boneCollectorModifier:GetAbility()
        critchance = boneCollectorModifierAbility:GetSpecialValueFor("bonus_stat4")*critchancefactor + flatCritChance
        local critDmgFactor = boneCollectorModifierAbility:GetSpecialValueFor("bonus_stat5") / 100
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_crit1") then
        critchance = 10*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.3*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_crit2") and not caster.crit2cd then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
            caster.crit2cd = true
            Timers:CreateTimer(10,function()
                caster.crit2cd = false
            end)
        end
    end
    
    --local agitocrit = caster:FindAbilityByName("wind5")
    --if critpossible == true and agitocrit and agitocrit:GetLevel() >= 4 then
    --    critchance = caster:GetPrimaryStatValue()*0.05*critchancefactor
    --    if math.random(1,100) <= critchance then
    --        finaldamage = finaldamage*3*critdmgbonusfactor
    --        critpossible = false
    --    end
    --end
    if critpossible == true and caster:HasModifier("modifier_lifesteal_double") then
        critchance = 10*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_crit_pure") then
        critchance = 7*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.3*critdmgbonusfactor
            critpossible = false
        end
    end
    local alphablood_divine = caster:HasModifier("modifier_pathbuff_045")
    if critpossible == true and caster.talents and caster.talents[45] and caster.talents[45] > 0 and ((ability:GetAbilityIndex() == 0 or ability:GetAbilityIndex() == 1 or (alphablood_divine and (event.fromsummon or event.ComesFromPet)) or (ability:GetAbilityIndex() == 2 and caster:HasModifier("modifier_pathbuff_013")))) then
        local alphablood_chance = 5
        local crit_dmg_alpha = 4
        if alphablood_divine and (event.fromsummon or event.ComesFromPet) then
            crit_dmg_alpha = 6
        end
        if ability:GetAbilityIndex() == 1 then
            alphablood_chance = 2.5
            if alphablood_divine then
                alphablood_chance = 5
            end
        end
        critchance = alphablood_chance * caster.talents[45] * critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*crit_dmg_alpha*critdmgbonusfactor
            critpossible = false
            PathAlphaBloodProc( caster, ability )
        end
    end
    if critpossible == true and caster.talents and caster.talents[19] and caster.talents[19] > 0 then
        critchance = caster.talents[19] * critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_druid_glove_crit") then
        critchance = 7*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.45*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_crit_pure_2") then
        critchance = 15*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.3*critdmgbonusfactor
            critpossible = false
        end
    end
    local legionBannerModifier = caster:FindModifierByName("modifier_item_crit_pure_4")
    if critpossible == true and legionBannerModifier then
        local legionBannerModifierAbility = legionBannerModifier:GetAbility()
        if(legionBannerModifierAbility) then
            critchance = legionBannerModifierAbility:GetSpecialValueFor("bonus_stat4")*critchancefactor + flatCritChance
            local critDmgFactor = legionBannerModifierAbility:GetSpecialValueFor("bonus_stat5") / 100
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    local noblePlainstridersModifier = caster:FindModifierByName("modifier_item_bootscrit4")
    if critpossible == true and noblePlainstridersModifier then
        local noblePlainstridersModifierAbility = noblePlainstridersModifier:GetAbility()
        if(noblePlainstridersModifierAbility) then
            critchance = noblePlainstridersModifierAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor + flatCritChance
            local critDmgFactor = noblePlainstridersModifierAbility:GetSpecialValueFor("bonus_stat3") / 100
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    local alphamaneModifier = caster:FindModifierByName("modifier_item_bootscrit3")
    if critpossible == true and alphamaneModifier then
        local alphamaneModifierAbility = alphamaneModifier:GetAbility()
        if(alphamaneModifierAbility) then
            critchance = alphamaneModifierAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor + flatCritChance
            local critDmgFactor = alphamaneModifierAbility:GetSpecialValueFor("bonus_stat3") / 100
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    local tamedFirebatModifier = caster:FindModifierByName("modifier_item_bootscrit2")
    if critpossible == true and tamedFirebatModifier then
        local tamedFirebatModifierAbility = tamedFirebatModifier:GetAbility()
        if(tamedFirebatModifierAbility) then
            critchance = tamedFirebatModifierAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor + flatCritChance
            local critDmgFactor = tamedFirebatModifierAbility:GetSpecialValueFor("bonus_stat3") / 100
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_endgame5") then
        critchance = 8*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.35*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.naturedmg and caster:HasModifier("modifier_item_elements") and not caster:HasModifier("modifier_innercd_nature") then
        local table3 = {}
        table3.Duration = 20
        caster.itemelemental:ApplyDataDrivenModifier(caster, caster, "modifier_innercd_nature", table3)
        finaldamage = finaldamage*2.5*critdmgbonusfactor
        critpossible = false
    end
    if critpossible == true and caster:HasModifier("modifier_item_bootscurse") then
        critchance = 15*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.3*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster.talents and caster.talents[48] and caster.talents[48] > 0 and not (event.isdot or event.isaoe) then
        critchance = 12*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*(1.5 + 1 * caster.talents[48])*critdmgbonusfactor
            critpossible = false
        end
    end
    local prot_counter_blow = caster:GetModifierStackCount("modifier_counter_blow", nil)
    if critpossible == true and prot_counter_blow >= 1 then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
            caster:RemoveModifierByName("modifier_counter_blow")
        end
    end
    if critpossible == true and caster.talents and caster.talents[37] and caster.talents[37] > 0 then
        critchance = (7 * caster.talents[37])*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            local factor = 2
            if caster:HasModifier("modifier_pathbuff_037") and GetHighestAbilityScaling(event) <= 400 then
                factor = 3
            end
            finaldamage = finaldamage*factor*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_bootscrit") then
        critchance = 10*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    local bootsOfWonderModifier = caster:FindModifierByName("modifier_item_bootscrit_2")
    if critpossible == true and bootsOfWonderModifier then
        local bootsOfWonderModifierAbility = bootsOfWonderModifier:GetAbility()
        if(bootsOfWonderModifierAbility) then
            critchance = bootsOfWonderModifierAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor + flatCritChance
            local critDmgFactor = bootsOfWonderModifierAbility:GetSpecialValueFor("bonus_stat2") / 100
            if math.random(1,100) <= critchance then
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible == true and event.froststrikecrit and caster:GetModifierStackCount("modifier_frostrune", nil) >= 5 then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            caster:RemoveModifierByName("modifier_frostrune")
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
            event.lifesteal = 5
        end
    end
    if critpossible == true and caster:HasModifier("modifier_crit_aura_dragon_2") then
        critchance = 3*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_caster6") then
        critchance = 12*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.3*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_bowupgradeproc") then
        critchance = 50*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            local dist = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
            if dist > 300.0 then
                finaldamage = finaldamage*2*critdmgbonusfactor
                critpossible = false
            end
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_weapon9") then
        critchance = 12*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.3*critdmgbonusfactor
            critpossible = false
        end
    end
    if event.inspiringshot and caster:HasModifier("glacier_trap_guaranteed_crit") then
        caster:RemoveModifierByName("glacier_trap_guaranteed_crit")
        finaldamage = finaldamage*1.5
    end
    if critpossible == true and caster:HasModifier("modifier_item_endgame9") then
        critchance = 10*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_weapon10") then
        critchance = 10*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.6*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_item_endgame10") then
        critchance = 5*critchancefactor + flatCritChance
        --print("test for blade")
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            --print("high crit")
            critpossible = false
        end
    end
    if caster:HasModifier("modifier_guaranteed_dmg_once") then
        finaldamage = finaldamage*5.0
        caster:RemoveModifierByName("modifier_guaranteed_dmg_once")
    end
    if caster:HasModifier("modifier_energy_doubled") then
        finaldamage = finaldamage*1.25
    end
    if critpossible == true and caster:HasModifier("modifier_crit_aura_dragon") then
        critchance = 3*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    local legionBannerActiveModifier = caster:FindModifierByName("modifier_guaranteed_crit_once")
    if critpossible == true and legionBannerActiveModifier then
        local legionBannerActiveModifierAbility = legionBannerActiveModifier:GetAbility()
        if(legionBannerActiveModifierAbility) then
            critchance = legionBannerActiveModifierAbility:GetSpecialValueFor("bonus_stat8")*critchancefactor + flatCritChance
            if math.random(1,100) <= critchance then
                local critDmgFactor = legionBannerActiveModifierAbility:GetSpecialValueFor("bonus_stat9") / 100
                finaldamage = finaldamage*critDmgFactor*critdmgbonusfactor
                critpossible = false
                caster:RemoveModifierByName("modifier_guaranteed_crit_once")
            end
        end
    end
    if critpossible == true and event.beartrapcrit and caster.owner and caster.owner:GetAbilityByIndex(2) and caster.owner:GetAbilityByIndex(2):GetLevel() >= 3 and target:HasModifier("modifier_bear_trap") then
        finaldamage = finaldamage*2.5*critdmgbonusfactor
        critpossible = false
    end
    if critpossible == true and caster:HasModifier("modifier_item_allrecipe4") then
        local life = math.floor(100-(100*caster:GetHealth()/caster:GetMaxHealth()))
        if math.random(1,100) <= life / 2 then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster.FeralFinisherCrit ~= nil and target:HasModifier("modifier_bleed2") then
        critchance = GetStrengthCustom(caster)*2 + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    local holy_priest_crit = caster:FindAbilityByName("holy2")
    if critpossible == true and holy_priest_crit and holy_priest_crit:GetLevel() >= 3 then
        critchance = 20*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2*critdmgbonusfactor
            critpossible = false
        end
    end
    local talentcritstacks = caster:GetModifierStackCount("modifier_crit_stacks", nil)
    if critpossible == true and talentcritstacks > 0 then
        critchance = talentcritstacks*15*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    local riki_passive_crit = caster:FindAbilityByName("hawk1")
    if critpossible == true and event.rikicrit and riki_passive_crit and riki_passive_crit:GetLevel() >= 3 then
        critchance = 15*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.75*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_guaranteed_crit") then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.5*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.critchance200 then
        critchance = event.critchance200*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2.0*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.lavaburst and target:HasModifier("modifier_lavashock") then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            local lavaCrit = event.lavaburst
            if caster:HasModifier("modifier_class_ele2") then
                lavaCrit = lavaCrit + 0.5
            end
            finaldamage = finaldamage*lavaCrit*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.alwayscrit200onbuff and target:HasModifier(event.alwayscrit200onbuff) then
        critchance = 10*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*2.0*critdmgbonusfactor
            critpossible = false
        end
    end
    if critpossible == true and event.dire1 and caster:HasModifier("modifier_npc_dota_hero_riki") then
        critchance = 100*critchancefactor + flatCritChance
        if math.random(1,100) <= critchance then
            finaldamage = finaldamage*1.75*critdmgbonusfactor
            critpossible = false
        end
    end
    
    local was_crit = false
    if critpossible == false and not event.cannotcrit then
        was_crit = true
    end
    local was_consecutive_crit = false
    if was_crit and caster.last_ability_damage_was_crit then
        was_consecutive_crit = true
    end
    caster.last_ability_damage_was_crit = was_crit
    -- END CRIT CALC

    -------------------------------------------------------------------------------------------------------------------------------------------------------
    
    --ele dmg check: need to do it again here cuz some effects are based on crits
    if event.arcanedmg and (caster:HasModifier("modifier_dark") or caster:HasModifier("modifier_dark2")) then
        event.arcanedmg = nil
        event.shadowdmg = 1
        local particle = ParticleManager:CreateParticle("particles/econ/items/witch_doctor/wd_ti8_immortal_head/wd_ti8_immortal_maledict_dark_b.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end

    --procs
    if was_crit then
        GlobalOnAbilityCriticalStrike(caster, target, ability, true, event.swordstorm)
        SavageryProc(caster, 2)
    end
    if event.isaoe and caster:IsHero() then
        GlobalOnDealAOEDamage(caster, target)
    end
    if is_pet_dmg and event.bearpet and caster:HasModifier("modifier_item_hunterbow2") then
        CheckForAutoAttackCriticalStrikeProcs(caster, target)
        caster:PerformAttack(target, true, true, true, true, true, false, false)
        Timers:CreateTimer(0.15,function()
            CheckForAutoAttackCriticalStrikeProcs(caster, target)
            caster:PerformAttack(target, true, true, true, true, true, false, false)
        end)
    end
    if is_pet_dmg then
        OnSummonDamage(caster, target, ability)
    end
    --pure damage check
    if (caster and caster.talents and GetLevelOfAbility(caster, "Mindfreezing_Shot") >= 2 and math.random(1,100) <= 10) or (event.pure_damage_chance and math.random(1,100) <= event.pure_damage_chance) or (caster.is_rogue and math.random(1,100) <= 5) or (caster.talents and caster.talents[82] and caster.talents[82] > 0 and caster.talents[82] * 10 >= math.random(1,100)) or (caster:HasModifier("modifier_item_valyrian") and math.random(1,100) <= 5) or (caster:HasModifier("modifier_item_dreihander") and math.random(1,100) <= 10) or (caster:HasModifier("modifier_pathbuff_030") and math.random(1,100) <= 10) or (event.critignorearmor and was_crit) or caster:HasModifier("modifier_valyrian") or (ability and ability:GetLevel() == 4 and caster.talents and caster.talents[139] and caster.talents[139] > 0 and caster.talents[139] * 5 >= math.random(1,100)) then
        pure_dmg = true
    end
    local standsstill = caster.standsstill
    if standsstill then
        if standsstill > 5 then
            standsstill = 5
        end
        if caster:HasModifier("modifier_pathbuff_020") and math.random(1,100) <= 5 * standsstill then
            pure_dmg = true
        end
    end

    --multiplicative buffs
    ------------------------------------------------------------------------------------------------------------------------------------------------------
    --print("get ab damage call " .. ability:GetName())
    if ability then
        ability_bonus = GetAbilityDamageModifierMultiplicative(event, caster, real_caster, target, ability, behindtarget, is_very_big_hit, is_500_big_hit, isaoe, true, was_crit, was_consecutive_crit, pure_dmg, is_pet_dmg)
        elemental_bonus = GetElementalDamageModifierAdditive(event, caster, real_caster, target, ability, behindtarget, true, dmgtype)
    end

    if event.shadowdmg then
        GlobalOnDealShadowDamage(caster, target)
    end
    if event.firedmg then
        GlobalOnDealFireDamage(caster, target)
    end
    if event.naturedmg then
        GlobalOnDealNatureDamage(caster)
    end
    if event.arcanedmg then
        GlobalOnDealArcaneDamage(caster, was_crit, target)
    end
    if event.chaosdmg then
        GlobalOnDealChaosDamage(caster, target)
    end

    --primal totem staff
    if caster.elemental_item3 and caster:HasModifier("modifier_item_elements3") then
        local buffdur = 15
        if event.firedmg then
            caster.elemental_item3:ApplyDataDrivenModifier(caster, caster, "modifier_dmgitem_fire", {Duration = buffdur})
        end
        if event.arcanedmg then
            caster.elemental_item3:ApplyDataDrivenModifier(caster, caster, "modifier_dmgitem_arcane", {Duration = buffdur})
        end
        if event.shadowdmg then
            caster.elemental_item3:ApplyDataDrivenModifier(caster, caster, "modifier_dmgitem_shadow", {Duration = buffdur})
        end
        if event.naturedmg then
            caster.elemental_item3:ApplyDataDrivenModifier(caster, caster, "modifier_dmgitem_nature", {Duration = buffdur})
        end
        if event.holydmg then
            caster.elemental_item3:ApplyDataDrivenModifier(caster, caster, "modifier_dmgitem_holy", {Duration = buffdur})
        end
        if event.frostdmg then
            caster.elemental_item3:ApplyDataDrivenModifier(caster, caster, "modifier_dmgitem_frost", {Duration = buffdur})
        end
        if event.chaosdmg then
            caster.elemental_item3:ApplyDataDrivenModifier(caster, caster, "modifier_dmgitem_chaos", {Duration = buffdur})
        end
    end
    --local aoe_bonus = 1
    --if isaoe then
    --    aoe_bonus = GetAbilityAOEDamageModifierAdditive(event, caster, real_caster, target, ability, behindtarget, true)
    --end

    -------------------------------------------------
    --summon stuff
    local dragon_bonus = GetDragonBonusDamage(event, caster)
    local summon_bonus = GetSummonBonusDamage(event, caster, empowertocrit)

    --saving stats for statistics
    if caster:IsRealHero() then
        caster.ability_bonus = ability_bonus
        caster.elemental_bonus = elemental_bonus
        caster.crit_chance_factor = critchancefactor
        caster.crit_dmg_factor = critdmgbonusfactor
        --caster.multiplicative_bonus = multiplicative_bonus
    end

    --patient prowler, must be after getting bonus
    if caster.talents then
        if caster.talents[52] and caster.talents[52] > 0 then
            local myevent = {}
            myevent.caster = caster
            myevent.target = caster
            myevent.buff = "modifier_talent_tiger_prowl"
            myevent.ability = passive_ability
            myevent.dur = -1
            myevent.addstacks = -1
            local max_stack = 10
            if caster:HasModifier("modifier_item_ancient_elune") then
                max_stack = 15
            end
            myevent.max = max_stack
            ApplyBuffStack(myevent)
        end
    end

    --critical strike tracking
    if caster.consecutive_crits then
        if was_crit then
            caster.consecutive_crits = caster.consecutive_crits + 1
        else
            caster.consecutive_crits = 0
        end
    else
        if was_crit then
            caster.consecutive_crits = 1
        else
            caster.consecutive_crits = 0
        end
    end

    if event.killdance_crit_extra_hit then
        if was_crit then
            caster.killdance_last_hit_was_crit = true
        else
            caster.killdance_last_hit_was_crit = false
        end
    end

    --new buffs based on improved talents, 4.3
    local drow_consec_crit_talent = caster:FindAbilityByName("Icy_Shot")
    if drow_consec_crit_talent and drow_consec_crit_talent:GetLevel() >= 4 and caster.consecutive_crits and caster.consecutive_crits >= 3 then
        if caster.agility_bonus_100 then
            caster.agility_bonus_100 = caster.agility_bonus_100 + 1
        else
            caster.agility_bonus_100 = 1
        end
        drow_consec_crit_talent:ApplyDataDrivenModifier(caster, caster, "modifier_icy_agi", {Duration = 20})
        Timers:CreateTimer(20,function()
            caster.agility_bonus_100 = caster.agility_bonus_100 - 1
        end)
    end
    local darkseer_class_consec_bonus = caster:FindAbilityByName("shadow1")
    if darkseer_class_consec_bonus and caster.consecutive_crits and caster.consecutive_crits >= 3 and caster:HasModifier("modifier_class_darkseer") then
        if caster.ds_shadow_bonus_50 then
            caster.ds_shadow_bonus_50 = caster.ds_shadow_bonus_50 + 1
        else
            caster.ds_shadow_bonus_50 = 1
        end
        --drow_consec_crit_talent:ApplyDataDrivenModifier(caster, caster, "modifier_icy_agi", {Duration = 20})
        Timers:CreateTimer(10,function()
            caster.ds_shadow_bonus_50 = caster.ds_shadow_bonus_50 - 1
        end)
    end

    --talent procs 2, based on crits, bloodwolf
    if caster.talents then
        --if was_crit and caster.talents[45] and caster.talents[45] > 0 and caster.consecutive_crits and caster.consecutive_crits >= 5 then
        --    passive_ability:ApplyDataDrivenModifier(caster, caster, "modifier_talent_enrage_2", {Duration = 5})
        --end
        if was_crit then
            GlobalOnDamagingCritLanded(caster, target)
        end
        if was_crit and caster.talents[47] and caster.talents[47] > 0 then
            if caster.critcounter then
                caster.critcounter = caster.critcounter + 1
                local crits_needed = 10 + 5 * caster.talents[47]
                --if caster:HasModifier("modifier_item_ancient_wolf") then
                --   crits_needed = crits_needed * 2
                --end
                --if caster:HasModifier("modifier_pathbuff_047") and crits_needed > 25 then
                --    crits_needed = 25
                --end
                if caster.critcounter >= crits_needed then
                    caster.critcounter = 0
                    passive_ability:ApplyDataDrivenModifier(caster, caster, "modifier_talent_enrage", {Duration = 15})
                end
            else
                caster.critcounter = 1
            end
            if caster.critcounter == 0 then
                caster:RemoveModifierByName("modifier_talent_critcounter")
            else
                passive_ability:ApplyDataDrivenModifier(caster, caster, "modifier_talent_critcounter", {Duration = -1})
                caster:SetModifierStackCount("modifier_talent_critcounter", passive_ability, caster.critcounter)
            end
        end
        --[[
        if caster.talents[50] and caster.talents[50] > 0 and math.random(1,100) <= 1 then
            local myevent = {}
            myevent.caster = caster
            myevent.target = caster
            myevent.buff = "modifier_talent_onheal_armor"
            myevent.ability = caster.combat_system_ability
            myevent.dur = 3 + 3 * caster.talents[50]
            ApplyBuff(myevent)
            caster.creepertarget = target
            myevent.target = target
            myevent.dur = nil
            myevent.buff = "irongrizzly_summon_proc"
            ApplyBuff(myevent)
        end
        ]]
        if caster.talents[30] and caster.talents[30] > 0 and not caster.talent_30_cd then
            BlizzardTalent(caster, target, false)
        end
    end
    --cp on crit
    if event.cponcrit and event.cponcrit > 0 and critpossible == false then
    	if not caster.ComboPoints then
    		caster.ComboPoints = 0
    	end
    	if caster.ComboPoints < 3 then
    		caster.ComboPoints = caster.ComboPoints + event.cponcrit
    	end
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_combopoint", tab)
		caster:SetModifierStackCount("modifier_combopoint", event.ability, caster.ComboPoints)
    end
    if event.oncritrunic and was_crit and caster.resourcesystem then
        local myevent = {}
        myevent.caster = caster
        myevent.energy = event.oncritrunic
        if caster:GetMana() > 35 then
            Timers:CreateTimer(0.02,function()
                AddEnergy(myevent)
            end)
        else
            AddEnergy(myevent)
        end
    end
    if event.refundoncrit and event.refundoncrit > 0 and critpossible == false and not caster:HasModifier("modifier_manacost_reduction") then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_manacost_reduction", tab)
		--EmitSoundOn("drowranger_dro_spawn_04", caster)
    end

    if event.critmanareg and critpossible == false then
        if event.critmanaregnonpercent then
    	   caster:SetMana(caster:GetMana()+event.critmanareg)
        else
            caster:SetMana(caster:GetMana()+(caster:GetMaxMana()*event.critmanareg/100.0))
        end
    	local particle = ParticleManager:CreateParticle("particles/items3_fx/mango_active.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end

    if event.holy4heal then
        local holy4 = caster:FindAbilityByName("holy4")
        if holy4 and holy4:GetLevel() >= 3 then
            HealMostWoundedHero({caster = caster, target = caster, ability = holy4, holy4FX = 1, fromCaster = 1, heal = 0, attributefactor = 50, spelldamagefactor = 50, range = 900})
        end
    end

    if event.oncritswp and event.oncritswp > 0 and critpossible == false and not event.cannotcrit then
    	if math.random(1,100) <= event.oncritswp and not caster:HasModifier("modifier_swd_2_proc_cd") and (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length() < 2500 then
	    	event.ability:ApplyDataDrivenModifier(caster, target, "modifier_swd_2_proc", nil)
            if caster:HasModifier("modifier_class_darkseer") then
                Timers:CreateTimer(0.3,function()
                    event.ability:ApplyDataDrivenModifier(caster, target, "modifier_swd_2_proc", nil)
                    Timers:CreateTimer(0.3,function()
                        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_swd_2_proc", nil)
                    end)
                end)
            end
            local swpcd = 5 * GetInnerCooldownFactor(caster)
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_swd_2_proc_cd", {Duration = swpcd})
    	end
    end

    if event.oncritbuff and was_crit then
        local buffdur = nil
        if event.oncritbuffdur then
            buffdur = {Duration = event.oncritbuffdur}
        end
        if not event.oncritbuffchance then
            event.ability:ApplyDataDrivenModifier(caster, caster, event.oncritbuff, buffdur)
        else
            if math.random(1,100) <= event.oncritbuffchance then
                event.ability:ApplyDataDrivenModifier(caster, caster, event.oncritbuff, buffdur)
            end
        end
    end
    if event.on2critbuff then
        if was_crit then
            if caster.on2crit then
                caster.on2crit = caster.on2crit  + 1
                if caster.on2crit >= 2 then
                    event.ability:ApplyDataDrivenModifier(caster, caster, event.on2critbuff, nil)
                    caster.on2crit = 0
                end
            else
                caster.on2crit = 1
            end
        else
            caster.on2crit = 0
        end
    end
    if event.on3critbuff then
        if was_crit then
            if caster.on3crit then
                caster.on3crit = caster.on3crit  + 1
                if caster.on3crit >= 3 then
                    event.ability:ApplyDataDrivenModifier(caster, caster, event.on3critbuff, nil)
                    caster.on3crit = 0
                end
            else
                caster.on3crit = 1
            end
        else
            caster.on3crit = 0
        end
    end
    if event.oncritdebuff and was_crit and (not event.oncritdebuffinnercd or not caster.oncritdebuffinnercd) then
        event.ability:ApplyDataDrivenModifier(caster, target, event.oncritdebuff, nil)
        if event.oncritdebuffinnercd then
            caster.oncritdebuffinnercd = true
            Timers:CreateTimer(event.oncritdebuffinnercd * GetInnerCooldownFactor(caster), function()
                caster.oncritdebuffinnercd = false
            end)
        end
    end

    if event.oncritcdreduce and event.oncritcdreduce > 0 and critpossible == false and not event.cannotcrit then
    	event.amount = event.oncritcdreduce
    	ReduceCooldown(event)
    end

    if event.oncritcdreduce3rd and event.oncritcdreduce3rd > 0 and critpossible == false and not event.cannotcrit then
        event.amount = event.oncritcdreduce3rd
        event.chooseability = 2
        ReduceCooldown(event)
    end

    if event.oncritcdreduce4th and event.oncritcdreduce4th > 0 and critpossible == false and not event.cannotcrit then
        event.amount = event.oncritcdreduce4th
        event.chooseability = 3
        ReduceCooldown(event)
    end

    if event.asoncrit and event.asoncrit > 0 and critpossible == false and not event.cannotcrit then
    	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_asbonus", nil)
    end

    if event.critmanacat and event.critmanacat > 0 and critpossible == false then
    	if caster.OldMana then
    		caster.OldMana = caster.OldMana + event.critmanacat
    	end
    end

    if event.holydmg and caster:HasModifier("modifier_holyaaa") then
        caster.holyaaa_bonus = true
    end
    if event.holydmg and caster:HasModifier("modifier_holyaaa2") then
        caster.holyaaa2_bonus = true
    end

    --ability crit
    if was_crit then
        if not isaoe and caster:HasModifier("modifier_spearspeed") then
            if not caster.spearspeed then
                caster.spearspeed = 0
            end
            caster.spearspeed = caster.spearspeed + 1
            local lastSpearStackCount = caster.spearspeed
            Timers:CreateTimer(2, function()
                if caster.spearspeed <= lastSpearStackCount then
                    caster.spearspeed = 0
                end
            end)
        end
        

        if not caster.ab_crit_counter_last_5_secs then
        	caster.ab_crit_counter_last_5_secs = 0
        end
        caster.ab_crit_counter_last_5_secs = caster.ab_crit_counter_last_5_secs + 1
        local sniper_bonus = caster:FindAbilityByName("Bear")
        if caster.ab_crit_counter_last_5_secs == 1 and sniper_bonus and sniper_bonus:GetLevel() >= 4 then
        	caster.sniper_blood_particle = ParticleManager:CreateParticle("particles/items4_fx/spirit_vessel_damage_ground.vpcf", PATTACH_POINT_FOLLOW, caster)
        end
        Timers:CreateTimer(5, function()
        	caster.ab_crit_counter_last_5_secs = caster.ab_crit_counter_last_5_secs - 1
        	if caster.ab_crit_counter_last_5_secs == 0 and caster.sniper_blood_particle then
        		ParticleManager:DestroyParticle(caster.sniper_blood_particle,false)
        		ParticleManager:ReleaseParticleIndex(caster.sniper_blood_particle)
        	end
        end)
    end

    local talentwarriorcritdot = caster:FindAbilityByName("Switch_Battle_Stance")
    if not talentwarriorcritdot then
        talentwarriorcritdot = caster:FindAbilityByName("temple_brawler_battlestance")
    end
    if critpossible == false and not event.cannotcrit and not caster.armstalentdotcd and not event.talentarmsnodot and talentwarriorcritdot and talentwarriorcritdot:GetLevel() >= 4 then
    	caster.armstalentdotcd = true
        Timers:CreateTimer(2 * GetInnerCooldownFactor(caster),function()
            caster.armstalentdotcd = false
        end)
        local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_arms_bleed_crit"
		myevent.ability = talentwarriorcritdot
		myevent.dur = 6
        myevent.settickrate = 2
		ApplyBuff(myevent)
    end

    if critpossible == false and not event.cannotcrit and event.lancecritproc and event.lancecritproc > 0 then
        local chance = event.lancecritproc
        if caster:HasModifier("modifier_npc_dota_hero_flame2") then
            chance = chance + 40
        end
    	if math.random(1,100) <= event.lancecritproc then
	    	event.ability:ApplyDataDrivenModifier(caster, target, "modifier_lavalance_proc", nil)
		end
    end

    if event.lancestunproc and event.lancestunproc > 0 then
    	local lancestacks = caster:GetModifierStackCount("modifier_lancestun_proc", nil)
	    if lancestacks >= 5 then
            finaldamage = finaldamage * 3
	    	caster:RemoveModifierByName("modifier_lancestun_proc")
	    	local myevent = {}
    		myevent.caster = caster
    		myevent.target = target
    		myevent.buff = "modifier_stunned"
			myevent.ability = event.ability
			myevent.dur = event.lancestunproc
			ApplyBuff(myevent)
	    end
    end

    -- elemental item stuff
 	if caster:HasModifier("modifier_item_elements") then
 		local table3 = {}
    	if event.frostdmg and caster.itemelemental then
    		local myevent = {}
    		myevent.caster = caster
    		myevent.target = target
    		myevent.buff = "modifier_frostslow10"
			myevent.ability = caster.itemelemental
			myevent.dur = 5
			ApplyBuff(myevent)
    		--caster.itemelemental:ApplyDataDrivenModifier(caster, target, "modifier_frostslow10", nil)
    	end
    	if event.firedmg then
    		if caster.itemelemental and not caster:HasModifier("modifier_innercd_fire") then
	    		if math.random(1,100) <= 100 then
			    	local myevent = {}
		    		myevent.caster = caster
		    		myevent.target = target
		    		myevent.buff = "modifier_stunned"
					myevent.ability = event.ability
					myevent.dur = 2
					ApplyBuff(myevent)
	    			local particle = ParticleManager:CreateParticle("particles/econ/items/invoker/glorious_inspiration/invoker_forge_spirit_death_esl_explode.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
                    ParticleManager:ReleaseParticleIndex(particle)
	    			table3.Duration = 30
	    			caster.itemelemental:ApplyDataDrivenModifier(caster, caster, "modifier_innercd_fire", table3)
	    			particle = ParticleManager:CreateParticle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze_end_smoke.vpcf", PATTACH_POINT_FOLLOW, target)
                    ParticleManager:ReleaseParticleIndex(particle)
			    end
			end
    	end
    end

    if event.frostdmg and caster:HasModifier("modifier_pathbuff_030") then
        AddSpellhaste(caster, 25, 5)
        AddAttackSpeed(caster, 25, 5)
    end

    --------------------------------------------------------------------------------------------------------------------------------------------------
    --final damage determined
    
    -- set damage table
    finaldamage = finaldamage * nodamageatall * ability_bonus * elemental_bonus * dragon_bonus * summon_bonus
    if event.is_echo_proc then
        finaldamage = finaldamage * event.is_echo_proc
    end

    local damage_table = {}
 	damage_table.victim = target
 	damage_table.attacker = caster
 	damage_table.ability = ability
 	if ability == nil then
 		damage_table.damage_type = 1
 	else
        if ability:IsNull() then
            return
        end
 		damage_table.damage_type = dmgtype
 	end
    --pure dmg?
    if event.puredmg or pure_dmg then
        damage_table.damage_type = DAMAGE_TYPE_PURE
        local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5_gold/am_manaburn_basher_ti_5_gold.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
    end

    --if caster:IsRealHero() then
    --    finaldamage = finaldamage * 10
    --end
 	damage_table.damage = finaldamage

 	if damage_table.damage_type == 0 then
 		damage_table.damage_type = 2
 	end

 	if event.dontbreakcc and CheckForBreakableCC(target) then

 	else
        if caster.talents then
            if caster.talents[6] and caster.talents[6] > 0 then
                if not event.notalent4proc and not caster.talent4cd and math.random(1,100) <= 10 then
                    caster.talent4cd = true
                    Timers:CreateTimer(1,function()
                        caster.talent4cd = false
                    end)
                    local dot_dur = 5
                    if caster:HasModifier("modifier_item_ancient_grizzly") then
                        dot_dur = dot_dur * 2
                    end
                    local myevent = { caster = caster, target = target, dur = dot_dur, buff = "modifier_dot", ability = passive_ability, settickrate = 1}
                    if not target:IsRealHero() then
                        ApplyBuff(myevent)
                    end
                end
            end
            if caster.talents[7] and caster.talents[7] > 0 then
                local buff = "modifier_talent_maul"
                local dot_dur = 5
                if caster:HasModifier("modifier_item_ancient_grizzly") then
                    dot_dur = dot_dur * 2
                end
                local myevent = { caster = caster, target = caster, dur = dot_dur, buff = buff, ability = passive_ability, addstacks = 1, max = caster.talents[7] * 33}
                ApplyBuffStack(myevent)
                --[[if false and math.random(1,100) <= caster.talents[7] and not event.maul_proc then
                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_warstomp_shockwave.vpcf", PATTACH_ABSORIGIN, target)
                    ParticleManager:ReleaseParticleIndex(particle)
                    EmitSoundOn("DOTA_Item.BladeMail.Activate", target)
                    local tab = {}
                    tab.caster = caster
                    tab.target = target
                    tab.damage = 0.0
                    tab.spelldamagefactor = 0.0
                    tab.attributefactor = 400
                    tab.ability = event.ability
                    tab.maul_proc = true
                    DamageUnit(tab)
                end]]
            end
        end

        --Spell Cleave
        local spellCleaveChance = GetSpellCleaveChance(caster)
        if math.random(1,100) <= spellCleaveChance then
            SpellCleaveProc(damage_table)
        else
            ApplyDamage(damage_table)
        end

        --extra hit procs
        if caster:HasModifier("modifier_rage_proc2") or caster:HasModifier("modifier_rage_proc") then
            local dmgfactorproc = 0.15
            if caster:HasModifier("modifier_rage_proc2") then
                dmgfactorproc = 0.3
            end
            local damage_table_2 = {}
            damage_table_2.victim = target
            damage_table_2.attacker = caster
            damage_table_2.ability = ability
            damage_table_2.damage_type = ability:GetAbilityDamageType()
            damage_table_2.damage = damage_table.damage * dmgfactorproc
            caster:RemoveModifierByName("modifier_rage_proc")
            caster:RemoveModifierByName("modifier_rage_proc2")
            Timers:CreateTimer(0.25,function() 
                ApplyDamage(damage_table_2)
                local particle = ParticleManager:CreateParticle("particles/econ/items/zeus/zeus_ti8_immortal_arms/zeus_ti8_immortal_arc.vpcf", PATTACH_POINT_FOLLOW, caster)
                ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,75))
                ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin()+Vector(0,0,75))
                ParticleManager:ReleaseParticleIndex(particle)
            end)
        end
        if caster:HasModifier("modifier_dancing_rune_dmg") and caster.DancingRune and not caster.DancingRune:IsNull() then
            local hit_ability = caster:FindAbilityByName("Death_For_Life")
            if hit_ability then
                local damage_table_2 = {}
                damage_table_2.victim = target
                damage_table_2.attacker = caster
                damage_table_2.ability = hit_ability
                damage_table_2.damage_type = hit_ability:GetAbilityDamageType()
                damage_table_2.damage = finaldamage * 0.5
                damage_table_2.fromsummon = 1
                Timers:CreateTimer(0.25,function() 
                    ApplyDamage(damage_table_2)
                    DancingRuneDamageFX(caster, target)
                end)
            end
        end

        if was_crit then
            CriticalStrikeFX(caster, target, finaldamage, dmgtype, 1)
        end
 		if caster:HasModifier("modifier_item_flamefury") or caster:HasModifier("modifier_item_flamefury2") then
     		FlameFury(event)
 		end
 		-- self damaging spells
 		if event.damageself ~= nil then
 			damage_table.victim = caster
 			damage_table.attacker = target
 			damage_table.damage = damage_table.damage*event.damageself
 			ApplyDamage(damage_table)
 		end
 	end

    --PROCS AFTER DEALING THE DMG
    if event.holydmg and GetRadianceStat(caster) >= 1 and not caster.radiance_cd then
        caster.radiance_cd = true
        RadianceProc(caster, ability)
        Timers:CreateTimer(10 * GetInnerCooldownFactor(caster),function() 
            caster.radiance_cd = false
        end)
    end

	if event.lifesteal then
		local tab = {}
		tab.caster = caster
		tab.target = caster
		tab.heal = finaldamage * event.lifesteal / 100
		tab.spelldamagefactor = 0.0
		tab.attributefactor = 0.0
		tab.ability = event.ability
        tab.cap_healing_at_max_health = event.cap_healing_at_max_health
        tab.bloodwolf = event.bloodwolf
		if tab.heal < 10 then
			tab.hidenumber = 1
		end
        if event.lifestealbuffcondition and not caster:HasModifier(event.lifestealbuffcondition) then
            --skip
        else
            HealUnit(tab)
        end
	end

    if event.fromcompanion and caster:HasModifier("modifier_bloodbrother") and GetCompanionCount(caster) == 1 then
        HealUnit({caster = caster, target = caster, heal = 0, percenthp = 5, ability = ability})
    end

    if caster:HasModifier("modifier_heal_on_summon_dmg") and caster:HasModifier("modifier_class_unholy") and event.ghoul and caster.Pet then
        HealUnit({caster = caster, target = caster, heal = 0, percenthp = 10, ability = ability})
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, caster.Pet)
        ParticleManager:SetParticleControl(particle, 4, caster:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:SetParticleControl(particle, 5, caster.Pet:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:ReleaseParticleIndex(particle)
        ApplyBuff({caster = caster, target = target, dur = 5, buff = "modifier_ghoul_res", ability = ability})
    end

    if caster.pathdarknesslevel and caster.pathdarknesslevel >= 3 and caster:HasModifier("modifier_shadow_stance_def") then
        local tab = {}
        tab.caster = caster
        tab.target = caster
        tab.heal = 0
        tab.percenthp = 1
        tab.ability = event.ability
        HealUnit(tab)
    end

	if event.lifestealowner ~= nil and caster.owner then
		local tab = {}
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_src_rope.vpcf", PATTACH_POINT_FOLLOW, caster.owner)
        ParticleManager:ReleaseParticleIndex(particle)
		ParticleManager:SetParticleControlEnt(particle, 4, caster.owner, PATTACH_POINT_FOLLOW, "attach_hitloc", caster.owner:GetAbsOrigin(), true)
		ParticleManager:SetParticleControlEnt(particle, 5, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
		tab.caster = caster.owner
		tab.target = caster.owner
		tab.heal = finaldamage * event.lifestealowner / 100
		tab.spelldamagefactor = 0.0
		tab.attributefactor = 0.0
		tab.ability = event.ability
		--tab.hidenumber = 1
		HealUnit(tab)
	end

	if event.vampiricemb and event.vampiricemb > 0 then
		event.heal = finaldamage*0.6
		VampiricEmbrace(event)
	end

	if caster:HasModifier("modifier_item_weapon5") or caster:HasModifier("modifier_item_dreihander") then
        local maxprocs = 10
		if math.random(1,100) <= 6 and event.dontprocaoe == nil and (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length() < 2500 then
            if not caster.zweiprocs then
                caster.zweiprocs = 1
            else
                caster.zweiprocs = caster.zweiprocs + 1
            end
            if caster:HasModifier("modifier_item_dreihander") then
                maxprocs = 15
            end
            if caster.zweiprocs <= maxprocs then
    			local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_warstomp_shockwave.vpcf", PATTACH_ABSORIGIN, target)
                ParticleManager:ReleaseParticleIndex(particle)
    			EmitSoundOn("DOTA_Item.BladeMail.Activate", target)
    			local tab = {}
    			tab.caster = caster
    			tab.target = target
    			tab.damage = 0.0
    			tab.spelldamagefactor = 0.0
    			tab.attributefactor = 50
    			tab.ability = event.ability
    			tab.aoe = 250
    			tab.targeteffect = "blood"
    			tab.targetpos = 1
    			tab.dontprocaoe = 1
    			tab.dontbreakcc = 1
                tab.max_targets = 5
    			DamageAOE(tab)
            else
                Timers:CreateTimer(5,function() 
                    caster.zweiprocs = 0
                end)
            end
		end
	end
	if event.arcanedmg and caster:HasModifier("modifier_item_elements") and caster.itemelemental then
		event.max = 25
		event.buff = "modifier_elemental_sp"
		event.ability = caster.itemelemental
		event.target = caster
		ApplyBuffStack(event)
	end
	if event.holydmg and caster:HasModifier("modifier_item_elements") and caster.itemelemental then
		event.max = 7
		event.buff = "modifier_elemental_kings"
		event.ability = caster.itemelemental
		event.target = caster
		ApplyBuffStack(event)
	end
    if caster:HasModifier("modifier_item_multi_element") or caster:HasModifier("modifier_item_multi_element_2") then
        MultiElementProcs(event, caster, target)
    end
    if caster:HasModifier("modifier_item_beastmaster3") and caster.item_beastmaster3 and event.fromsummon then
        ApplyBuffStack({caster = caster, target = caster, ability = caster.item_beastmaster3, dur = 5, max = 50, buff = "modifier_beastitem"})
    end
    if caster.talents then
        if caster.talents[79] and caster.talents[79] > 0 and (event.fromsummon or event.fromcompanion or event.ComesFromPet) and caster.combat_system_ability and not event.pathcrow then
            local proc_threshold = 25
            local stacks = ApplyBuffStack({caster = caster, target = caster, ability = caster.combat_system_ability, dur = -1, max = proc_threshold, buff = "modifier_murdercrow"})
            if stacks >= proc_threshold then
                caster:RemoveModifierByName("modifier_murdercrow")
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, target, "crow_summon_proc", {Duration = 2})
            end
        end
        if caster.talents[87] and caster.talents[87] > 0 and (event.bloodwolf or (caster:GetAbilityByIndex(0) == ability and (caster:HasModifier("modifier_storm") or caster:HasModifier("modifier_storm2")))) then
            PathStormStrikeProc( caster, target, false, true, false, false)
        end
        if caster.talents[23] and caster.talents[23] > 0 and (caster:GetAbilityByIndex(4) == ability or (caster:GetAbilityByIndex(2) == ability and (caster:HasModifier("modifier_storm") or caster:HasModifier("modifier_storm2")))) then
            PathRainOfStarsAA({caster = caster, target = target, ability = caster.combat_system_ability})
        end
    end
    --pet windfury
    if (event.fromsummon or event.fromcompanion or event.ComesFromPet) and caster:HasModifier("modifier_pathbuff_041") and math.random(1,100) <= 4 then
        caster.pet_proc_windfury_on_next_aa = true
    end
    if event.fromsummon and caster.pet_proc_windfury_on_next_aa and caster:HasModifier("modifier_pathbuff_041") then
        caster.pet_proc_windfury_on_next_aa = nil
        local pet = event.attacker
        if pet then
            Multistrike( {caster = pet, target = target, hits = 3} )
        end
    end
    local track_ability_stats = true
    if track_ability_stats and caster and caster:IsHero() then
        if not caster.ability_stats then
            caster.ability_stats = {}
        end
        --print(ability)
        if ability and not ability:IsNull() then
            local index = ability:GetAbilityIndex()
            if not caster.ability_stats[index] then
                caster.ability_stats[index] = 0
            end
            caster.ability_stats[index] = caster.ability_stats[index] + damage_table.damage
        end
    end
end

function MultiElementProcs(event, caster, target)
    local dur = {Duration = 20}
    local ability = caster.item_multi_element_ability
    if event.firedmg then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_element_fire", dur)
        if math.random(1,100) <= 5  and not caster.multi_ele_item_stun_cd then
            caster.multi_ele_item_stun_cd = true
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.buff = "modifier_stunned"
            myevent.ability = ability
            myevent.dur = 1
            ApplyBuff(myevent)
            Timers:CreateTimer(20,function()
                caster.multi_ele_item_stun_cd = false
            end)
        end
    end
    if event.shadowdmg then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_element_shadow", dur)
    end
    if event.frostdmg then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_element_frost", dur)
        local myevent = {}
        myevent.caster = caster
        myevent.target = target
        myevent.buff = "modifier_frostslow10"
        myevent.ability = ability
        myevent.dur = 15
        ApplyBuff(myevent)
    end
    if event.holydmg then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_element_holy", dur)
    end
    if event.naturedmg then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_element_nature", dur)
    end
    if event.arcanedmg then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_element_arcane", dur)
        local myevent = {}
        myevent.caster = caster
        myevent.target = target
        myevent.buff = "modifier_element_arcane_weaken"
        myevent.ability = ability
        myevent.dur = 15
        ApplyBuff(myevent)
    end
    if event.chaosdmg then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_element_chaos", dur)
    end
end

function CalcAbilityStatsPercent( caster )
    local sum = 0
    local sum_heal = 0
    for i=0, 6 do
        if caster.ability_stats and caster.ability_stats[i] then
            sum = sum + caster.ability_stats[i]
        end
        if caster.ability_stats_heal and caster.ability_stats_heal[i] then
            sum_heal = sum_heal + caster.ability_stats_heal[i]
        end
    end
    caster.ability_stats_percent = {}
    caster.ability_stats_percent_heal = {}
    for i=0, 6 do
        caster.ability_stats_percent[i] = 0
        caster.ability_stats_percent_heal[i] = 0
        if caster.ability_stats and caster.ability_stats[i] and sum > 0 then
            caster.ability_stats_percent[i] = math.floor(caster.ability_stats[i] * 100 / sum)
        end
        if caster.ability_stats_heal and caster.ability_stats_heal[i] and sum_heal > 0 then
            caster.ability_stats_percent_heal[i] = math.floor(caster.ability_stats_heal[i] * 100 / sum_heal)
        end
    end
end

function GetDragonBonusDamage( event, caster )
    local value = 1
    if not event.dragondmg then
        return value
    end
    if caster.talents then
        --if caster.talents[36] and caster.talents[36] > 0 then
        --    value = value + 0.25 * caster.talents[36]
        --end
        if caster.talents[69] and caster.talents[69] > 0 then
            value = value * (1 + 0.15 * caster.talents[69])
        end
    end
    if caster:HasModifier("modifier_tamerbond") then
        value = value * 1.5
    end
    if caster:HasModifier("modifier_pathbuff_059") and caster:HasModifier("modifier_path_shadowform") and caster:HasModifier("modifier_talent_invul") then
        value = value * 2
    end
    if caster:HasModifier("modifier_item_aura_ancient") then
        value = value * 1.3
    end
    if caster:HasModifier("modifier_pathbuff_072") and caster:HasModifier("modifier_crowfall") then
        value = value * 3
    end
    if caster:HasModifier("modifier_active99") then
        value = value * 1.25
    end
    if caster:HasModifier("item_mother_of_dragons") then
        value = value * 2
    end
    if caster:HasModifier("modifier_item_aura_empire") then
        value = value * 1.25
    end
    if caster:HasModifier("modifier_summon_companion_50") then
        value = value * 1.5
    end
    if caster:HasModifier("modifier_item_ancient_primary") then
        value = value * 1.1
    end
    if caster:HasModifier("modifier_item_dragonshield") then
        value = value * 1.25
    end
    local felhunter = caster:FindAbilityByName("Felhunter")
    if felhunter and felhunter:GetLevel() >= 3 then
        value = value * 1.5
    end
    return value
end

function GetSummonBonusDamage( event, caster, empower_stacks )
    local value = 1
    if not event.fromsummon and not event.ComesFromPet then
        return value
    end
    local demonbolt = caster:FindAbilityByName("demo2")
    if demonbolt and demonbolt:GetLevel() >= 4 then
        value = value * (1 + 0.2 * GetDemonCount(caster))
    end
    if caster.talents then
        if caster.talents[59] and caster.talents[59] > 0 then
            value = value * (1 + 0.25 * caster.talents[59])
        end
        if caster.talents[69] then
            value = value * (1 + 0.15 * caster.talents[69])
        end
        if caster.talents[11] and caster.talents[11] > 0 then
            value = value * (1 + 0.1 * caster.talents[11])
        end
    end
    local unholy_3 = caster:FindAbilityByName("unholy_3")
    if unholy_3 and unholy_3:GetLevel() >= 3 then
        value = value * (1 + 0.005 * GetAgilityCustom(caster))
    end
    local necroMark = caster:GetModifierStackCount("modifier_necrotic_mark", nil)
    if necroMark > 0 then
        value = value * (1 + 0.01 * necroMark)
    end
    if caster:HasModifier("modifier_fel_fire_summon") then
        value = value * 1.5
    end
    if caster.summon_bonus and caster.summon_bonus > 0 then
        value = value * 2
    end
    if caster.summon2_bonus and caster.summon2_bonus > 0 then
        value = value * 2
    end
    if caster:HasModifier("modifier_tamerbond") then
        value = value * 1.5
    end
    if caster:HasModifier("modifier_pathbuff_102") and event.shadowdmg then
        value = value * 1.25
    end
    if caster:HasModifier("modifier_pathbuff_072") and caster:HasModifier("modifier_crowfall") then
        value = value * 3
    end
    if caster:HasModifier("modifier_active99") then
        value = value * 1.25
    end
    if caster:HasModifier("modifier_pathbuff_059") and caster:HasModifier("modifier_path_shadowform") and caster:HasModifier("modifier_talent_invul") then
        value = value * 1.5
    end
    if caster:HasModifier("modifier_pathbuff_046") then
        value = value * 1.25
    end
    if caster:HasModifier("modifier_item_aura_empire") then
        value = value * 1.25
    end
    if caster:HasModifier("modifier_item_aura_ancient") then
        value = value * 1.25
    end
    if caster:HasModifier("modifier_summon_companion_50") then
        value = value * 1.5
    end
    local felhunter = caster:FindAbilityByName("Felhunter")
    if felhunter and felhunter:GetLevel() >= 3 then
        value = value * 1.5
    end
    if empower_stacks and empower_stacks > 0 then
        value = value * (1 + 0.01 * empower_stacks)
    end
    if caster:HasModifier("modifier_item_ancient_primary_heal") then
        value = value * 1.1
    end
    return value
end

function GetLowestMainAttribute( hero )
    local value1 = GetStrengthCustom(hero)
    local value2 = GetAgilityCustom(hero)
    local value3 = GetIntellectCustom(hero)
    if value1 > value2 then
        --no str
        if value2 > value3 then
            return value3
        else
            return value2
        end
    else
        --str or int
        if value1 > value3 then
            return value3
        else
            return value1
        end
    end
end

function HasMutationEffect(caster)
    return caster.inMonkeyKingForm or caster:HasModifier("modifier_shadow_form_ds") or caster:HasModifier("modifier_demon_form") or caster:HasModifier("modifier_path_shadowform") or caster:HasModifier("modifier_crowfall") or caster:HasModifier("modifier_catform") or caster:HasModifier("modifier_metamorph_terror") or caster:HasModifier("modifier_metamorph_dh") or caster:HasModifier("modifier_stormcrow") or caster:HasModifier("modifier_plague_form") or (caster:HasModifier("modifier_bear_roar_armor") and caster:HasModifier("modifier_class_ursa2"))
end

function GetElementalDamageModifierAdditive( event, caster, real_caster, target, ability, behindtarget, process_procs, dmgtype )
    local value = 1
    if event.frostdmg and caster:HasModifier("modifier_class_invoker") then -- and caster:HasModifier("modifier_arcane_barrage_bonus") then
        event.arcanedmg = 1
    end
    if GetMetamorphosisStat(caster) >= 1 and HasMutationEffect(caster) then
        value = value + 0.01 * GetMetamorphosisStat(caster)
    end
    if dmgtype == 1 and event.isdot and caster:HasModifier("modifier_big") then
        value = value + 0.15
    end
    if dmgtype == 1 and event.isdot and caster:HasModifier("modifier_big2") then
        value = value + 0.25
    end
    if (event.firedmg or event.naturedmg or event.frostdmg) and GetLevelOfAbility(caster, "Ghost4") >= 3 and caster:HasModifier("modifier_stormaurabuff1") then
        value = value + 0.5 + 0.001 * GetLowestMainAttribute(caster)
    end
    if event.naturedmg then
        value = value + 0.1 *caster:GetModifierStackCount("modifier_ele_thunder_stacks", nil)
    end
    if dmgtype == 1 and caster:IsRealHero() then
        value = value + 0.001 * GetStrengthCustom(caster) --0.0008
    end
    if event.holydmg and caster:HasModifier("modifier_class_sanct2") and caster:GetName() == "npc_dota_hero_phantom_lancer" then
        value = value + 0.5 * caster:Script_GetMagicalArmorValue(false, nil)
    end
    if event.frostdmg and caster:HasModifier("modifier_npc_dota_hero_drow_ranger") and caster:HasModifier("modifier_manacost_reduction") then
        value = value + 2
    end
    if caster:HasModifier("modifier_class_brawler") and target and target:HasModifier("modifier_arms_bleed") and caster:IsRealHero() and dmgtype == 1 then
        value = value + 0.001 * GetStrengthCustom(caster) --0.0008
    end
    if event.naturedmg and caster:HasModifier("modifier_class_bounty") and caster:IsRealHero() then
        value = value + 0.001 * GetAgilityCustom(caster)
    end
    if event.holydmg and caster:HasModifier("modifier_godschosen2") then
        value = value + 1
    end
    if event.holydmg and caster:HasModifier("modifier_holydmg") then
        value = value + 0.5
    end
    if event.chaosdmg and caster:HasModifier("modifier_item_demonglaive") then
        value = value + 0.25
    end
    if event.chaosdmg and caster:HasModifier("modifier_item_ancient_dot") then
        value = value + 0.25
    end
    if event.arcanedmg and caster:HasModifier("modifier_pathbuff_033") then
        value = value + 0.25
    end
    if event.shadowdmg and caster:HasModifier("modifier_item_ancient_dot") then
        value = value + 0.25
    end
    if event.holydmg and caster:HasModifier("modifier_npc_dota_hero_legion2") and caster:HasModifier("modifier_fanatism") then
        local bonusfromms = caster:GetMoveSpeedModifier(caster:GetBaseMoveSpeed(), true) - 300
        if bonusfromms > 0 then
            value = value + 0.01 * bonusfromms
        end
    end
    if event.shadowdmg and caster:HasModifier("modifier_item_nova_blade_shadow") then
        value = value + 0.25
    end
    if event.chaosdmg and caster:HasModifier("modifier_item_chaos_dh") then
        value = value + 0.15
    end
    if dmgtype == 1 and caster:HasModifier("modifier_guardian_temple_phys") then
        value = value + 0.3
    end
    if event.shadowdmg then
        local demonbolt = caster:FindAbilityByName("demo2")
        if demonbolt and demonbolt:GetLevel() >= 3 then
            value = value + 0.2 * GetDemonCount(caster)
        end
    end
    if event.firedmg then
        local demo3 = caster:FindAbilityByName("demo3")
        if demo3 and demo3:GetLevel() >= 3 then
            value = value + 0.2 * GetAbilitiesOnCooldown(caster)
        end
        if caster:HasModifier("modifier_npc_dota_hero_windrunner2") and caster:HasModifier("modifier_fire_shots_jungle") then
            value = value + 0.002 * GetAgilityCustom(caster)
        end
    end
    if event.arcanedmg and caster:HasModifier("modifier_moonfall_aura") then
        value = value + 0.5
    end
    if event.firedmg and (event.isaoe or event.isdot) and caster:HasModifier("modifier_firebow") then
        value = value + caster:GetPhysicalArmorValue(false) * 0.02
    end
    if event.firedmg and (event.isaoe or event.isdot) and caster:HasModifier("modifier_firebow2") then
        value = value + caster:GetPhysicalArmorValue(false) * 0.03
    end
    if event.naturedmg and caster:HasModifier("modifier_moonfall_aura") then
        value = value + 0.5
    end
    if event.naturedmg and GetForceOfNatureStat(caster) > 0 then
        value = value + 0.0001 * GetStrengthCustom(caster) * GetForceOfNatureStat(caster)
    end

    if event.firedmg and caster.fof and caster.fof > 0 then
        value = value + 0.0001 * GetStrengthCustom(caster) * caster.fof
    end
    if event.frostdmg and caster.ffe and caster.ffe > 0 then
        value = value + 0.0001 * GetAgilityCustom(caster) * caster.ffe
    end
    if event.holydmg and caster.hog and caster.hog > 0 then
        value = value + 0.0001 * GetIntellectCustom(caster) * caster.hog
    end
    if event.shadowdmg and caster.shw and caster.shw > 0 then
        value = value + 0.01 * caster:Script_GetMagicalArmorValue(false, nil) * caster.shw
    end
    if dmgtype == 1 and caster.shw and caster.shw > 0 then
        value = value + 0.01 * caster:Script_GetMagicalArmorValue(false, nil) * caster.shw
    end
    if event.naturedmg and caster.woz and caster.woz > 0 then
        value = value + 0.01 * caster:GetIncreasedAttackSpeed(false) * caster.woz
    end
    if event.chaosdmg and caster.und and caster.und > 0 then
        value = value + 0.0001 * caster:GetPhysicalArmorValue(false) * caster.und
    end
    if dmgtype == 1 and caster.und and caster.und > 0 then
        value = value + 0.0001 * caster:GetPhysicalArmorValue(false) * caster.und
    end
    if event.arcanedmg and caster.nec and caster.nec > 0 and caster.hpPercentValue and caster.manaPercentValue then
        value = value + 0.01 * (caster.hpPercentValue + caster.manaPercentValue) * caster.nec
    end

    if event.chaosdmg and caster:HasModifier("modifier_dh_soulpact_chaos") then
        value = value + 0.25
    end
    if event.firedmg and caster:HasModifier("modifier_pathbuff_057") then
        value = value + 0.25
    end
    if event.firedmg and caster:HasModifier("modifier_pathbuff_118") then
        value = value + 0.2
    end
    if event.naturedmg and caster:HasModifier("modifier_pathbuff_119") then
        value = value + 0.25
    end
    if event.arcanedmg and caster:HasModifier("modifier_pathbuff_120") then
        value = value + 0.5
    end
    if event.shadowdmg and caster:HasModifier("modifier_heal_on_summon_dmg") and caster:HasModifier("modifier_class_unholy") then
        value = value + 0.5
    end
    if event.arcanedmg and caster:HasModifier("modifier_pathbuff_081") and caster:HasModifier("modifier_skyfall") and caster:HasModifier("modifier_crit_moon_cd") then
        value = value + 0.5
    end
    if dmgtype == 1 and caster:HasModifier("modifier_pathbuff_089") and caster:HasModifier("modifier_crowfall") and caster:HasModifier("modifier_talent_enrage") then
        value = value + 0.5
    end
    if event.naturedmg and caster:HasModifier("modifier_pathbuff_089") and caster:HasModifier("modifier_crowfall") and caster:HasModifier("modifier_talent_enrage") then
        value = value + 0.5
    end
    if event.firedmg and caster:HasModifier("modifier_talent57cd") and caster:HasModifier("modifier_pathbuff_071") and caster:HasModifier("modifier_path_overwhelm") then
        value = value + 2
    end
    if event.shadowdmg and caster.ds_shadow_bonus_50 and caster.ds_shadow_bonus_50 > 0 then
        value = value + 0.5
    end
    if caster:HasModifier("modifier_item_myth_agi") then
        value = value + 0.25
    end
    --if event.firedmg and caster:HasModifier("modifier_burning_nether") then
    --    value = value + 0.25
    --end
    local shadow_stance_cleric = caster:GetModifierStackCount("modifier_shadow_stance", nil)
    if event.shadowdmg and shadow_stance_cleric > 0 then
        value = value + 0.05 * shadow_stance_cleric
    end
    if event.chaosdmg then
        local dh_agi_talent = caster:FindAbilityByName("terror3")
        if dh_agi_talent and dh_agi_talent:GetLevel() >= 4 then
            value = value + GetAgilityCustom(caster) * 0.001
        end
    end
    if event.shadowdmg and target and target:HasModifier("modifier_rooted_self_slow") then
        value = value + 0.25
    end
    if event.shadowdmg and caster:HasModifier("modifier_nightmare_sp") then
        value = value + 1
    end
    if event.holydmg and caster:HasModifier("modifier_item_item_set_t4_aad_4") then
        value = value + 0.25
    end
    if event.naturedmg and caster:HasModifier("modifier_item_item_set_t4_aad_4") then
        value = value + 0.25
    end
    if event.holydmg and caster:HasModifier("modifier_item_item_set_t4_aad_5") then
        value = value + 0.25
    end
    if event.naturedmg and caster:HasModifier("modifier_item_item_set_t4_aad_5") then
        value = value + 0.25
    end
    if event.naturedmg and caster:HasModifier("modifier_special_bonus_respawn_reduction") then
        value = value + 0.25
    end
    if event.naturedmg and caster:HasModifier("modifier_pathbuff_087") then
        value = value + 0.25
    end
    if event.naturedmg and target and target:HasModifier("modifier_bear_slow_pve") then
        value = value + 0.3
    end
    if event.firedmg and target and target:HasModifier("modifier_bear_slow_pve") then
        value = value + 0.3
    end
    if event.arcanedmg and caster:HasModifier("modifier_class_invoker") then
        value = value + 0.25
    end
    if event.holydmg and target and target:HasModifier("modifier_holy_shadow_weakness") then
        value = value + 0.25
    end
    if event.shadowdmg and target and target:HasModifier("modifier_holy_shadow_weakness") then
        value = value + 0.25
    end
    if event.arcanedmg and caster:HasModifier("modifier_astral_ele_bonus") then
        value = value + 1
    end
    if event.naturedmg and caster:HasModifier("modifier_astral_ele_bonus") then
        value = value + 1
    end
    if event.firedmg and caster:HasModifier("modifier_astral_ele_bonus") then
        value = value + 1
    end
    if event.firedmg and caster:HasModifier("modifier_thorns_buff") then
        value = value + 0.25
    end
    if event.naturedmg and caster:HasModifier("modifier_thorns_buff") then
        value = value + 0.25
    end
    if event.arcanedmg and caster:HasModifier("modifier_thorns_buff") then
        value = value + 0.25
    end
    if event.chaosdmg and caster:HasModifier("modifier_class_am") and caster:HasModifier("modifier_asfury") then
        value = value + 0.5
    end
    if caster.talents then
        if caster.talents[100] and event.chaosdmg then
            value = value + 0.2 * caster.talents[100]
        end
        if caster.talents[100] and dmgtype == 1 then
            value = value + 0.2 * caster.talents[100]
        end
        if caster.talents[16] and event.naturedmg then
            value = value + 0.15 * caster.talents[16]
        end
        if caster.talents[16] and event.arcanedmg then
            value = value + 0.15 * caster.talents[16]
        end
        if caster.talents[42] and event.naturedmg then
            value = value + 0.15 * caster.talents[42]
        end
        if caster.talents[27] and event.arcanedmg then
            value = value + 0.15 * caster.talents[27]
        end
        if caster.talents[29] and event.firedmg then
            value = value + 0.15 * caster.talents[29]
        end
        if caster.talents[30] and event.frostdmg then
            value = value + 0.15 * caster.talents[30]
        end
        if caster.talents[64] and caster.talents[64] > 0 and event.shadowdmg then
            value = value + 0.1 * caster.talents[64]
        end
        if caster.talents[64] and caster.talents[64] > 0 and event.holydmg then
            local holyfactor = 0.1
            if caster:HasModifier("modifier_holyaaa") or caster:HasModifier("modifier_holyaaa2") then
                holyfactor = 0.2
            end
            value = value + holyfactor * caster.talents[64]
        end
        --if dmgtype == 1 and caster.talents[75] and caster.talents[75] > 0 then
        --    value = value + caster:GetMagicalArmorValue() * 0.25 * caster.talents[75]
        --end
        --if event.shadowdmg and caster.talents[75] and caster.talents[75] > 0 then
        --    value = value + caster:GetMagicalArmorValue() * 0.25 * caster.talents[75]
        --end
        --if event.chaosdmg and caster.talents[75] and caster.talents[75] > 0 then
        --    value = value + caster:GetMagicalArmorValue() * 0.25 * caster.talents[75]
        --end
        if caster.talents[68] and caster.talents[68] > 0 and (event.shadowdmg or event.chaosdmg) and process_procs then
            if caster.path_dark_ritual then
                caster.path_dark_ritual = caster.path_dark_ritual + 1
            else
                caster.path_dark_ritual = 1
            end
            Timers:CreateTimer(15,function()
                caster.path_dark_ritual = caster.path_dark_ritual - 1
            end)
        end
        --[[
        if caster.talents[36] and caster.talents[36] > 0 and event.firedmg and process_procs then
            if caster.path_dragon_fire then
                caster.path_dragon_fire = caster.path_dragon_fire + 1
            else
                caster.path_dragon_fire = 1
            end
            Timers:CreateTimer(15,function()
                caster.path_dragon_fire = caster.path_dragon_fire - 1
            end)
        end]]
    end
    local distance = 1
    if caster and target then
        distance = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
    end
    if dmgtype == 1 and distance > 700 and caster:HasModifier("modifier_item_longbow") then
        value = value + 0.5
    end
    local icenovastacks = caster:GetModifierStackCount("modifier_ice_nova_bonus", nil)
    if event.frostdmg and icenovastacks > 0 then
        value = value + 0.1 * icenovastacks
    end
    if caster:HasModifier("modifier_polybonusdamage") then
        value = value + 0.25
    end
    if event.shadowdmg and caster:HasModifier("modifier_shadowdmgaura") then
        value = value + 0.25
    end
    if event.shadowdmg and caster:HasModifier("modifier_str_unholy") then
        value = value + 0.75
    end
    if event.firedmg and event.isdot and caster:HasModifier("modifier_item_elements") then
        value = value + 0.25
    end
    if event.firedmg and caster:HasModifier("firedmgaura") then
        value = value + 0.25
    end
    local arcane_resi_dmg = caster:FindAbilityByName("Arcane6")
    if event.firedmg and arcane_resi_dmg and arcane_resi_dmg:GetLevel() >= 4 then
        value = value + caster:Script_GetMagicalArmorValue(false, nil)
    end
    if event.arcanedmg and arcane_resi_dmg and arcane_resi_dmg:GetLevel() >= 4 then
        value = value + caster:Script_GetMagicalArmorValue(false, nil)
    end
    arcane_resi_dmg = caster:FindAbilityByName("frost_lake")
    if event.frostdmg and arcane_resi_dmg and arcane_resi_dmg:GetLevel() >= 4 then
        value = value + 0.5
    end
    arcane_resi_dmg = caster:FindAbilityByName("deadly2")
    if event.frostdmg and arcane_resi_dmg and arcane_resi_dmg:GetLevel() >= 3 then
        value = value + 1
    end
    local mage1_abil = caster:FindAbilityByName("mage1")
    if target and target:HasModifier("modifier_frostfire_slow") and event.firedmg and mage1_abil and mage1_abil:GetLevel() >= 4 then
        value = value + 0.5
    end
    if target and target:HasModifier("modifier_frostfire_slow") and event.frostdmg and mage1_abil and mage1_abil:GetLevel() >= 4 then
        value = value + 0.5
    end
    if event.firedmg and caster:HasModifier("modifier_firedmg_50") then
        value = value + 0.25
    end
    if event.holydmg and caster:HasModifier("modifier_item_bootshp3") then
        value = value + 0.1
    end
    if event.shadowdmg and caster:HasModifier("modifier_item_bootshp4") then
        value = value + 0.1
    end
    if event.firedmg and caster:HasModifier("modifier_item_fireball4") then
        value = value + 0.5
    end
    if event.firedmg and caster:HasModifier("modifier_item_sandstorm2") then
        value = value + 0.25
    end
    arcane_resi_dmg = caster:FindAbilityByName("Numbing_Cut")
    if arcane_resi_dmg and arcane_resi_dmg:GetLevel() >= 4 and event.cruelabils and target and target:HasModifier("modifier_stunned") then
        value = value + 1
    end
    if event.shadowdmg and caster:HasModifier("modifier_shadowflame") then
        value = value + 0.25
    end
    if event.firedmg and caster:HasModifier("modifier_shadowflame") then
        value = value + 0.25
    end
    local maskOfHorrorModifier = caster:FindModifierByName("modifier_ancient_def")
    if(maskOfHorrorModifier) then
        local maskOfHorrorModifierAbility = maskOfHorrorModifier:GetAbility()
        if(maskOfHorrorModifierAbility) then
            if event.chaosdmg then
                value = value + maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat7") / 100
            end
            if event.firedmg then
                value = value + maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat6") / 100
            end
            if event.shadowdmg then
                value = value + maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat5") / 100
            end
        end
    end
    if event.arcanedmg and caster:HasModifier("modifier_stormrider") then
        value = value + 0.25
    end
    if event.naturedmg and caster:HasModifier("modifier_stormrider") then
        value = value + 0.25
    end
    local arcane2_stacks = caster:GetModifierStackCount("modifier_arcane_barrage_bonus", nil)
    if event.arcanedmg and arcane2_stacks > 0 then
        value = value + 0.25 * arcane2_stacks
    end
    arcane2_stacks = caster:GetModifierStackCount("modifier_fire_barrage_bonus", nil)
    if event.arcanedmg and arcane2_stacks > 0 then
        value = value + 0.25 * arcane2_stacks
    end
    if event.firedmg and arcane2_stacks > 0 then
        value = value + 0.25 * arcane2_stacks
    end
    if event.arcanedmg and caster:HasModifier("modifier_nether_explosion_buff") then
        value = value + 0.5
    end
    if event.firedmg and caster:HasModifier("modifier_stormrider2") then
        value = value + 0.5
    end
    if event.shadowdmg and caster:HasModifier("modifier_warlockrage") then
        value = value + 1
    end
    --mythic
    if event.firedmg and caster:HasModifier("modifier_mythic_firedmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_firedmg", nil)/100
    end
    if event.arcanedmg and caster:HasModifier("modifier_mythic_arcanedmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_arcanedmg", nil)/100
    end
    if event.naturedmg and caster:HasModifier("modifier_mythic_naturedmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_naturedmg", nil)/100
    end
    if event.shadowdmg and caster:HasModifier("modifier_mythic_shadowdmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_shadowdmg", nil)/100
    end
    if event.frostdmg and caster:HasModifier("modifier_mythic_frostdmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_frostdmg", nil)/100
    end
    if event.holydmg and caster:HasModifier("modifier_mythic_holydmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_holydmg", nil)/100
    end
    if event.chaosdmg and caster:HasModifier("modifier_mythic_chaosdmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_chaosdmg", nil)/100
    end
    if dmgtype == 1 and caster:HasModifier("modifier_mythic_physicaldmg") then
        value = value + caster:GetModifierStackCount("modifier_mythic_physicaldmg", nil)/100
    end

    if event.naturedmg and caster:HasModifier("modifier_ranger_as_bonus_surv") then
        value = value + 0.5
    end
    if event.poisondmg and caster:HasModifier("modifier_item_viper_blade") then
        value = value + 0.25
    end
    if event.poisondmg and caster:HasModifier("modifier_item_viper_blade2") then
        value = value + 0.4
    end
    if event.firedmg and caster:HasModifier("modifier_master_elements") then
        value = value + 0.5
    end
    if event.naturedmg and caster:HasModifier("modifier_master_elements") then
        value = value + 0.5
    end
    if event.frostdmg and caster:HasModifier("modifier_master_elements") then
        value = value + 0.5
    end
    if event.arcanedmg and caster:HasModifier("modifier_master_elements") then
        value = value + 0.5
    end
    if event.naturedmg and caster:HasModifier("modifier_item_nova_blade") then
        value = value + 0.25
    end
    if event.naturedmg and caster:HasModifier("modifier_item_nature") then
        value = value + 0.5
    end
    if event.naturedmg and caster:HasModifier("modifier_item_nova_blade2") then
        value = value + 0.4
    end
    local rangerelementtalent = caster:FindAbilityByName("wind7")
    if event.shadowdmg and rangerelementtalent and rangerelementtalent:GetLevel() >= 2 then
        value = value + 0.25
    end
    if event.naturedmg and rangerelementtalent and rangerelementtalent:GetLevel() >= 4 then
        value = value + 0.15
    end
    if event.firedmg and rangerelementtalent and rangerelementtalent:GetLevel() >= 4 then
        value = value + 0.15
    end
    local rogue_bounty_poison_talent = caster:FindAbilityByName("combat6")
    if event.poisondmg and rogue_bounty_poison_talent and rogue_bounty_poison_talent:GetLevel() >= 4 then
        value = value + 0.5
    end
    if event.naturedmg and rogue_bounty_poison_talent and rogue_bounty_poison_talent:GetLevel() >= 4 then
        value = value + 0.5
    end
    local polymorph_talent = caster:FindAbilityByName("Polymorph")
    if polymorph_talent and polymorph_talent:GetLevel() >= 4 then
        local speed = caster:GetMoveSpeedModifier(caster:GetBaseMoveSpeed(), true) - 300
        if speed > 0 then
            value = value + 0.0025 * speed
        end
    end
    local int_to_holy_pala = caster:FindAbilityByName("pala4")
    if event.holydmg and int_to_holy_pala and int_to_holy_pala:GetLevel() >= 4 then
        local bonus_fire = GetIntellectCustom(caster) * 0.001
        --if bonus_fire > 0.3 then
        --    bonus_fire = 0.3
        --end
        value = value + bonus_fire
    end
    local agi_to_holy_pala = caster:FindAbilityByName("pala5")
    if event.holydmg and agi_to_holy_pala and agi_to_holy_pala:GetLevel() >= 4 then
        local bonus_fire = GetAgilityCustom(caster) * 0.001
        --if bonus_fire > 0.3 then
        --    bonus_fire = 0.3
        --end
        value = value + bonus_fire
    end
    int_to_holy_pala = caster:FindAbilityByName("Lightning_Bolt")
    if event.naturedmg and int_to_holy_pala and int_to_holy_pala:GetLevel() >= 4 then
        local bonus_fire = GetIntellectCustom(caster) * 0.001
        --if bonus_fire > 0.3 then
        --    bonus_fire = 0.3
        --end
        value = value + bonus_fire
    end
    int_to_holy_pala = caster:FindAbilityByName("Spirit_Shock")
    if event.firedmg and int_to_holy_pala and int_to_holy_pala:GetLevel() >= 4 then
        local bonus_fire = GetSpellpower({caster = caster}) / 1500 -- * 0.001
        --if bonus_fire > 0.3 then
        --    bonus_fire = 0.3
        --end
        value = value + bonus_fire
    end
    local haste_to_fire = caster:FindAbilityByName("Magma_Bolt")
    if caster and caster.spellhaste and event.firedmg and haste_to_fire and haste_to_fire:GetLevel() >= 4 then
        local bonus_fire = caster.spellhaste * 0.15
        --if bonus_fire > 0.3 then
        --    bonus_fire = 0.3
        --end
        value = value + bonus_fire
    end
    local templedk_shadow = caster:FindAbilityByName("templedk1")
    if event.shadowdmg and templedk_shadow and templedk_shadow:GetLevel() >= 4 then
        value = value + 0.25
    end
    haste_to_fire = caster:FindAbilityByName("Shadowfury")
    if caster and caster.spellhaste and event.shadowdmg and haste_to_fire and haste_to_fire:GetLevel() >= 4 then
        local bonus_fire = caster.spellhaste * 0.25
        --if bonus_fire > 0.5 then
        --    bonus_fire = 0.5
        --end
        value = value + bonus_fire
    end
    haste_to_fire = caster:FindAbilityByName("destro3")
    if caster and event.chaosdmg and haste_to_fire and haste_to_fire:GetLevel() >= 3 then
        local bonus_fire = GetStrengthCustom(caster) * 0.001
        --if bonus_fire > 0.5 then
        --    bonus_fire = 0.5
        --end
        value = value + bonus_fire
    end
    if caster and caster.spellhaste and event.frostdmg and caster:HasModifier("modifier_class_winter") and caster:HasModifier("modifier_ice_armor") then
        local winter_bonus = caster.spellhaste * 0.5
        if winter_bonus > 4 then
            winter_bonus = 4
        end
        value = value + winter_bonus
    end
    if event.firedmg and caster:HasModifier("modifier_item_frostfire") then
        value = value + 0.2
    end
    if event.frostdmg and caster:HasModifier("modifier_item_frostfire") then
        value = value + 0.2
    end
    if event.firedmg and caster:HasModifier("modifier_item_frostfire2") then
        value = value + 0.3
    end
    if event.frostdmg and caster:HasModifier("modifier_item_frostfire2") then
        value = value + 0.3
    end
    if event.frostdmg then
        if caster:HasModifier("modifier_item_element_frost") then
            value = value + 0.25
        end
        if caster:HasModifier("modifier_item_crit_frost_immortal") then
            value = value + 0.4
        end
        if caster:HasModifier("modifier_item_crit_frost_immortal2") then
            value = value + 0.5
        end
    end
    if event.shadowdmg and caster:HasModifier("modifier_item_elements") then
        value = value + 0.25
    end
    if event.holydmg and caster:HasModifier("modifier_crusader_mount") then
        value = value + 0.25
    end
    if event.frostdmg and target and target:HasModifier("modifier_frost_bonus_arctic") then
        value = value + 0.2
    end
    --multiplicative bonuses
    if (dmgtype == 1 or event.naturedmg) and caster:HasModifier("modifier_bladerush") and caster:HasModifier("modifier_item_rogueblades2") then
        value = (value - 1) * 2 + 1
    end
    if event.shadowdmg and caster:HasModifier("modifier_class_warlock") and target and target:HasModifier("modifier_dot1") then
        value = (value - 1) * 2 + 1
    end
    if event.frostdmg and caster:HasModifier("modifier_pathbuff_055") then
        value = (value - 1) * 2 + 1
    end
    if caster.talents and caster.talents[127] and caster.talents[127] > 0 then
    	local icestorm_factor = 0.3333 * caster.talents[127]
        value = (value - 1) * (1 + icestorm_factor) + 1
    end
    if event.starfallbonus and event.naturedmg then
    	value = (value - 1) * 2 + 1
    end
    return value
end
--22222

function GetAbilityAOEDamageModifierAdditive( event, caster, real_caster, target, ability, behindtarget, process_procs )
    local value = 1
    --talents
    if caster.talents then
  
    end
    --rune words
    if caster.runeword then

    end
    return value
end

--[[
function GetAbilityDamageModifierAdditive( event, caster, real_caster, target, ability, behindtarget, process_procs )
    local value = 1
    if event.consumesuncharge then
        local stack = caster:GetModifierStackCount("modifier_mooncharge", caster)
        if stack >= 5 then
            caster:RemoveModifierByName("modifier_mooncharge")
            value = value + 1.35
        end
    end
    --if event.moltenlavabonus then
        --local molten_lava_ability = caster:FindAbilityByName("Molten_Lava")
        --if target:HasModifier("fireslow50") and molten_lava_ability and molten_lava_ability:GetLevel() >= 3 then
        --   value = value + 0.4
        --end
    --end
    if event.firelance and target:HasModifier("modifier_magmaburn") and target:HasModifier("fireslow50") then
        value = value + event.firelance - 1
    end
    if caster.elemental_item3 and caster:HasModifier("modifier_item_elements3") then
        local bonusdmg = 0
        if caster:HasModifier("modifier_dmgitem_fire") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_arcane") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_shadow") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_nature") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_holy") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_frost") then
            bonusdmg = bonusdmg + 0.15
        end
        value = value + bonusdmg
    end
    
    local dk_blood_stacks = caster:GetModifierStackCount("modifier_strikeofvengeance2", nil)
    if dk_blood_stacks > 0 then
        value = value + 0.1 * dk_blood_stacks
    end
    local pala_retal_stacks = caster:GetModifierStackCount("modifier_strikeofvengeance3", nil)
    if pala_retal_stacks > 0 then
        value = value + 0.1 * pala_retal_stacks
    end
    if caster:GetAbilityByIndex(5) and caster:GetAbilityByIndex(5):GetName() == "moon6" and caster:GetAbilityByIndex(5):GetLevel() >= 2 then
        value = value + 0.3
    end
    if event.immolatebonus ~= nil then
        if target:HasModifier("modifier_magmaburn2") then
            value = value + event.immolatebonus/100.0
        end 
    end
    if caster:HasModifier("modifier_item_longbow") and ability == caster:GetAbilityByIndex(2) then
        value = value + 1
    end
    if event.ancientlongbow and caster:HasModifier("modifier_itemhastebow") then
        value = value + 0.25
    end
    if event.ancientlongbow and caster:HasModifier("modifier_item_hunterbow") then
        value = value + 0.35
    end
    if caster:HasModifier("modifier_active9") then
        value = value + 0.3
    end
    if caster:HasModifier("modifier_item_ancient_grizzly") then
        value = value + 0.5
    end
    if event.ambushblade and caster:HasModifier("modifier_item_armoriron2") then
        value = value + 0.15
    end
    if caster:HasModifier("modifier_dmgbonus_cruel") then
        value = value + 0.25
    end
    if (event.shadowdmg or event.holydmg) and target:HasModifier("modifier_holy_shadow_weakness") then
        value = value + 0.2
    end
    if caster:HasModifier("modifier_activepaladin") then
        value = value + 0.25
    end
    if event.untamed and caster:HasModifier("modifier_item_straxe3") then
        value = value + event.untamed - 1
    end
    if caster:HasModifier("modifier_elemental_lust2") then
        value = value+0.25
    end

    if event.rampupdamage then
        if caster.rampupdamage then
            value = value + caster.rampupdamage - 1
        end
    end
    
    --rune words
    if caster.runeword then
        --if event.bloodwolf and caster.runeword[17] then
        --    value = value + 0.01 * caster.runeword[17]
        --end
        if caster.runeword[19] then
            --finaldamage = finaldamage * (1 + 0.01 * caster.runeword[19])
            value = value + 0.01 * caster.runeword[19]
        end
        if caster.runeword[24] and ability and ability == caster:GetAbilityByIndex(2) then
            --finaldamage = finaldamage * (1 + 0.01 * caster.runeword[24])
            value = value + 0.01 * caster.runeword[24]
        end
        if caster.runeword[25] and ability and ability == caster:GetAbilityByIndex(3) then
            --finaldamage = finaldamage * (1 + 0.01 * caster.runeword[25])
            value = value + 0.01 * caster.runeword[25]
        end
        if caster.runeword[26] and ability and ability == caster:GetAbilityByIndex(4) then
            --finaldamage = finaldamage * (1 + 0.01 * caster.runeword[26])
            value = value + 0.01 * caster.runeword[26]
        end
        if caster.runeword[27] and ability and ability == caster:GetAbilityByIndex(1) then
            --finaldamage = finaldamage * (1 + 0.01 * caster.runeword[27])
            value = value + 0.01 * caster.runeword[27]
        end
        if event.runewordscale and event.runewordscale == 10 and caster.runeword[event.runewordscale] and caster.runeword[event.runewordscale] > 0 then
            value = value + caster.runeword[event.runewordscale] / 100
        end
    end

    --target talents, unused
    --if target.talents then
    --    if target.talents[11] then
    --        value = value - 0.1 * target.talents[11]
    --    end
    --end

    
    if event.feralbonus ~= nil then
        value = value + 0.15*target:GetModifierStackCount("modifier_bleedslow", nil)
    end
    if event.thunderstacks then
        value = value + 0.15*caster:GetModifierStackCount("modifier_ele_thunder_stacks", nil)
    end
    local snowrangerbonus = caster:GetModifierStackCount("modifier_ranger_as_bonus", nil)
    if snowrangerbonus > 0 then
        value = value + 0.05 * snowrangerbonus
    end
    local distance = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
    if event.rangeddoubledamage and event.rangeddoubledamage > 0 and distance > event.rangeddoubledamage then
        value = value + 1
        if process_procs then
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_abaddon/abaddon_death_coil_explosion_e.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
    if event.shadowstrikewl and caster:HasModifier("modifier_item_shadowstrike") then
        local b = 0
        if target:HasModifier("modifier_dot1") then
            b = b + 0.35
        end
        b = b + 0.35*target:GetModifierStackCount("modifier_dot2", nil)
        if target:HasModifier("modifier_dot4") then
            b = b + 0.35
        end
        value = value + b
    end
    if event.shadowstrikesp and caster:HasModifier("modifier_item_shadowstrike") then
        local b = 0
        if target:HasModifier("modifier_swd") then
            b = b + 0.35
        end
        local mods = target:GetModifierCount()-1
        for k=0, mods do
            local name = target:GetModifierNameByIndex(k)
            if name == "modifier_swd_2" then
                b = b + 0.35
            end
        end
        value = value + b
    end
    local dhabiltalent = caster:FindAbilityByName("dh1")
    if dhabiltalent and dhabiltalent:GetLevel() >= 4 then
        value = value + caster:GetAgility() * 0.002
    end
    
    local bearroartalent = caster:FindAbilityByName("bear6")
    if bearroartalent and bearroartalent:GetLevel() >= 3 and caster:HasModifier("modifier_bear_roar_armor") then
        value = value + 0.5
    end
    local fury_as_abil = caster:FindAbilityByName("fury2")
    if fury_as_abil and fury_as_abil:GetLevel() >= 4 then
        value = value + 0.05 * caster:GetIncreasedAttackSpeed()
    end
    local arcane_resi_dmg = caster:FindAbilityByName("Arcane6")
    if arcane_resi_dmg and arcane_resi_dmg:GetLevel() >= 4 then
        value = value + 1 * caster:GetMagicalArmorValue()
    end
    local dk_resi_dmg = caster:FindAbilityByName("Rot")
    if dk_resi_dmg and dk_resi_dmg:GetLevel() >= 4 then
        value = value + 1 * caster:GetMagicalArmorValue()
    end
    if caster:HasModifier("item_mother_of_dragons") then
        value = value + 0.15
    end
    
    if event.brutalsetscale and caster:HasModifier("modifier_item_set_str_t3_2_full_dream") then
        value = value + 2
    end

    local arcane_barrage_stacks = caster:GetModifierStackCount("modifier_arcane_barrage_bonus", nil)
    if event.isarcanebarrage and arcane_barrage_stacks > 0 then
        value = value + 0.1 * arcane_barrage_stacks
    end
    
    if event.dreamfeastbonus and target:HasModifier("modifier_swd") then
        value = value + event.dreamfeastbonus - 1
    end
    
    if event.starfallbonus and caster:HasModifier("modifier_item_dmg4") then
        value = value + 1
    end
    if caster:HasModifier("modifier_item_silverblood2_active") then
        value = value + 0.25
    end
    if caster:HasModifier("modifier_item_int_set_t3_active") then
        value = value + 1.3
    end
    if event.warlockdrainbonus ~= nil then
        local drainbonus = 0
        if target:HasModifier("modifier_dot1") then
            drainbonus = drainbonus + event.warlockdrainbonus
        end
        drainbonus = drainbonus + event.warlockdrainbonus*target:GetModifierStackCount("modifier_dot2", nil)
        if target:HasModifier("modifier_dot4") then
            drainbonus = drainbonus + event.warlockdrainbonus
        end
        value = value + drainbonus
    end
    if caster:HasModifier("modifier_shadowstep1") then
        value = value + 0.3
    end
    --if caster:HasModifier("modifier_axe_dmg_titan") then
    --    value = value+0.25
    --end
    if caster:HasModifier("modifier_tigerfury") then
        value = value+0.4
    end
    local furycatstacks = caster:GetModifierStackCount("modifier_furycat", nil)
    if event.feralleapbonus and furycatstacks > 0 then
        value = value + 0.25 * furycatstacks
    end
    local icenovastacks = caster:GetModifierStackCount("modifier_ice_nova_bonus", nil)
    if event.frostdmg and icenovastacks > 0 then
        value = value+ 0.1 * icenovastacks
    end
    local abil_dmg_stacks_5 = caster:GetModifierStackCount("modifier_abil_bonus_5_percent", nil)
    if abil_dmg_stacks_5 > 0 then
        value = value + 0.05 * abil_dmg_stacks_5
    end
    --if caster:HasModifier("modifier_talent_enrage") then
    --    if caster.runeword and caster.runeword[14] then
    --        value = value + caster.runeword[14]/100
    --   end
    --end
    --if caster:HasModifier("modifier_talent_enrage_2") and caster.talents and caster.talents[45] and caster.talents[45] > 0 then
    --    value = value + 0.25 * caster.talents[45]
    --end
    if event.chaosstrike and caster:HasModifier("modifier_metamorph_dh") then
        value = value + event.chaosstrike - 1
    end
    if event.championprot and caster:HasModifier("modifier_item_straxe2") then
        local shieldbashstack = caster:GetModifierStackCount("modifier_shieldbash", caster)
        value = value + 0.1 * shieldbashstack
    end
    local talentfurytitan = caster:FindAbilityByName("fury6")
    if talentfurytitan and talentfurytitan:GetLevel() >= 4 then
        value = value + 0.15
    end
    if caster:HasModifier("modifier_mythic_abil") then
        value = value + caster:GetModifierStackCount("modifier_mythic_abil", nil)/100
    end
    if event.moonburn and caster:HasModifier("modifier_moonburn_cd") then
        value = value + 1
    end
    local disctalent = caster:FindAbilityByName("Soul_Burn")
    if disctalent and disctalent:GetLevel() >= 3 then
        value = value + 0.1
    end
    if event.feralleapbonus and caster:HasModifier("modifier_asbonus") then
        value = value + 0.5
    end
    if caster:HasModifier("modifier_item_night_shoulders") and caster:GetAbilityByIndex(4) == ability then
        value = value + 2
    end
    if caster:HasModifier("modifier_arcaneweak") and event.arcanedmg and event.netherblast then
        local stacks = caster:GetModifierStackCount("modifier_arcaneweak", nil)
        if caster:GetMana() >= 0.4*15*stacks then
            value = value + 0.3*stacks
            if process_procs then
                caster:SetMana(caster:GetMana() - 0.4*15*stacks)
            end
        end
    end
    if event.mutilate then
        value = value + (event.mutilate*target:GetModifierStackCount("modifier_deadlypoison", nil)/100)
    end

    return value
end
]]

function HasClassItem( caster, level )
    local buffname = "modifier_"..caster:GetUnitName()
    if level > 1 then
        buffname = buffname..tostring(level)
    end
    if caster:HasModifier(buffname) then
        return true
    end
    --[[
    if buffname == "modifier_npc_dota_hero_furion" and caster:GetUnitName() == "npc_dota_hero_enchantress" then
        return true
    end
    --if buffname == "modifier_npc_dota_hero_furion" and caster:GetUnitName() == "npc_dota_hero_abaddon" then
    --    return true
    --end
    if buffname == "modifier_npc_dota_hero_windrunner" and caster:GetUnitName() == "npc_dota_hero_clinkz" then
        return true
    end
    if buffname == "modifier_npc_dota_hero_sniper" and caster:GetUnitName() == "npc_dota_hero_clinkz" then
        return true
    end
    if buffname == "npc_dota_hero_drow_ranger" and caster:GetUnitName() == "npc_dota_hero_clinkz" then
        return true
    end
    if buffname == "modifier_npc_dota_hero_furion" and caster:GetUnitName() == "npc_dota_hero_enchantress" then
        return true
    end
    if buffname == "modifier_npc_dota_hero_furion" and caster:GetUnitName() == "npc_dota_hero_enchantress" then
        return true
    end
    if buffname == "modifier_npc_dota_hero_furion" and caster:GetUnitName() == "npc_dota_hero_enchantress" then
        return true
    end
    if buffname == "modifier_npc_dota_hero_furion" and caster:GetUnitName() == "npc_dota_hero_enchantress" then
        return true
    end
    if buffname == "modifier_npc_dota_hero_furion" and caster:GetUnitName() == "npc_dota_hero_enchantress" then
        return true
    end]]
    return false
end

function CountElementalDamageTypes(event)
    local amount = 0
    if event.shadowdmg then
        amount = amount + 1
    end
    if event.arcanedmg then
        amount = amount + 1
    end
    if event.naturedmg then
        amount = amount + 1
    end
    if event.firedmg then
        amount = amount + 1
    end
    if event.holydmg then
        amount = amount + 1
    end
    if event.chaosdmg then
        amount = amount + 1
    end
    if event.frostdmg then
        amount = amount + 1
    end
    return amount
end

function GetAbilityDamageModifierMultiplicative( event, caster, real_caster, target, ability, behindtarget, is_very_big_hit, is_500_big_hit, isaoe, process_procs, wascrit, was_consecutive_crit, pure_dmg, is_pet_dmg)
    local multiplicative_bonus = 1
    if event.firestone then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.fromcompanion and caster:HasModifier("modifier_bloodbrother") and GetCompanionCount(caster) == 1 then
        multiplicative_bonus = multiplicative_bonus * 3.5
    end
    if caster:HasModifier("modifier_class_demo") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * GetDemonCount(caster))
    end
    if caster:HasModifier("modifier_mage_1") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    local hp_percent = -1
    if target then
        hp_percent = target:GetHealth() / target:GetMaxHealth()
    end
    if process_procs and caster.talents and ability then
        local endBossItem = caster:HasModifier("modifier_endboss")
        if target and target.real_boss and endBossItem then
            multiplicative_bonus = multiplicative_bonus * 1.75
            if not caster.endBossUsed then
                caster.endBossUsed = true
            end
        end
        if caster.endBossUsed and not endBossItem then
            multiplicative_bonus = multiplicative_bonus * 0.25
        end
        if caster.songIceFire1Cast and caster.talents and caster:GetAbilityByIndex(1) == ability and caster.talents[129] > 0 then
            if math.random(1,100) <= caster.talents[129] * 33.4 then
                local bonusFactor = 2
                if caster:HasModifier("modifier_pathbuff_129") then
                    bonusFactor = 3.5
                end
                event.firedmg = 1
                multiplicative_bonus = multiplicative_bonus * bonusFactor
            end
            caster.songIceFire1Cast = false
        elseif caster.songIceFire2Cast and caster.talents and caster:GetAbilityByIndex(0) == ability and caster.talents[129] > 0 then
            if math.random(1,100) <= caster.talents[129] * 33.4 then
                local bonusFactor = 2
                if caster:HasModifier("modifier_pathbuff_129") then
                    bonusFactor = 3.5
                end
                event.frostdmg = 1
                multiplicative_bonus = multiplicative_bonus * bonusFactor
            end
            caster.songIceFire2Cast = false
        end
    end
    if process_procs and caster:HasModifier("modifier_summoner") then
        if is_pet_dmg then
            multiplicative_bonus = multiplicative_bonus * 2
        else
            multiplicative_bonus = multiplicative_bonus * 0.5
        end
    end
    
    if event.firedmg and hp_percent < 0.5 and GetAfterburnStat(caster) >= 1 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * GetAfterburnStat(caster))
    end
    if event.bookofdead and HeroHasNeutralItem(caster, "item_neutral_26") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster.swordStormCrits and caster:HasModifier("modifier_axestorm") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.swordStormCrits)
    end
    if wascrit and event.isdot and HeroHasNeutralItem(caster, "item_neutral_28") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.isdot and caster.plagueFormBonus then
        multiplicative_bonus = multiplicative_bonus * (1 + caster.plagueFormBonus)
    end
    if event.fatalThrowBonus then
        multiplicative_bonus = multiplicative_bonus * 3
        if not wascrit and caster.fatalThrowBonus then
            caster.fatalThrowBonus = caster.fatalThrowBonus - 1
        end
    end
    if caster:HasModifier("modifier_equilibrium") then
        multiplicative_bonus = multiplicative_bonus * 1.45
    end
    if caster:HasModifier("modifier_bm2") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_talent_genesis") and caster.talents[135] > 0 then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    local ab_on_cooldown = GetAbilitiesOnCooldown(caster)
    if ab_on_cooldown > 0 and caster.talents and caster.talents[41] and caster.talents[41] > 0 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.02 * ab_on_cooldown * caster.talents[41])
    end
    --heal to abi
    if process_procs and event.chaosdmg and GetTowerOfChaosStat(caster) >= 1 then
        caster.tower_of_chaos_reduction = GetTowerOfChaosStat(caster) * 0.01
    end
    if event.naturedmg and GetNaturesHarmonyStat(caster) >= 1 and not wascrit then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * GetNaturesHarmonyStat(caster))
    end
    if GetCrusaderStat(caster) >= 1 then
        multiplicative_bonus = multiplicative_bonus * (1 + (GetHealingMultiplier(event, caster, ability, target, false, false, false) - 1) * 0.01 * GetCrusaderStat(caster))
    end
    if GetNetherfusionStat(caster) >= 1 and ability and ability:GetManaCost(ability:GetLevel()) >= 30 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * GetNetherfusionStat(caster))
    end
    if pure_dmg and wascrit and event.arcanedmg and GetStarCollapseStat(caster) >= 1 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * GetStarCollapseStat(caster))
    end
    if GetTwinStormStat(caster) >= 1 and CountElementalDamageTypes(event) == 2 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * GetTwinStormStat(caster))
    end
    if HeroHasNeutralItem(caster, "item_neutral_5") and CountElementalDamageTypes(event) == 3 then
        multiplicative_bonus = multiplicative_bonus * 1.75
    end
    if HeroHasNeutralItem(caster, "item_neutral_22") and caster.pvelives and caster.pvelives == 1 then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    local wog = caster:GetModifierStackCount("modifier_wog", nil)
    if wog >= 1 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * wog)
    end
    local tot = caster:GetModifierStackCount("modifier_tot", nil)
    if tot >= 1 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * tot)
    end
    local fortressOfPain = GetFortressOfPainStat(caster)
    if fortressOfPain >= 1 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * fortressOfPain * (1 - GetTotalDamageTakenFactor(caster)))
    end
    --spellcast frenzy
    if ability == caster:GetAbilityByIndex(2) and ((not event.spellcastfrenzy) or (event.spellcastfrenzy and event.spellcastfrenzy == 0)) and caster:HasModifier("modifier_pathbuff_044") then
        event.spellcastfrenzy = 0.05
        event.spellcastfrenzy_max = 0.5
    end
    if ability == caster:GetAbilityByIndex(0) and ((not event.spellcastfrenzy) or (event.spellcastfrenzy and event.spellcastfrenzy == 0)) and caster:HasModifier("modifier_pathbuff_002") then
        event.spellcastfrenzy = 0.03
        event.spellcastfrenzy_max = 0.6
    end
    if ability == caster:GetAbilityByIndex(1) and ((not event.spellcastfrenzy) or (event.spellcastfrenzy and event.spellcastfrenzy == 0)) and caster:HasModifier("modifier_pathbuff_100") then
        event.spellcastfrenzy = 0.01
        event.spellcastfrenzy_max = 0.75
    end
    if caster:HasModifier("modifier_taunt123") and GetLevelOfAbility(caster, "mars6") >= 4 then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_manacost_reduction") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_critmass") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * caster.talents[122])
    end
    if caster:HasModifier("modifier_savagery") then
        local bonus = 0.05 + 0.15 * caster.talents[131]
        if is_pet_dmg then
            bonus = bonus * 2
        end
        multiplicative_bonus = multiplicative_bonus * (1 + bonus)
    end
    if GetLevelOfAbility(caster, "special_bonus_unique_nether_wizard_3") >= 1 then
        multiplicative_bonus = multiplicative_bonus * 1.05
    end
    if caster:HasModifier("modifier_mop2") then
        multiplicative_bonus = multiplicative_bonus * 1.05
    end
    if caster:HasModifier("modifier_symbiosos_fur") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if ability and caster:HasModifier("modifier_new8") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.005 * ability:GetManaCost(ability:GetLevel()))
    end
    if ability and caster:HasModifier("modifier_new82") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * ability:GetManaCost(ability:GetLevel()))
    end
    if caster:HasModifier("modifier_windfury_path") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * caster.talents[53])
    end
    if process_procs and GetFirstBloodStat(caster) >= 1 then
        if not target.first_strike then
            target.first_strike = {}
        end
        local playerid = caster:GetPlayerID()
        if playerid then
            if not target.first_strike[playerid] then
                target.first_strike[playerid] = true
                multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * GetFirstBloodStat(caster))
            end
        end
    end
    if event.frostdmg and process_procs and GetFrostbiteStat(caster) >= 1 and target and math.random(1,100) <= 25 then
        if not target.frostbite then
            target.frostbite = {}
        end
        local playerid = caster:GetPlayerID()
        if playerid then
            if not target.frostbite[playerid] then
                target.frostbite[playerid] = true
                ApplyBuff({ caster = caster, target = target, dur = 2.5, buff = "modifier_deepfreeze", ability = caster.combat_system_ability})
                multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * GetFrostbiteStat(caster))
            end
        end
    end
    if caster:HasModifier("modifier_new7") and ability then
        local abilityIndex = ability:GetAbilityIndex()
        if abilityIndex >= 1 and caster:GetAbilityByIndex(abilityIndex - 1) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster:GetAbilityByIndex(abilityIndex - 1):GetLevel())
        end
    end
    if caster:HasModifier("modifier_new72") and ability then
        local abilityIndex = ability:GetAbilityIndex()
        if abilityIndex >= 1 and caster:GetAbilityByIndex(abilityIndex - 1) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.2 * caster:GetAbilityByIndex(abilityIndex - 1):GetLevel())
        end
    end
    if event.shadowimp then
        local shadowimps = caster:GetModifierStackCount("modifier_shadow_imp", nil)
        multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * shadowimps)
    end
    local iceshatter = caster:GetModifierStackCount("modifier_ice_shatter", nil)
    if iceshatter >= 1 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * iceshatter)
    end
    if caster:HasModifier("modifier_holymagicres") then
        multiplicative_bonus = multiplicative_bonus * 1.1
    end
    if caster:HasModifier("modifier_sacred_shield") then
        multiplicative_bonus = multiplicative_bonus * 1.1
    end
    if caster:HasModifier("modifier_demon_form2") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if event.felflames and caster:HasModifier("modifier_class_am") and (caster:HasModifier("modifier_blurblend") or caster:HasModifier("modifier_aoeantimagic_dh_buff")) then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.rainofarrows and caster:HasModifier("modifier_item_hunterbow2") and target:HasModifier("modifier_piercearmorsnake") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if caster:HasModifier("modifier_frostmourne_dmg") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if caster:HasModifier("modifier_sanctum_dmg") then
        multiplicative_bonus = multiplicative_bonus * 1.1
    end
    if caster:HasModifier("modifier_pathbuff_113") and ability:GetLevel() >= 4 then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if ability == caster:GetAbilityByIndex(5) and caster:HasModifier("modifier_tamerbond") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if isaoe and caster:HasModifier("modifier_blood_shield") and caster:HasModifier("modifier_npc_dota_hero_skeleton_king") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if isaoe and caster:HasModifier("modifier_npc_dota_hero_drow2") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.45 * caster:GetModifierStackCount("modifier_ranger_as_bonus", nil))
    end
    
    if caster:HasModifier("modifier_unholyaura") then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end
    if isaoe and GetLevelOfAbility(caster, "mars4") >= 3 and caster:GetPhysicalArmorValue(false) > 0 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * caster:GetPhysicalArmorValue(false))
    end
    if isaoe and caster:HasModifier("modifier_stormcrow") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if isaoe and caster:HasModifier("modifier_soullink") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if isaoe and caster.talents and caster.talents[84] and caster.talents[84] > 0 and caster:HasModifier("modifier_dominance") then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[84])
    end
    if event.isdot then
        local brawler3 = caster:FindAbilityByName("Concussive_Blow")
        if brawler3 and brawler3:GetLevel() >= 4 and caster:GetIncreasedAttackSpeed(false) > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * caster:GetIncreasedAttackSpeed(false))
        end
    end
    if caster.consecutive_crits and caster.consecutive_crits >= 2 then --we had 2 previous crits, this is the 3rd crit
        if event.frostdmg and caster:HasModifier("modifier_frostcrit") then
            multiplicative_bonus = multiplicative_bonus * 2
            local particle = ParticleManager:CreateParticle("particles/econ/items/lich/frozen_chains_ti6/lich_frozenchains_frostnova.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 3, Vector(50, 50, 50))
            ParticleManager:ReleaseParticleIndex(particle)
        elseif event.frostdmg and caster:HasModifier("modifier_frostcrit2") then
            multiplicative_bonus = multiplicative_bonus * 3
            local particle = ParticleManager:CreateParticle("particles/econ/items/lich/frozen_chains_ti6/lich_frozenchains_frostnova.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 3, Vector(50, 50, 50))
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
    if event.shadowdmg and GetHighestAbilityScaling(event) <= 200 and caster:HasModifier("modifier_dark2") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_talent_enrage") and caster:HasModifier("modifier_pathbuff_047") and GetHighestAbilityScaling(event) <= 150 then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if event.shadowdmg and GetHighestAbilityScaling(event) <= 200 and caster:HasModifier("modifier_dark") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if event.iceflame_bolt then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if process_procs and event.firedmg and not event.naturedmg and caster:HasModifier("modifier_firenature2") then
        caster.firenature2_bonus_fire = true
    end
    if process_procs and event.naturedmg and not event.firedmg and caster:HasModifier("modifier_firenature2") then
        caster.firenature2_bonus_nature = true
    end
    if process_procs and event.firedmg and caster.firenature2_bonus_nature then
        multiplicative_bonus = multiplicative_bonus * 3
        caster.firenature2_bonus_nature = false
        local particle = ParticleManager:CreateParticle("particles/econ/items/doom/doom_ti8_immortal_arms/doom_ti8_immortal_devour_burst_b.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        
    end
    if process_procs and event.naturedmg and caster.firenature2_bonus_fire then
        multiplicative_bonus = multiplicative_bonus * 3
        caster.firenature2_bonus_fire = false
        local particle = ParticleManager:CreateParticle("particles/econ/items/underlord/underlord_ti8_immortal_weapon/underlord_ti8_immortal_pitofmalice_stun_light_b.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    --if process_procs then
        --print("ele dmg " .. ability:GetName())
        --print(event.naturedmg)
        --print(process_procs)
    --end
    if process_procs and event.firedmg and not event.naturedmg and caster:HasModifier("modifier_firenature") then
        caster.firenature_bonus_fire = true
        --print("bonus11!")
    end

    if process_procs and event.naturedmg and not event.firedmg and caster:HasModifier("modifier_firenature") then
        caster.firenature_bonus_nature = true
        --print("bonus22!")
    end
    if process_procs and event.firedmg and caster.firenature_bonus_nature then
        multiplicative_bonus = multiplicative_bonus * 2
        caster.firenature_bonus_nature = false
        local particle = ParticleManager:CreateParticle("particles/econ/items/doom/doom_ti8_immortal_arms/doom_ti8_immortal_devour_burst_b.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        --print("bonus1!")
    end
    if process_procs and event.naturedmg and caster.firenature_bonus_fire then
        multiplicative_bonus = multiplicative_bonus * 2
        caster.firenature_bonus_fire = false
        local particle = ParticleManager:CreateParticle("particles/econ/items/underlord/underlord_ti8_immortal_weapon/underlord_ti8_immortal_pitofmalice_stun_light_b.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        --print("bonus2!")
    end
    if caster:HasModifier("modifier_dispelovertime") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if is_500_big_hit and HeroHasNeutralItem(caster, "item_neutral_29") and not wascrit then
        multiplicative_bonus = multiplicative_bonus * 3.5
    end
    if wascrit and (not is_500_big_hit) and event.arcanedmg and caster:HasModifier("modifier_arcanabracers") then
        multiplicative_bonus = multiplicative_bonus * 1.5
        local particle = ParticleManager:CreateParticle("particles/econ/items/vengeful/vs_ti8_immortal_shoulder/vs_ti8_immortal_magic_missle_end_streaks_b.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if wascrit and (not is_500_big_hit) and event.arcanedmg and caster:HasModifier("modifier_arcanabracers2") then
        multiplicative_bonus = multiplicative_bonus * 2
        local particle = ParticleManager:CreateParticle("particles/econ/items/vengeful/vs_ti8_immortal_shoulder/vs_ti8_immortal_magic_missle_end_streaks_b.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if was_consecutive_crit and (caster:HasModifier("modifier_critmaster") or caster:HasModifier("modifier_critmaster2")) then
        local bonusfactor = 1.5
        if caster:HasModifier("modifier_critmaster2") then
            bonusfactor = 2
        end
        multiplicative_bonus = multiplicative_bonus * bonusfactor
        local particle = ParticleManager:CreateParticle("particles/econ/items/queen_of_pain/qop_ti8_immortal/queen_ti8_shadow_strike_body.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
        ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if ability == caster:GetAbilityByIndex(1) and caster:HasModifier("modifier_npc_dota_hero_riki") and caster:HasModifier("modifier_shadowstep1") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if caster:HasModifier("modifier_dh_soulpact") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    --if caster:HasModifier("modifier_pathbuff_043") and target and target:HasModifier("modifier_dot") and (target:HasModifier("modifier_piercearmor_m_0") or target:HasModifier("modifier_piercearmor_m_1") or target:HasModifier("modifier_piercearmor_m_2") or target:HasModifier("modifier_piercearmor_m_3") or target:HasModifier("modifier_piercearmor_m_4"))  then
    --    multiplicative_bonus = multiplicative_bonus * 1.5
    --end
    if caster:IsRealHero() then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.00015 * GetIntellectCustom(caster)) -0.0001
    end
    if caster.astral_ability_200 and process_procs then
        caster.astral_ability_200 = nil
        multiplicative_bonus = multiplicative_bonus * 3
    end
    if isaoe and caster:HasModifier("modifier_item_shadowmourne_active") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if isaoe and caster:HasModifier("modifier_item_myth_sp") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_windfury_path") and caster:HasModifier("modifier_windbreaker") and caster:HasModifier("modifier_pathbuff_083") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if event.starfallbonus and caster:HasModifier("modifier_pathbuff_068") and caster.path_dark_ritual and caster.path_dark_ritual > 0 then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    --if event.icestorm and caster:HasModifier("modifier_pathbuff_072") then
    --    multiplicative_bonus = multiplicative_bonus * 1.5
    --end
    if event.spellcastfrenzy and event.spellcastfrenzy > 0 and caster.spellcast_tracking and target then
        local dmg_bonus = event.spellcastfrenzy
        local abilityname = ability:GetName()
        local found_ability = false
        for k, v in pairs( caster.spellcast_tracking ) do
            if k == abilityname then
                found_ability = true
                if v and v[1] and v[1] == target and v[2] then
                    --same target, increase bonus
                    multiplicative_bonus = multiplicative_bonus * (1 + v[2])
                    v[2] = v[2] + event.spellcastfrenzy
                    if caster:HasModifier("modifier_pathbuff_015") and event.spellcastfrenzy_max then
                        event.spellcastfrenzy_max = event.spellcastfrenzy_max * 1.5
                    end
                    if event.spellcastfrenzy_max and v[2] > event.spellcastfrenzy_max then
                        v[2] = event.spellcastfrenzy_max
                    end 
                else
                    --new target
                    v = {target, dmg_bonus}
                    caster.spellcast_tracking[abilityname] = {target, dmg_bonus}
                end
            end
        end
        if not found_ability then
            caster.spellcast_tracking[abilityname] = {target, dmg_bonus}
        end
    end
    if hp_percent > 0.75 and caster:HasModifier("modifier_pathbuff_070") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if wascrit and pure_dmg and caster:HasModifier("modifier_pathbuff_052") then
        multiplicative_bonus = multiplicative_bonus * 1.75
    end
    if wascrit and pure_dmg and caster:HasModifier("modifier_purecrit") and ability:GetCooldown(ability:GetLevel()) <= 6 and process_procs then
        multiplicative_bonus = multiplicative_bonus * 1.75
        local particle = ParticleManager:CreateParticle("particles/econ/items/vengeful/vs_ti8_immortal_shoulder/vs_ti8_immortal_magic_missle_end_embers.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if wascrit and pure_dmg and caster:HasModifier("modifier_purecrit2") and ability:GetCooldown(ability:GetLevel()) <= 6 and process_procs then
        multiplicative_bonus = multiplicative_bonus * 2.25
        local particle = ParticleManager:CreateParticle("particles/econ/items/vengeful/vs_ti8_immortal_shoulder/vs_ti8_immortal_magic_missle_end_embers.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if pure_dmg and caster:HasModifier("modifier_pathbuff_004") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if caster:IsRealHero() then
        if caster.temple_class then
            multiplicative_bonus = multiplicative_bonus * 0.5
        end
        --if not caster.temple_class then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.006 * caster:GetLevel())
        --else
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.005 * caster:GetLevel())
        --end
    end
    if (event.netherchaos or event.netherchaos_low) and caster:HasModifier("modifier_item_netherchaos") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if is_very_big_hit and (caster:HasModifier("modifier_item_bighit") or caster:HasModifier("modifier_item_bighit_2")) then
        multiplicative_bonus = multiplicative_bonus * 1.5
        --[[if process_procs then
            if not caster.very_big_hit_cd then
                local particle = ParticleManager:CreateParticle("particles/necro_ti7_immortal_scythe_start_only_ghost.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
                ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
                ParticleManager:ReleaseParticleIndex(particle)
                caster.very_big_hit_cd = true
                Timers:CreateTimer(2.0, function()
                    caster.very_big_hit_cd = nil
                end)
            end
        end]]
    end
    if caster:HasModifier("modifier_pathbuff_032") and ability == caster:GetAbilityByIndex(0) then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end
    if caster:HasModifier("modifier_special_bonus_day_vision") then
        multiplicative_bonus = multiplicative_bonus * 1.05
    end
    if hp_percent > 0.5 and caster:HasModifier("modifier_pathbuff_021") then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end
    if caster:HasModifier("modifier_myth_str_abil") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if caster:HasModifier("modifier_item_myth_str") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if caster:HasModifier("modifier_item_myth_agi") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if caster:HasModifier("modifier_item_myth_int") then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end
    if event.warlockdot2 and caster:HasModifier("modifier_class_warlock") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.isdot then
        local warlocktalent = caster:FindAbilityByName("Agony")
        if warlocktalent and warlocktalent:GetLevel() >= 4 and target:HasModifier("modifier_dot1") and target:HasModifier("modifier_dot2") and target:HasModifier("modifier_dot4") then
            multiplicative_bonus = multiplicative_bonus * 2
        end
    end
    if pure_dmg then
        local drow_pure_bonus = caster:FindAbilityByName("Mindfreezing_Shot")
        if drow_pure_bonus and drow_pure_bonus:GetLevel() >= 3 then
            multiplicative_bonus = multiplicative_bonus * 1.25
        end
    end
    if caster:HasModifier("modifier_wl_shield") then
        local fear_ability = caster:FindAbilityByName("Fear_Warlock")
        if fear_ability and fear_ability:GetLevel() >= 4 and ability and ability:GetName() == "dark_ranger_life_drain" then
            multiplicative_bonus = multiplicative_bonus * 2
        end
    end
    if event.isdot and caster:HasModifier("modifier_item_rogueblades2") and caster:HasModifier("modifier_furycat") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if event.isdot and event.naturedmg and caster:HasModifier("modifier_naturedot") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.isdot and event.naturedmg and caster:HasModifier("modifier_naturedot2") then
        multiplicative_bonus = multiplicative_bonus * 3
    end
    if event.isdot and caster:HasModifier("modifier_axestorm_dot") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.shadowdmg and not isaoe then
        local demo5 = caster:FindAbilityByName("demo5")
        if demo5 and demo5:GetLevel() >= 3 then
            multiplicative_bonus = multiplicative_bonus * 1.5
        end
    end
    if not event.was_stars_aligned_first_crit and caster:HasModifier("modifier_crit_moon_cd") and caster:HasModifier("modifier_moonlighttiger") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if caster:HasModifier("modifier_fanatism_2") and caster:HasModifier("modifier_class_sanctified") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if caster:HasModifier("modifier_divine_sprint") and caster:HasModifier("modifier_class_deadly") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if (event.viperpoison or event.serpentpoison) and caster:HasModifier("modifier_npc_dota_hero_windrunner") then
        multiplicative_bonus = multiplicative_bonus * 4
    end
    if event.classitemdmgfactor and caster:HasModifier(event.classitemdmgfactorbuff) then
        multiplicative_bonus = multiplicative_bonus * event.classitemdmgfactor
    end
    if caster.channel_item_bonus then
        if caster:HasModifier("modifier_item_channel_2") then
            multiplicative_bonus = multiplicative_bonus * 1.75
        else
            multiplicative_bonus = multiplicative_bonus * 1.4
        end
    end
    if caster.ability_combo_6_bonus and (caster:HasModifier("modifier_item_titanarmor") or caster:HasModifier("modifier_item_titanarmor_2")) then
        if caster:HasModifier("modifier_item_titanarmor_2") then
            multiplicative_bonus = multiplicative_bonus * 2.25
        else
            multiplicative_bonus = multiplicative_bonus * 1.6
        end
    end
    if caster:HasModifier("modifier_element_chaos") and isaoe then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if caster:HasModifier("modifier_pathbuff_085") and isaoe then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if ability:GetCooldown(ability:GetLevel()) <= 0.5 and caster:HasModifier("modifier_item_myth_aa") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if caster:HasModifier("modifier_talent_enrage") and caster.talents and caster.talents[47] and caster.talents[47] > 0 then
        local ancient = 0.15 * caster.talents[47]
        if caster:HasModifier("modifier_item_sp4") then
            ancient = ancient + 0.3
        end
        --if caster:HasModifier("modifier_item_ancient_wolf") then
         --   ancient = ancient + 0.3
       --end
        multiplicative_bonus = multiplicative_bonus * ( 1 + ancient )
    end
    if event.fireconsecbonus and event.fireconsecbonus > 0 and target and target:HasModifier("modifier_magmaburn") then
        multiplicative_bonus = multiplicative_bonus * (1 + event.fireconsecbonus/100)
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_techies/techies_remote_mine_detonate_embers.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if caster.lifeblood then
    	local true_blood_bonus = 1
    	if (caster.aa_crit_counter_last_10_secs and caster.aa_crit_counter_last_10_secs > 0) or (caster.true_blood_from_stun and caster.true_blood_from_stun > 0) then
    		true_blood_bonus = 2
    	end
        multiplicative_bonus = multiplicative_bonus * ((caster.lifeblood - 1) * true_blood_bonus + 1)
    end
    if caster:HasModifier("modifier_pathbuff_058") then
        local percent_hp = caster:GetHealth() / caster:GetMaxHealth()
        multiplicative_bonus = multiplicative_bonus * (1 + 1 - percent_hp)
    end
    if caster:HasModifier("modifier_axe_dmg_titan") and caster:GetAbilityByIndex(4) and caster:GetAbilityByIndex(4) == ability then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if caster:HasModifier("modifier_axe_dmg_titan2") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    local dhchaostalent = caster:FindAbilityByName("dh4")
    if dhchaostalent and dhchaostalent:GetLevel() >= 3 and event.chaosstrike and caster:HasModifier("modifier_aoeantimagic_dh_buff") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if caster.tiger_fury_next_abi_bonus and process_procs then
        multiplicative_bonus = multiplicative_bonus * caster.tiger_fury_next_abi_bonus
        caster.tiger_fury_next_abi_bonus = nil
    end
    if caster.talents then
        --if isaoe and caster.talents[104] and caster.talents[104] > 0 and caster:HasModifier("modifier_deathchill") then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * caster.talents[104])
        --end
        if caster.spearspeed then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.03 * math.min(75, caster.spearspeed))
        end
        if process_procs and caster.talents[130] > 0 and ability and ability:GetCooldown(ability:GetLevel()) <= 5 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.2 * caster.talents[130])
            local newLife = caster:GetHealth() - caster:GetMaxHealth() * 0.01
            if newLife < 2 then
                newLife = 2
            end
            caster:SetHealth(newLife)
        end
        if process_procs and caster.ambushTalent and caster.ambushTalent > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.3 * caster.talents[159])
            caster.ambushTalent = caster.ambushTalent - 1
        end
        if caster.talents[155] > 0 then
            local highestAbility = GetHighestCooldownAbility(caster)
            if highestAbility and highestAbility:GetCooldown(highestAbility:GetLevel() - 1) > 0 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * caster.talents[155])
            end
        end
        if caster.talents[156] > 0 then
            if GetTotalDamageTakenFactor(caster) <= 0.5 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[156])
            end
        end
        if caster.talents[140] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[140] * CountMutationEffects(caster))
        end
        if caster.talents[127] > 0 then
            if process_procs and CountElementalDamageTypes(event) >= 2 then
                ApplyBuff({ caster = caster, target = caster, dur = 5, buff = "modifier_dfe", ability = caster.combat_system_ability})
            end
            if caster:HasModifier("modifier_dfe") then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[127])
            end
        end
        if caster.talents[46] and caster.talents[46] > 0 and caster:HasModifier("modifier_bloodwolf_buff") then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[46])
        end
        if caster.talents[143] > 0 and GiantsOnCooldown(caster) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[143])
        end
        if process_procs and caster.talents[125] > 0 then
            multiplicative_bonus = multiplicative_bonus * GetButterflyDamageFactor(caster, ability)
        end
        if caster.talents[126] > 0 then
            local bonusPerElement = 0.05 * caster.talents[126]
            if isaoe then
                bonusPerElement = bonusPerElement * 2
            end
            if wascrit then
                bonusPerElement = bonusPerElement * 2
            end
            if pure_dmg then
                bonusPerElement = bonusPerElement * 2
            end
            multiplicative_bonus = multiplicative_bonus * (1 + bonusPerElement * CountElementalDamageTypes(event))
        end
        if caster.talents[100] and caster.talents[100] > 0 and caster:HasModifier("modifier_chaosknight_combo") and caster:GetAbilityByIndex(1) and caster:GetAbilityByIndex(1) == ability then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.2 * caster.talents[100])
        end
        if caster.talents[113] and caster.talents[113] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.002 * caster.talents[113] * GetTotalAbilityCooldowns(caster))
        end
        if caster.talents[110] and caster.talents[110] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[110])
        end
        if caster.talents[107] and caster.talents[107] > 0 and caster:HasModifier("modifier_lonedruid") then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.07 * caster.talents[107])
        end
        if caster.talents[108] and caster.talents[108] > 0 and not isaoe then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.07 * caster.talents[108])
        end
        if caster.talents[7] and caster.talents[7] > 0 and not isaoe then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * caster.talents[7])
        end
        if caster.talents[91] and caster.talents[91] > 0 and caster:IsMoving() then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[91])
        end
        if caster.talents[148] and caster.talents[148] > 0 then
            if process_procs and caster:GetPrimaryAttribute() == 1 and ability == caster:GetAbilityByIndex(1) then
                ApplyBuffStack({ caster = caster, target = caster, buff = "modifier_wma", ability = caster.combat_system_ability, max = 50, dur = 5})
            end
            if process_procs and caster:GetPrimaryAttribute() == 2 and event.isdot then
                ApplyBuffStack({ caster = caster, target = caster, buff = "modifier_wmi", ability = caster.combat_system_ability, max = 50, dur = 3})
            end
            local wma = caster:GetModifierStackCount("modifier_wma", nil)
            local wmi = caster:GetModifierStackCount("modifier_wmi", nil)
            local wms = caster:GetModifierStackCount("modifier_wms", nil)
            multiplicative_bonus = multiplicative_bonus * (1 + wms * 0.025 * caster.talents[148] + wma * 0.005 * caster.talents[148] + wmi * 0.005 * caster.talents[148])
        end
        if process_procs and caster.talents[99] and caster.talents[99] > 0 then
            local chaosFactor = 1
            if event.chaosdmg then
                chaosFactor = 2
            end
            if not caster.resourcesystem then --mana
                if caster:GetMana() / caster:GetMaxMana() > 0.5 then
                    multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * chaosFactor * caster.talents[99])
                    caster:SetMana(caster:GetMana() - caster:GetMaxMana() * 0.03)
                    ReignOfChaosFX(caster, target)
                end
            else --energy
                local maxEnergy = GetMaxEnergy({caster = caster})
                if caster:GetMana() / maxEnergy > 0.5 then
                    multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * chaosFactor * caster.talents[99])
                    EnergyCost({caster = caster, cost = maxEnergy * 0.03, pay = true})
                    ReignOfChaosFX(caster, target)
                end
            end
        end
        if caster.talents[4] and caster.talents[4] > 0 and isaoe then
            local bonus_per_armor = 0.0033
            local bonus_factor = 1 + bonus_per_armor * caster.talents[4] * caster:GetPhysicalArmorValue(false)
            --if caster:GetPrimaryAttribute() == 1 then
            --    bonus_per_armor = 0.0016
            --end
            local cap = 2
            --if caster:HasModifier("modifier_pathbuff_051") then
            --    cap = 2.25
            --end
            if bonus_factor > cap then
                bonus_factor = cap
            end
            multiplicative_bonus = multiplicative_bonus * bonus_factor
        end
        if caster.talents[51] and caster.talents[51] > 0 and caster:Script_GetMagicalArmorValue(false, nil) >= 0.7 and caster:GetPhysicalArmorValue(false) >= 46 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[51])
        end
        if caster.talents and caster.talents[111] and caster.talents[111] > 0 then
            local talent111_buff = caster:GetModifierStackCount("modifier_overgrowth", nil)
            local dmgPerStack = 0.02
            if caster:HasModifier("modifier_pathbuff_111") and caster:HasModifier("modifier_path_overwhelm") then
                dmgPerStack = dmgPerStack * 1.5
            end
            multiplicative_bonus = multiplicative_bonus * (1 + dmgPerStack * talent111_buff)
        end
        if caster.talents and caster.talents[7] and caster.talents[7] > 0 then
            local talent7_buff = caster:GetModifierStackCount("modifier_talent_maul", nil)
            local dmgPerMaul = 0.005
            multiplicative_bonus = multiplicative_bonus * (1 + dmgPerMaul * talent7_buff)
        end
        if caster.talents[9] and caster.talents[9] > 0 then
            local factor = (1 + 0.001 * caster.talents[9] * caster:GetPhysicalArmorValue(false))
            local max = 1 + 0.25 * caster.talents[9]
            --if caster:HasModifier("modifier_pathbuff_051") then
            --    max = 1 + (max - 1) * 1.25
            --end
            if factor > max then
                factor = max
            end
            multiplicative_bonus = multiplicative_bonus * factor
        end
        if caster.talents[11] and caster.talents[11] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.03 * caster.talents[11])
        end
        if caster.talents[28] and caster.talents[28] > 0 and ability and ability:GetCooldown(ability:GetLevel()) >= 20 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * caster.talents[28])
        end
        if event.isdot and caster.talents[49] and caster.talents[49] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * caster.talents[49])
        end
        if event.isdot and isaoe and caster.talents[96] and caster.talents[96] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * caster.talents[96])
        end
        --if event.isdot and caster.talents[36] and caster.talents[36] > 0 then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[36])
        --end
        if caster.talents[154] and caster.talents[154] > 0 and caster:HasModifier("modifier_trickster") then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[154])
        end
        if caster.talents[72] and caster.talents[72] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[72])
        end
        if caster.talents[64] and caster.talents[64] > 0 and caster:GetAbilityByIndex(3) == ability then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[64])
        end
        if event.warlockdot and caster:IsMoving() and caster:HasModifier("modifier_npc_dota_hero_wl2") then
            local bonusfromms = caster:GetMoveSpeedModifier(caster:GetBaseMoveSpeed(), true) - 300
            if bonusfromms > 0 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * bonusfromms)
            end
        end
        if caster.talents[60] and caster.talents[60] > 0 then
            local bonusfromms = caster:GetMoveSpeedModifier(caster:GetBaseMoveSpeed(), true) - 300
            bonusfromms = bonusfromms * 0.0005 * caster.talents[60]
            if bonusfromms > 0.5 then
                bonusfromms = 0.5
            end
            if bonusfromms > 0 then
                multiplicative_bonus = multiplicative_bonus * (1 + bonusfromms)
            end
        end
        --if caster.talents[57] and caster.talents[57] > 0 and caster:HasModifier("modifier_talent57_dmg") then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[57])
        --end
        if caster.talents and caster.talents[74] and caster.talents[74] > 0 and caster.path_sacrifice_souls_paid then
        	local bonus_first_3 = 1
        	if caster.path_sacrifice_souls_paid >= 2 and target then
        		caster.path_sacrifice_souls_paid = caster.path_sacrifice_souls_paid - 1
        		bonus_first_3 = 2
        		local particle = ParticleManager:CreateParticle("particles/econ/items/shadow_demon/sd_ti7_shadow_poison/sd_ti7_shadow_poison_kill.vpcf", PATTACH_ABSORIGIN, target)
				ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + Vector(0,0,50))
				ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin() + Vector(0,0,50))
			    ParticleManager:ReleaseParticleIndex(particle)
        	end
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[74] * bonus_first_3)
            if ability:GetCooldown(ability:GetLevel()) >= 10 and caster:HasModifier("modifier_pathbuff_074") then
                multiplicative_bonus = multiplicative_bonus * 1.25
            end
        end
        if caster.standsstill and caster.talents[20] then
            local standsstill = caster.standsstill
            if standsstill > 5 then
                standsstill = 5
            end
            multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * caster.talents[20] * standsstill)
        end
        local glass_cannon = caster:GetModifierStackCount("modifier_talent_glass_cannon", nil)
        if glass_cannon > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * glass_cannon)
        end
        if event.bloodwolf and caster.talents[32] then --channel bonus
             multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[32])
        end
        if event.bloodwolf and caster.talents[157] then --channel bonus
             multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[157])
        end
        local keeper1_stacks = caster:GetModifierStackCount("modifier_keeper_spellhaste", nil)
        if event.bloodwolf and keeper1_stacks > 0 then --channel bonus
             multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * keeper1_stacks)
        end
        if behindtarget and caster.talents[44] then
             multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[44])
        end
        if caster.talents[35] and caster.talents[35] > 0 and target then
            if (caster:GetAbsOrigin() - target:GetAbsOrigin()):Length() > 500 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[35])
            end
        end
        if caster.talents[86] and caster.talents[86] > 0 and target then
            local point_of_damaging_unit = caster:GetAbsOrigin()
            if event.fromsummon or event.fromcompanion then --summons and companions cause master dmg, need to adjust position to summon position
                if event.attacker then
                    point_of_damaging_unit = event.attacker:GetAbsOrigin()
                end
            end
            local distance = (point_of_damaging_unit - target:GetAbsOrigin()):Length()
            if distance > 600 then
                local max_distance_cap = 1200
                if caster:HasModifier("modifier_pathbuff_052") then
                    max_distance_cap = 1350
                end
                if distance > max_distance_cap then
                    distance = max_distance_cap
                end
                distance = (distance - 600) / 100
                multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * caster.talents[86] * distance)
            end
        end
        --if caster.talents[24] and caster.talents[24] > 0 then
        --     multiplicative_bonus = multiplicative_bonus * (1 + 0.25 * caster.talents[24])
        --end
        if caster.talents[52] and caster.talents[52] > 0 then
            local tiger_stacks = caster:GetModifierStackCount("modifier_talent_tiger_prowl", nil)
            multiplicative_bonus = multiplicative_bonus * (1 + 0.03 * caster.talents[52] * tiger_stacks)
        end
        --[[
        if caster.talents[36] and caster.talents[36] > 0 then
            if caster.path_dragon_fire and caster.path_dragon_fire > 0 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * caster.talents[36])
            end
            --[[
            if event.firedmg then
                caster.talent_next_non_fire_bonus = 0.1 * caster.talents[36]
                caster.talent_next_non_fire_counter = 5
            end
            if not event.firedmg and caster.talent_next_non_fire_bonus and caster.talent_next_non_fire_bonus > 0 and caster.talent_next_non_fire_counter and caster.talent_next_non_fire_counter > 0 then
                multiplicative_bonus = multiplicative_bonus * (1 + caster.talent_next_non_fire_bonus)
                caster.talent_next_non_fire_counter = caster.talent_next_non_fire_counter - 1
            end
        end]]
        --if caster.talents[48] and caster.talents[48] > 0 and target and (target:GetPhysicalArmorValue(false) < 15 or target:GetMagicalArmorValue() < 45 or target:GetHealth() / target:GetMaxHealth() < 0.3) then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[48])
        --end
        --if caster.talents[50] and caster.talents[50] > 0 and not isaoe then
        --     multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * caster.talents[50])
        --end
        if process_procs and caster.talents[12] and caster.talents[12] > 0 and ability and (ability:GetCooldown(ability:GetLevel()) <= 5 or (ability:GetCooldown(ability:GetLevel()) <= 10 and caster:HasModifier("modifier_pathbuff_001"))) then
            local factor = 0.1
            if not caster:IsRangedAttacker() then
                factor = 0.2
            end
            if isaoe and caster:HasModifier("modifier_pathbuff_054") then
                factor = factor * 1.5
            end
            multiplicative_bonus = multiplicative_bonus * (1 + factor * caster.talents[12])
        end
        if caster.talents[67] and caster.talents[67] > 0 and isaoe then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.07 * caster.talents[67])
        end
        --if caster.talents[36] and caster.talents[36] > 0 and isaoe then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[36])
        --end
        if caster.talents[66] and caster.talents[66] > 0 and (ability == caster:GetAbilityByIndex(1) or (ability == caster:GetAbilityByIndex(3) and caster:HasModifier("modifier_pathbuff_038"))) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[66])
            if (event.shadowdmg or math.random(1,100) <= 25) and caster.combat_system_ability and process_procs then
                AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 300 + 100 * caster.talents[66], aacrit_chance = 100})
            end
        end
        if caster.talents[6] and caster.talents[6] > 0 and ability == caster:GetAbilityByIndex(2) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[6])
        end
        if caster.talents[8] and caster.talents[8] > 0 and (ability == caster:GetAbilityByIndex(4) or is_very_big_hit) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[8])
        end
        if caster.talents[68] and caster.talents[68] > 0 then
            if caster.path_dark_ritual and caster.path_dark_ritual > 0 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[68])
            end
            if ability:GetAbilityIndex() == 5 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.2 * caster.talents[68])
            end
        end
        if caster.talents[70] and caster:HasModifier("modifier_path_from_shadows") then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.05 + 0.15 * caster.talents[70])
            if caster.fromTheShadows and process_procs then
                multiplicative_bonus = multiplicative_bonus * caster.fromTheShadows
                caster.fromTheShadows = 1
            end
        end
        if caster.talents[77] and not wascrit and process_procs then
            local extrafactor = 0.15
            if event.fromsummon or event.ComesFromPet or event.bloodwolf then
                extrafactor = 0.225
            end
            multiplicative_bonus = multiplicative_bonus * (1 + extrafactor * caster.talents[77])
        end
        if caster.talents[81] and caster:HasModifier("modifier_skyfall") then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster.talents[81])
        end
        local stack = caster:GetModifierStackCount("modifier_stormclaws", caster)
        if (not event.fromcompanion) and stack >= 5 and caster.talents[78] and process_procs then
            caster:RemoveModifierByName("modifier_stormclaws")
            multiplicative_bonus = multiplicative_bonus * (1 + 0.15 * caster.talents[78])
        end

        local stacksSwordBoard = caster:GetModifierStackCount("modifier_swordboard", caster)
        if stacksSwordBoard > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * stacksSwordBoard)
        end
        stacksSwordBoard = caster:GetModifierStackCount("modifier_berserkerrage", caster)
        if stacksSwordBoard > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * stacksSwordBoard)
        end

        if caster.nearby_enemies and caster.nearby_enemies > 0 and caster.talents[85] and caster.talents[85] > 0 then
            local enemy_count = caster.nearby_enemies
            local enemy_cap = 8
            if not caster:IsRangedAttacker() then
                enemy_cap = 12
            end
            if enemy_count > enemy_cap then
                enemy_count = enemy_cap
            end
            multiplicative_bonus = multiplicative_bonus * (1 + 0.02 * caster.talents[85] * enemy_count)
        end
        local crowfall = caster:GetModifierStackCount("modifier_crowfall", nil)
        if crowfall > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.02 * crowfall)
        end
    end
    local fire_dot_talent = caster:FindAbilityByName("Molten_Lava")
    if fire_dot_talent and fire_dot_talent:GetLevel() >= 4 then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if isaoe then
        fire_dot_talent = caster:FindAbilityByName("terror5")
        if fire_dot_talent and fire_dot_talent:GetLevel() >= 4 then
            multiplicative_bonus = multiplicative_bonus * 1.5
        end
    end
    if event.isdot and caster:HasModifier("modifier_item_ancient_dot") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if event.isdot and caster:HasModifier("modifier_item_nature") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if caster:HasModifier("modifier_fireball_bonus") then
        if event.isfireball then
            multiplicative_bonus = multiplicative_bonus * 1.5
        elseif ability and (ability:GetName() == "Molten_Lava" or ability:GetName() == "Dragon_Claw") then
            multiplicative_bonus = multiplicative_bonus * 2
        end
    end
    if event.t3bonus and caster:HasModifier("modifier_item_set_agi_t3_full") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if event.t3bonus and caster:HasModifier("modifier_item_set_str_t3_full") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if event.ancientlongbow and caster:HasModifier("modifier_item_hunterbow") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if event.ancientlongbow and caster:HasModifier("modifier_item_hunterbow2") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_item_silverblood2_active") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if event.bloodwolf and caster:HasModifier("modifier_item_shadowstrike") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if caster:HasModifier("modifier_elemental_lust2") then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end
    if caster.elemental_item3 and caster:HasModifier("modifier_item_elements3") then
        local bonusdmg = 1
        if caster:HasModifier("modifier_dmgitem_fire") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_arcane") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_shadow") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_nature") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_holy") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_frost") then
            bonusdmg = bonusdmg + 0.15
        end
        if caster:HasModifier("modifier_dmgitem_chaos") then
            bonusdmg = bonusdmg + 0.15
        end
        multiplicative_bonus = multiplicative_bonus * bonusdmg
    end
    if caster:HasModifier("modifier_activepaladin") then
        multiplicative_bonus = multiplicative_bonus * 1.1
    end
    if caster:HasModifier("modifier_activepaladin_2") then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end
    if event.untamed and caster:HasModifier("modifier_item_straxe3") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_item_int_set_t3_active") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if caster:HasModifier("modifier_item_night_shoulders") and caster:GetAbilityByIndex(4) == ability then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_item_longbow") and ability == caster:GetAbilityByIndex(2) then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    if caster:HasModifier("modifier_item_ancient_grizzly") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if caster:HasModifier("modifier_active9") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    --if event.thunderstacks then
    --    multiplicative_bonus = multiplicative_bonus * (1 + 0.1 *caster:GetModifierStackCount("modifier_ele_thunder_stacks", nil))
    --end
    if not (event.fromsummon or event.ComesFromPet) then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.01 *caster:GetModifierStackCount("modifier_beastitem", nil))
    end
    if caster:HasModifier("modifier_tigerfury") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if event.feralleapbonus and caster:HasModifier("modifier_asbonus") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.moonburn and caster:HasModifier("modifier_moonburn_cd") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if event.consumesuncharge and caster.starfallDamage then
        multiplicative_bonus = multiplicative_bonus * caster.starfallDamage
    end
    local dk_blood_stacks = caster:GetModifierStackCount("modifier_strikeofvengeance2", nil)
    if dk_blood_stacks > 0 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * dk_blood_stacks)
    end
    local pala_retal_stacks = caster:GetModifierStackCount("modifier_strikeofvengeance3", nil)
    if pala_retal_stacks > 0 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * pala_retal_stacks)
    end
    if event.immolatebonus ~= nil and target then
        if target:HasModifier("modifier_magmaburn2") then
            multiplicative_bonus = multiplicative_bonus * (1 + event.immolatebonus/100.0)
        end 
    end
    if event.ancientlongbow and caster:HasModifier("modifier_itemhastebow") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if event.ambushblade and caster:HasModifier("modifier_item_armoriron2") then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end
    --reworked until here

    if caster:HasModifier("modifier_dmgbonus_cruel") then
        multiplicative_bonus = multiplicative_bonus * 1.35
    end
    
    --rune words
    if caster.runeword then
        if caster.runeword[19] then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * caster.runeword[19])
        end
        --if caster.runeword[24] and ability and ability == caster:GetAbilityByIndex(2) then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * caster.runeword[24])
        --end
        if caster.runeword[25] and ability and ability == caster:GetAbilityByIndex(3) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * caster.runeword[25])
        end
        --if caster.runeword[26] and ability and ability == caster:GetAbilityByIndex(4) then
        --    multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * caster.runeword[26])
        --end
        if caster.runeword[27] and ability and ability == caster:GetAbilityByIndex(1) then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.01 * caster.runeword[27])
        end
        if event.runewordscale and event.runewordscale == 10 and caster.runeword[event.runewordscale] and caster.runeword[event.runewordscale] > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + caster.runeword[event.runewordscale] / 100)
        end
    end

    
    local snowrangerbonus = caster:GetModifierStackCount("modifier_ranger_as_bonus", nil)
    if snowrangerbonus > 0 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * snowrangerbonus)
    end
    local distance = -1
    if target then
        distance = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
    end
    if event.rangeddoubledamage and event.rangeddoubledamage > 0 and distance > event.rangeddoubledamage then
        multiplicative_bonus = multiplicative_bonus * 2
        if process_procs and target then
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_abaddon/abaddon_death_coil_explosion_e.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
    local bearroartalent = caster:FindAbilityByName("bear6")
    if bearroartalent and bearroartalent:GetLevel() >= 3 and caster:HasModifier("modifier_bear_roar_armor") then
        multiplicative_bonus = multiplicative_bonus * 1.5
    end
    local fury_as_abil = caster:FindAbilityByName("fury2")
    if fury_as_abil and fury_as_abil:GetLevel() >= 4 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * caster:GetIncreasedAttackSpeed(false))
    end
    local dk_resi_dmg = caster:FindAbilityByName("Rot")
    if dk_resi_dmg and dk_resi_dmg:GetLevel() >= 4 then
        multiplicative_bonus = multiplicative_bonus * (1 + 1.5 * caster:Script_GetMagicalArmorValue(false, nil))
    end
    if caster:HasModifier("item_mother_of_dragons") then
        multiplicative_bonus = multiplicative_bonus * 1.15
    end

    local arcane_barrage_stacks = caster:GetModifierStackCount("modifier_arcane_barrage_bonus", nil)
    if event.isarcanebarrage and arcane_barrage_stacks > 0 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * arcane_barrage_stacks)
    end
    if caster:HasModifier("modifier_npc_dota_hero_invo2") then
        if arcane_barrage_stacks >= 3 then
            local manaregpersec = GetManaRegenerationPerSec(caster)
            if manaregpersec > 0 then
                multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * manaregpersec)
            end
        end
    end
    if event.starfallbonus and caster:HasModifier("modifier_item_dmg4") then
        multiplicative_bonus = multiplicative_bonus * 2
    end
    if caster:HasModifier("modifier_shadowstep1") then
        multiplicative_bonus = multiplicative_bonus * 1.3
    end
    if event.souldrain then
        local blackGrimoireStacks = target:GetModifierStackCount("modifier_black_grimoire", nil)
        if blackGrimoireStacks > 0 then
            multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * blackGrimoireStacks)
        end
    end
    local abil_dmg_stacks_5 = caster:GetModifierStackCount("modifier_abil_bonus_5_percent", nil)
    if abil_dmg_stacks_5 > 0 then
        multiplicative_bonus = multiplicative_bonus * (1 + 0.05 * abil_dmg_stacks_5)
    end
    if event.chaosstrike and caster:HasModifier("modifier_metamorph_dh") then
        multiplicative_bonus = multiplicative_bonus * 1.25
    end
    if event.championprot and caster:HasModifier("modifier_item_straxe2") then
        local shieldbashstack = caster:GetModifierStackCount("modifier_shieldbash", caster)
        multiplicative_bonus = multiplicative_bonus * (1 + 0.1 * shieldbashstack)
    end
    if caster:HasModifier("modifier_mythic_abil") then
        multiplicative_bonus = multiplicative_bonus * (1 + caster:GetModifierStackCount("modifier_mythic_abil", nil)/100)
    end
    if caster:HasModifier("modifier_mythic_aoe") and isaoe then
        multiplicative_bonus = multiplicative_bonus * (1 + caster:GetModifierStackCount("modifier_mythic_aoe", nil)/100)
    end
    if caster:HasModifier("modifier_mythic_dot") and event.isdot then
        multiplicative_bonus = multiplicative_bonus * (1 + caster:GetModifierStackCount("modifier_mythic_dot", nil)/100)
    end
    if caster:HasModifier("modifier_mythic_single") and not isaoe then
        multiplicative_bonus = multiplicative_bonus * (1 + caster:GetModifierStackCount("modifier_mythic_single", nil)/100)
    end

    --[[
    if caster:HasModifier("modifier_arcaneweak") and event.arcanedmg and event.netherblast then
        local stacks = caster:GetModifierStackCount("modifier_arcaneweak", nil)
        if caster:GetMana() >= 0.4*15*stacks then
            value = value + 0.3*stacks
            if process_procs then
                caster:SetMana(caster:GetMana() - 0.4*15*stacks)
            end
        end
    end
    ]]
    return multiplicative_bonus
end
--3333333

function LockReloadProc(event)
	local caster = event.caster
	event.max = 25
	event.buff = "modifier_lockreload"
	--event.ability = caster:FindAbilityByName("wind2")
	event.target = caster
	ApplyBuffStack(event)
end

function CriticalStrikeFX(casterarg, targetarg, amountarg, dmgorheal, crit) --dmgorheal: 0 = heal, 1 = dmg, 2 = dmg pure, 3 = dps
	--print("call")
	local target = targetarg
	local caster = casterarg
	local amount = amountarg
	local particle = nil
	local particlepath = nil
    if target and target:IsNull() then
        return
    end
	local pos = target:GetAbsOrigin()+Vector(math.random(0,50),math.random(-25,25),75)
	if dmgorheal == 1 or dmgorheal == 2 then
		particlepath = "particles/criticalstrike.vpcf"
		if dmgorheal == 1 then
			--physical fx
			--particle = ParticleManager:CreateParticle("particles/econ/items/phantom_assassin/phantom_assassin_arcana_elder_smith/phantom_assassin_crit_impact_dagger_arcana.vpcf", PATTACH_POINT_FOLLOW, target)
	    	--ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
			--ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
			--ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())
			local event2 = {}
			event2.caster = caster
			event2.target = target
			BloodArcana(event2)
		else
			--magic fx
            if false and not COverthrowGameMode.crit_effect_cooldown then
                particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5/am_manaburn_basher_ti_5_b.vpcf", PATTACH_POINT_FOLLOW, target)
                ParticleManager:ReleaseParticleIndex(particle)
                particle = ParticleManager:CreateParticle("particles/units/heroes/hero_templar_assassin/templar_assassin_trap_explode_points.vpcf", PATTACH_POINT_FOLLOW, target)
                ParticleManager:ReleaseParticleIndex(particle)
                particle = ParticleManager:CreateParticle("particles/units/heroes/hero_invoker/invoker_emp_lightning_thick_child.vpcf", PATTACH_POINT_FOLLOW, target)
                local tar = target:GetAbsOrigin()
                ParticleManager:SetParticleControl(particle, 0, tar)
                tar = tar + Vector(0,0,200)
                ParticleManager:SetParticleControl(particle, 1, tar)
                ParticleManager:ReleaseParticleIndex(particle)
                COverthrowGameMode.crit_effect_cooldown = true
                Timers:CreateTimer(3,function()
                    COverthrowGameMode.crit_effect_cooldown = nil
                end)
            end
		end
	else
		particlepath = "particles/criticalheal.vpcf"
		pos = target:GetAbsOrigin()+Vector(math.random(0,50),math.random(-175,-125),75)
	end
    --dps position different
    if dmgorheal == 3 then
        particlepath = "particles/criticalstrike.vpcf"
        pos = target:GetAbsOrigin() + Vector(-100,0,0)
    end
	
	--calc digits
    local test9 = math.floor((amount%1000000000)/100000000)
    local test8 = math.floor((amount%100000000)/10000000)
    local test7 = math.floor((amount%10000000)/1000000)
    local test6 = math.floor((amount%1000000)/100000)
    local test5 = math.floor((amount%100000)/10000)
    local test4 = math.floor((amount%10000)/1000)
	local test3 = math.floor((amount%1000)/100)
	local test2 = math.floor((amount%100)/10)
	local test1 = math.floor(amount%10)

    --healing numbers
    --1st
    particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
    ParticleManager:SetParticleControl(particle, 0, pos)
	ParticleManager:SetParticleControl(particle, 1, Vector(0,test1,0))
    ParticleManager:ReleaseParticleIndex(particle)
	--2nd
    if test2 >= 1.0 or test7 >= 1.0 or test6 >= 1.0 or test5 >= 1.0 or test4 >= 1.0 or test3 >= 1.0 or test8 >= 1.0 or test9 >= 1.0 then
    	particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
	    pos = pos+Vector(-16,0,0)
	    ParticleManager:SetParticleControl(particle, 0, pos)
		ParticleManager:SetParticleControl(particle, 1, Vector(0,test2,0))
        ParticleManager:ReleaseParticleIndex(particle)
	end
	if test3 >= 1.0 or test5 >= 1.0 or test4 >= 1.0 or test7 >= 1.0 or test6 >= 1.0 or test8 >= 1.0 or test9 >= 1.0 then
    	particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
	    pos = pos+Vector(-16,0,0)
	    ParticleManager:SetParticleControl(particle, 0, pos)
		ParticleManager:SetParticleControl(particle, 1, Vector(0,test3,0))
        ParticleManager:ReleaseParticleIndex(particle)
	end
    if test4 >= 1.0 or test5 >= 1.0 or test7 >= 1.0 or test6 >= 1.0 or test8 >= 1.0 or test9 >= 1.0 then
        particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
        pos = pos+Vector(-16,0,0)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, Vector(0,test4,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if test5 >= 1.0 or test7 >= 1.0 or test6 >= 1.0 or test8 >= 1.0 or test9 >= 1.0 then
        particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
        pos = pos+Vector(-16,0,0)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, Vector(0,test5,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if test7 >= 1.0 or test6 >= 1.0 or test8 >= 1.0 or test9 >= 1.0 then
        particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
        pos = pos+Vector(-16,0,0)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, Vector(0,test6,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if test7 >= 1.0 or test8 >= 1.0 or test9 >= 1.0 then
        particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
        pos = pos+Vector(-16,0,0)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, Vector(0,test7,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if test8 >= 1.0 or test9 >= 1.0 then
        particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
        pos = pos+Vector(-16,0,0)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, Vector(0,test8,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if test9 >= 1.0 then
        particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
        pos = pos+Vector(-16,0,0)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, Vector(0,test9,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end

	--blitz icon
	if crit == 1 then
		pos = pos+Vector(-20,0,0)
		particle = ParticleManager:CreateParticle(particlepath, PATTACH_ABSORIGIN, target)
		ParticleManager:SetParticleControl(particle, 0, pos)
		ParticleManager:SetParticleControl(particle, 1, Vector(0,14,0))
        ParticleManager:ReleaseParticleIndex(particle)
	end
end

function DamageAOEDelayed( event )
	Timers:CreateTimer(event.delay,function() 
		DamageAOE(event)
	end)
end

function DamageUnitDelayed(event)
	Timers:CreateTimer(event.delay,function() 
		DamageUnit(event)
	end)
end

function DamageAOESplitHero( event )
    if event.caster == nil then
        return
    end
    local caster2 = event.caster
    local target2 = event.target
    if target2 == nil then
        target2 = event.unit
    end
    local ability2 = event.ability
    local range = event.aoe
    local pos = caster2:GetOrigin()
    if event.targetpos then
        pos = target2:GetOrigin()
    end
    if event.target_points ~= nil then
        pos = event.target_points[1]
    end
    if event.zeus ~= nil then
        pos = target2:GetOrigin()
        --print("zeus target detected")
    end

    local enemies = FindUnitsInRadius( caster2:GetTeamNumber(), pos, caster2, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
    
    local targets = 0
    local guy
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy ~= nil and ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()==pet) or (enemy:GetUnitLabel()=="tower"))  then
                targets = targets + 1
                guy = enemy
            end
        end
    end
    if targets > 0 then
        if event.stunsingle and targets == 1 then
            local myevent = {}
            myevent.caster = caster2
            myevent.target = guy
            myevent.buff = "modifier_stunned"
            myevent.ability = event.ability
            myevent.dur = 0.5
            ApplyBuff(myevent)
        end
        event.includeauto = event.includeauto / targets
        DamageAOE(event)
    end
end

function PathFeastForCrowsAOE( caster )
	Timers:CreateTimer(0.5,function()
		EmitSoundOn("DOTA_Item.Mjollnir.Activate", caster)
	    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, 900, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	    if #enemies > 0 then
	        for _,enemy in pairs(enemies) do
	            if enemy and not enemy:IsNull() and (enemy:GetUnitLabel() == "hero" or enemy:GetUnitLabel() == "tower" ) and math.random(1,100) <= 50 then
	            	PathFeastForCrowsShadowStorm( caster, enemy )
	            end
	        end
	    end
	end)
end

function PathFeastForCrowsShadowStorm( caster, target )
	local particle = ParticleManager:CreateParticle("particles/econ/items/riki/riki_immortal_ti6/riki_immortal_ti6_blinkstrike.vpcf", PATTACH_ABSORIGIN, caster)
	ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin() + Vector(0,0,50))
	ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,50))
	ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin() + Vector(0,0,50))
	ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin() + Vector(0,0,50))
    ParticleManager:ReleaseParticleIndex(particle)
	local event = {}
	event.caster = caster
	event.target = target
	event.includeauto = caster.talents[85] * 100
	event.spelldamagefactor = caster.talents[85] * 100
	event.shadowdmg = 1
	event.puredmg = 1
	event.ability = caster.combat_system_ability
	event.ignore_when_target_has_reflect = true
	DamageUnit(event)
end

function AstralShock( caster )
	Timers:CreateTimer(0.25,function()
		EmitSoundOn("DOTA_Item.Mjollnir.Activate", caster)
	    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, 900, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	    if #enemies > 0 then
	        for _,enemy in pairs(enemies) do
	            if enemy and not enemy:IsNull() and (enemy:GetUnitLabel() == "hero" or enemy:GetUnitLabel() == "tower" ) then
	            	AstralShockProc( caster, enemy )
	            end
	        end
	    end
	end)
end

function AstralShockProc( caster, target )
	local particle = ParticleManager:CreateParticle("particles/econ/items/riki/riki_immortal_ti6/riki_immortal_ti6_blinkstrike.vpcf", PATTACH_ABSORIGIN, caster)
	ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin() + Vector(0,0,50))
	ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,50))
	ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin() + Vector(0,0,50))
	ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin() + Vector(0,0,50))
    ParticleManager:ReleaseParticleIndex(particle)
	local event = {}
	event.caster = caster
	event.target = target
	event.attributefactor = 0
	event.spelldamagefactor = 500
	event.arcanedmg = 1
    event.isaoe = 1
	event.ability = caster.combat_system_ability
	event.ignore_when_target_has_reflect = true
    event.changedmgtypetomagical = 1
	DamageUnit(event)
end

function CountNearbyEnemies(caster, range)
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    local targets_hit = 0
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy and not enemy:IsNull() and (enemy:GetUnitLabel() == "hero" or enemy:GetUnitLabel() == "tower" )  then
                targets_hit = targets_hit + 1
            end
        end
    end
    return targets_hit
end

function CountNearbyMonsters(monster, range)
    local enemies = FindUnitsInRadius( monster:GetTeamNumber(), monster:GetAbsOrigin(), monster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    local monsters = 0
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy and not enemy:IsNull() and (enemy:GetUnitLabel() == "hero" or enemy:GetUnitLabel() == "tower" )  then
                monsters = monsters + 1
            end
        end
    end
    return monsters
end

function DamageAOE( event )
	if event.caster == nil then
		return
	end
	local caster2 = event.caster
	local target2 = event.target
	if target2 == nil then
		target2 = event.unit
	end
    if not caster2 then
        return
    end
    if caster2 and caster2:IsNull() then
        return
    end
    if target2 and target2:IsNull() then
        return
    end
	local ability2 = event.ability
	local range = event.aoe
	local pos = caster2:GetOrigin()
	if event.targetpos then
		pos = target2:GetOrigin()
	end
	if event.target_points ~= nil then
		pos = event.target_points[1]
	end
	if event.zeus ~= nil then
		pos = target2:GetOrigin()
		--print("zeus target detected")
	end
    local targets_hit = 0
    local max_targets = 1000
    if event.max_targets then
        max_targets = event.max_targets
    end
    if event.buffcondition and not caster2:HasModifier(event.buffcondition) then
        return
    end

	local event2 = {
		caster = caster2,
		target = target2,
		ability = ability2,
		damage = event.damage,
		spelldamagefactor = event.spelldamagefactor,
		attributefactor = event.attributefactor,
        attributechangestr = event.attributechangestr,
        counterblow = event.counterblow,
		pvescale = event.pvescale,
		critdmgbonusfactor = event.critdmgbonusfactor,
		critchancefactor = event.critchancefactor,
		includeauto = event.includeauto,
        includefullauto = event.includefullauto,
		critmanareg = event.critmanareg,
		championcleaver = event.championcleaver,
        difficultyscale = event.difficultyscale,
        difficultyscalelinear = event.difficultyscalelinear,
        t3bonus = event.t3bonus,
        isdot = event.isdot,
        isaoe = event.isaoe,
        changedmgtypetophys = event.changedmgtypetophys,
        classitemdmgfactor = event.classitemdmgfactor,
        classitemdmgfactorbuff = event.classitemdmgfactorbuff,
        swordstorm = event.swordstorm
	}
    if event.rainofarrows then
        event2.rainofarrows = 1
    end
	if event.naturedmg then
		event2.naturedmg = 1
	end
	if event.firedmg then
		event2.firedmg = 1
	end
	if event.shadowdmg then
		event2.shadowdmg = 1
	end
	if event.arcanedmg then
		event2.arcanedmg = 1
	end
	if event.frostdmg then
		event2.frostdmg = 1
	end
	if event.holydmg then
		event2.holydmg = 1
	end
    if event.holy4heal then
        event2.holy4heal = 1
    end
    if event.oncritcdreduce3rd then
        event2.oncritcdreduce3rd = event.oncritcdreduce3rd
    end
    if event.oncritcdreduce4th then
        event2.oncritcdreduce4th = event.oncritcdreduce4th
    end

	local agha = caster2:HasModifier("modifier_item_straxe2") or caster2:HasModifier("modifier_item_straxe3")

	if event.arrowsound then
		EmitSoundOn("Hero_LegionCommander.Overwhelming.Hero", caster2)
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_legion_commander/legion_commander_odds_hero_arrow_group.vpcf", PATTACH_ABSORIGIN, caster2)
		ParticleManager:SetParticleControl(particle, 0, pos+Vector(-125,0,0))
		ParticleManager:SetParticleControl(particle, 1, pos)
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticle("particles/units/heroes/hero_legion_commander/legion_commander_odds_hero_arrow_group.vpcf", PATTACH_ABSORIGIN, caster2)
		ParticleManager:SetParticleControl(particle, 0, pos+Vector(125,0,0))
		ParticleManager:SetParticleControl(particle, 1, pos)
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticle("particles/units/heroes/hero_legion_commander/legion_commander_odds_hero_arrow_group.vpcf", PATTACH_ABSORIGIN, caster2)
		ParticleManager:SetParticleControl(particle, 0, pos+Vector(0,125,0))
		ParticleManager:SetParticleControl(particle, 1, pos)
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticle("particles/units/heroes/hero_legion_commander/legion_commander_odds_hero_arrow_group.vpcf", PATTACH_ABSORIGIN, caster2)
		ParticleManager:SetParticleControl(particle, 0, pos+Vector(0,-125,0))
		ParticleManager:SetParticleControl(particle, 1, pos)
        ParticleManager:ReleaseParticleIndex(particle)
	end

	local enemies
	local pet = "pet"
	if event.onlyhero then
		--enemies = FindUnitsInRadius( caster2:GetTeamNumber(), pos, caster2, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
		pet = "hero"
	end
	enemies = FindUnitsInRadius( caster2:GetTeamNumber(), pos, caster2, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )

	local crusaderheal = 0
    --count targets
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy and not enemy:IsNull() and (enemy:GetUnitLabel() == "hero" or enemy:GetUnitLabel() == pet or enemy:GetUnitLabel() == "tower" )  then
                if targets_hit < max_targets and ((not CheckForBreakableCC(enemy)) or event.breakcc) then
                    targets_hit = targets_hit + 1
                end
            end
        end
    end
    if event.damage_divided and targets_hit > 0 then
        event2.damage_scale = 1 / targets_hit
    end
    targets_hit = 0
    if event.damage_factor_single_target and #enemies == 1 then
        event2.damage_factor_single_target = event.damage_factor_single_target
    end
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy and not enemy:IsNull() and (enemy:GetUnitLabel() == "hero" or enemy:GetUnitLabel() == pet or enemy:GetUnitLabel() == "tower" ) and ((not event.dontdamagereflect) or not HasDamageReflect(enemy)) then
				if targets_hit < max_targets and ((not CheckForBreakableCC(enemy)) or event.breakcc) then
					event2.target = enemy
					DamageUnit( event2 )
                    targets_hit = targets_hit + 1
                    if event.targeteffect then
    					if event.targeteffect == "blood" then
    						local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_beastmaster/beastmaster_wildaxes_hit.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
                            ParticleManager:ReleaseParticleIndex(particle)
    					end
                        if event.targeteffect == "arcanablood" then
                            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_beastmaster/beastmaster_wildaxes_hit.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
                            ParticleManager:ReleaseParticleIndex(particle)
                            local particle = ParticleManager:CreateParticle("particles/econ/items/troll_warlord/troll_warlord_ti7_axe/troll_ti7_axe_bash_explosion.vpcf", PATTACH_POINT_FOLLOW, enemy)
                            ParticleManager:SetParticleControl(particle, 3, caster2:GetAbsOrigin())
                            ParticleManager:ReleaseParticleIndex(particle)
                            BloodArcana({caster = caster2, target = enemy, ignore_crit_effect_cooldown = true })
                        end
    					if event.targeteffect == "thunder" then
    						local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_disruptor/disruptor_thunder_strike_aoe.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
                            ParticleManager:ReleaseParticleIndex(particle)
    					end
    					if event.targeteffect == "fire" then
    						local particle = ParticleManager:CreateParticle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze_lava.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
    						ParticleManager:SetParticleControl(particle, 0, enemy:GetAbsOrigin()+Vector(0,0,15))
                            ParticleManager:ReleaseParticleIndex(particle)
    					end
    					if event.targeteffect == "water" then
    						local particle = ParticleManager:CreateParticle("particles/econ/items/kunkka/divine_anchor/hero_kunkka_dafx_skills/kunkka_spell_x_spot_return_fxset.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
                            ParticleManager:ReleaseParticleIndex(particle)
    					end
    					if event.targeteffect == "holy" then
    						local particle = ParticleManager:CreateParticle("particles/econ/items/legion/legion_weapon_voth_domosh/legion_commander_duel_dmg_flare.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
    						ParticleManager:SetParticleControl(particle, 3, enemy:GetAbsOrigin()+Vector(0,0,0))
                            ParticleManager:ReleaseParticleIndex(particle)
    					end
                    end
					if event.healpertarget ~= nil then
						crusaderheal = crusaderheal + event.healpertarget
					end
					if event.stun then
						--local tab = {}
						--tab.Duration = event.stun
						event.target = enemy
						event.dur = event.stun
						StunTarget(event)
						--event.ability:ApplyDataDrivenModifier(caster2, enemy, "modifier_stunned", tab)
					end
					if event.championslowproc and agha then
						local myevent = {}
			    		myevent.caster = caster2
			    		myevent.target = enemy
			    		myevent.buff = "modifier_slow25"
						myevent.ability = event.ability
						myevent.dur = 2
						ApplyBuff(myevent)
						--event.ability:ApplyDataDrivenModifier(caster2, enemy, "modifier_slow25", nil)
					end

					if event.arrowsound then
						--local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_legion_commander/legion_commander_odds_hero_arrow_start_pos.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
						
						--ParticleManager:SetParticleControl(particle, 1, enemy:GetAbsOrigin())
						local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_invoker/invoker_forged_spirit_projectile_explosion.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
						ParticleManager:SetParticleControl(particle, 3, enemy:GetAbsOrigin()+Vector(0,0,75))
                        ParticleManager:ReleaseParticleIndex(particle)
                        local myevent = {}
                        myevent.caster = caster2
                        myevent.energy = event.energy
                        AddEnergy(myevent)
					end
				end
			end
		end
	end
	if crusaderheal > 0 then
		event.target = caster2
		event.heal = caster2:GetMaxHealth()*crusaderheal/100
		event.attributefactor = 0.0
		event.spelldamagefactor = 0.0
		if event.retrisound ~= nil then
			EmitSoundOn("Hero_LegionCommander.Attack", event.caster)
		end
		if event.warlockfx ~= nil then
			local particle = ParticleManager:CreateParticle("particles/econ/events/ti5/blink_dagger_start_smoke_ti5.vpcf", PATTACH_POINT_FOLLOW, caster2)
            ParticleManager:ReleaseParticleIndex(particle)
		end
		HealUnit(event)
	end
end

function ApplyBuffAOE( event )
	if event.caster == nil or event.target == nil then
		return
	end
    local targetsHit = 0
    local maxTargets = 1000000
    if event.maxAOEBuffTargets then
        maxTargets = event.maxAOEBuffTargets
    end
	local caster = event.caster
	local target = event.target
	if target == nil then
		target = event.unit
	end
	local ability = event.ability
	local range = event.aoe
	local pos = caster:GetOrigin()
	if event.targetpos then
		pos = target:GetOrigin()
	end
	if event.target_points ~= nil then
		pos = event.target_points[1]
	end
	local pet = "pet"
	if event.onlyhero then
		local pet = "hero"
	end
	local team = DOTA_UNIT_TARGET_TEAM_ENEMY
	if event.friend then
		team = DOTA_UNIT_TARGET_TEAM_FRIENDLY
	end

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, range, team, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )

	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil and ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()==pet) or (enemy:GetUnitLabel()=="tower")) and targetsHit < maxTargets then
				local myevent = {}
	    		myevent.caster = caster
	    		myevent.target = enemy
	    		myevent.buff = event.buff
				myevent.ability = event.ability
				myevent.dur = event.dur
                myevent.is_already_aoe_buff = true
				if not event.dontbreakccbuff or ( event.dontbreakccbuff and not CheckForBreakableCC(enemy) ) then
					ApplyBuff(myevent)
                    targetsHit = targetsHit + 1
				end
			end
		end
	end
end

function ApplyBuffAOERandom( event )
    if event.caster == nil or event.target == nil then
        return
    end
    local caster = event.caster
    local target = event.target
    if target == nil then
        target = event.unit
    end
    local ability = event.ability
    local range = event.aoe
    local pos = caster:GetOrigin()
    if event.targetpos then
        pos = target:GetOrigin()
    end
    if event.target_points ~= nil then
        pos = event.target_points[1]
    end
    local pet = "pet"
    if event.onlyhero then
        local pet = "hero"
    end
    local team = DOTA_UNIT_TARGET_TEAM_ENEMY
    if event.friend then
        team = DOTA_UNIT_TARGET_TEAM_FRIENDLY
    end
    local excludetarget = nil
    if event.excludetarget then
        excludetarget = target
    end

    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, range, team, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    local result = {}
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy ~= nil and ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()==pet) or (enemy:GetUnitLabel()=="tower")) and enemy ~= excludetarget then
                if not event.dontbreakccbuff or ( event.dontbreakccbuff and not CheckForBreakableCC(enemy) ) then
                    table.insert( result, enemy )
                end
            end
        end
    end
    --print("result " .. #result )
    if result[1] then
        local chosen_target = result[math.random(1,#result)]
        if event.limitdkswarm then
            if caster.limitdkswarm then
                if caster.limitdkswarm > event.limitdkswarm then
                    return
                end
            end
        end
        if event.alwaysapply then
            --print("ApplyBuffAOERandom alwaysapply" .. " " .. chosen_target:GetName())
            event.ability:ApplyDataDrivenModifier(caster, chosen_target, event.buff, {Duration = event.dur})
        else
            local myevent = {}
            myevent.caster = caster
            myevent.target = enemy
            myevent.buff = event.buff
            myevent.ability = event.ability
            myevent.dur = event.dur
            ApplyBuff(myevent)
        end
    else
        if event.limitdkswarm then
            caster.limitdkswarm = caster.limitdkswarm - 1
        end
    end

end

function LimitDKSwarm( event )
    local caster = event.caster
    if caster.limitdkswarm then
        caster.limitdkswarm = caster.limitdkswarm + 1
    else
        caster.limitdkswarm = 1
    end
end

function HeroTakesDamage( event )
	--print("damage taken " .. event.damagetaken)
end

function ChannelProcs( caster )
    if caster:HasModifier("modifier_item_channel") or caster:HasModifier("modifier_item_channel_2") then
        if not caster.channel_item_bonus then
            caster.channel_item_bonus = 1
        else
            caster.channel_item_bonus = caster.channel_item_bonus + 1
        end
        if caster.channel_item_bonus == 1 then
            local particle = ParticleManager:CreateParticle("particles/econ/items/spectre/spectre_transversant_soul/spectre_transversant_spectral_dagger_path_owner_energy.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
            caster.channel_item_bonus_fx = particle
        end
        Timers:CreateTimer(6,function()
            caster.channel_item_bonus = caster.channel_item_bonus - 1
            if caster.channel_item_bonus == 0 then
                caster.channel_item_bonus = nil
                ParticleManager:DestroyParticle(caster.channel_item_bonus_fx,true)
                ParticleManager:ReleaseParticleIndex(caster.channel_item_bonus_fx)
            end
        end)
    end
    if caster.rune_item_ability then
        if caster:HasModifier("modifier_rune") then
            local myevent = { caster = caster, target = caster, dur = 10, buff = "modifier_rune_sp", ability = caster.rune_item_ability, max = 50}
            ApplyBuffStack(myevent)
        end
    end
    if caster.rune_item_ability2 then
        if caster:HasModifier("modifier_rune2") then
            local myevent = { caster = caster, target = caster, dur = 10, buff = "modifier_rune_sp2", ability = caster.rune_item_ability2, max = 50}
            ApplyBuffStack(myevent)
        end
    end
end

function CheckForBreakableCC( target )
	if target:HasModifier("modifier_sap") or target:HasModifier("modifier_sap2") or target:HasModifier("modifier_confused") or target:HasModifier("modifier_voodoo_datadriven") or target:HasModifier("glacier_trap") or target:HasModifier("modifier_bane_nightmare") then
		return true
	else
		return false
	end
end

function IsHardCC( buff )
    if buff == "modifier_stunned" or buff == "modifier_delay_impale" or buff == "modifier_deepfreeze" or buff == "glacier_trap" or buff == "modifier_rootedfx" 
        or buff == "modifier_rootedpull" or buff == "modifier_sap" or buff == "modifier_fear2" or buff == "modifier_fearsp_bonus" 
        or buff == "modifier_sap2" or buff == "modifier_cyclone_self" or buff == "modifier_fearsp" or buff == "modifier_confused"
        or buff == "modifier_confused_unbreakable" or buff == "modifier_frostarmorbuff" or buff == "modifier_iceexplode" or buff == "modifier_stomp"
        or buff == "modifier_voodoo_datadriven"
            then
        return true
    else
        return false
    end
end

function CheckForCC( target )
    if target:HasModifier("modifier_stunned") or target:HasModifier("modifier_delay_impale") or target:HasModifier("modifier_deepfreeze") or target:HasModifier("glacier_trap") or target:HasModifier("modifier_rootedfx") 
        or target:HasModifier("modifier_rootedpull") or target:HasModifier("modifier_sap") or target:HasModifier("modifier_fear2") or target:HasModifier("modifier_fearsp_bonus") 
        or target:HasModifier("modifier_sap2") or target:HasModifier("modifier_cyclone_self") or target:HasModifier("modifier_fearsp") or target:HasModifier("modifier_confused")
        or target:HasModifier("modifier_confused_unbreakable") or target:HasModifier("modifier_frostarmorbuff") or target:HasModifier("modifier_iceexplode") or target:HasModifier("modifier_stomp")
        or target:HasModifier("modifier_voodoo_datadriven")
            then
        return true
    else
        return false
    end
end

function CheckForSilence( target )
    if target:HasModifier("modifier_silenced") or target:HasModifier("modifier_zonesilence") then
        return true
    else
        return false
    end
end

function BreakModifierOnDamage(event)
	--print("breaking dmg")
	if event.dmg ~= nil and event.dmg > 0.0 then
		if event.attacker.warddontbreakit ~= nil then
			--print("ward not breaking itself")
		else
			if not (event.dontbreak and event.dontbreak == 1) then
				local caster = event.unit
				caster:RemoveModifierByName("modifier_sap")
				caster:RemoveModifierByName("modifier_sap2")
                caster:RemoveModifierByName("modifier_sap3")
				caster:RemoveModifierByName("modifier_voodoo_datadriven")
				caster:RemoveModifierByName("modifier_confused")
				caster:RemoveModifierByName("glacier_trap")
			end
		end
	end
end

function RemoveSlows(event)
	local caster = event.target
	if caster == nil then
		caster = event.caster
	end
	if event.castertarget then
		caster = event.caster
	end
	if event.levelcondition and event.levelcondition == 0 then
		return
	end
	caster:RemoveModifierByName("modifier_slow25")
	caster:RemoveModifierByName("modifier_slow75")
	caster:RemoveModifierByName("modifier_aoeslow50")
	caster:RemoveModifierByName("modifier_frostslow50")
	caster:RemoveModifierByName("modifier_netherblast_enemy")
	caster:RemoveModifierByName("modifier_aoeslowaura")
	caster:RemoveModifierByName("aoeslow50")
	caster:RemoveModifierByName("modifier_slow50")
	caster:RemoveModifierByName("aoeslow20")
	caster:RemoveModifierByName("aoeslow40")
	caster:RemoveModifierByName("modifier_slow40storm")
	caster:RemoveModifierByName("pyroslow75")
	caster:RemoveModifierByName("hellfire50")
	caster:RemoveModifierByName("modifier_furyslow")
	caster:RemoveModifierByName("modifier_item_aura13dmg")
	caster:RemoveModifierByName("modifier_item_aura13")
	caster:RemoveModifierByName("modifier_bleedslow")
	caster:RemoveModifierByName("modifier_frostslow50_2")
	caster:RemoveModifierByName("modifier_frostchains")
	caster:RemoveModifierByName("modifier_slowpoison")
	caster:RemoveModifierByName("modifier_slowpoison2")
	caster:RemoveModifierByName("modifier_frostslow10")
	caster:RemoveModifierByName("modifier_slowstack10")
	caster:RemoveModifierByName("modifier_slowpoisonsnake")
	caster:RemoveModifierByName("modifier_shivpoison")
	caster:RemoveModifierByName("modifier_frostslow40")
    caster:RemoveModifierByName("modifier_ice_armor_slow")
    caster:RemoveModifierByName("modifier_hammerslow")
    caster:RemoveModifierByName("modifier_slowmsas50")
    caster:RemoveModifierByName("modifier_surv_aapoison")
    caster:RemoveModifierByName("modifier_dhslow")
    caster:RemoveModifierByName("modifier_icenova_slow")
end

function RemoveRoots(event)
	local caster = event.target
	if caster == nil then
		caster = event.caster
	end
	caster:RemoveModifierByName("modifier_rootsdruid")
	caster:RemoveModifierByName("modifier_rootedfx")
	caster:RemoveModifierByName("modifier_icenova")
	caster:RemoveModifierByName("modifier_rooted_self")
	
end

function SpellInterrupt( event )
	local target = event.target
	local caster = event.caster
	local manafactor = 1.0
	if target.IsCasting == 1 and not (target:HasModifier("modifier_activemage") or target:HasModifier("modifier_interruptimune")) then
		manafactor = 2.0
		if target.Castbar ~= nil then
    		ParticleManager:DestroyParticle(target.Castbar,true)
            ParticleManager:ReleaseParticleIndex(target.Castbar)
    	end
		if event.feralcdreduce then
			--event.ability:ApplyDataDrivenModifier(event.caster, event.caster, "modifier_feralfury", nil)
			--event.caster.Energy = event.caster.Energy+25
			StunTarget(event)
		elseif event.stun ~= nil then
			--local damage_table = {}
 			--damage_table.Duration = event.dur
			--event.ability:ApplyDataDrivenModifier(event.caster, target, "modifier_stunned", damage_table)

			local myevent = {}
    		myevent.caster = event.caster
    		myevent.target = target
    		myevent.buff = "modifier_stunned"
			myevent.ability = event.ability
			myevent.dur = event.dur
			ApplyBuff(myevent)
			--also short silence
 			--damage_table.Duration = 0.05
			--event.ability:ApplyDataDrivenModifier(event.caster, target, "modifier_silence", damage_table)

			local myevent = {}
    		myevent.caster = event.caster
    		myevent.target = target
    		myevent.buff = "modifier_silence"
			myevent.ability = event.ability
			myevent.dur = 0.05
			ApplyBuff(myevent)
		else
			local damage_table = {}
 			damage_table.Duration = event.dur
 			if event.curseblade then
 				damage_table.Duration = event.dur*GetCCPower(event)
 			end
			--event.ability:ApplyDataDrivenModifier(event.caster, target, "modifier_silence", damage_table)

			local myevent = {}
    		myevent.caster = event.caster
    		myevent.target = target
    		myevent.buff = "modifier_silence"
    		if event.trystun and event.trystun > 0 then
    			myevent.buff = "modifier_stunned"
    		end
			myevent.ability = event.ability
			myevent.dur = damage_table.Duration
			ApplyBuff(myevent)

			local particle = ParticleManager:CreateParticle("particles/radiant_fx/tower_good3_dest_lvl2_hit.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
		end
		if event.csfx ~= nil then
			event.ability:ApplyDataDrivenModifier(event.caster, target, "modifier_csfx", nil)
		end
		local particle = ParticleManager:CreateParticleForPlayer("particles/units/heroes/hero_zeus/zues_screen_empty.vpcf", PATTACH_POINT_FOLLOW, target, target:GetOwner())
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticleForPlayer("particles/econ/events/killbanners/screen_killbanner_compendium14_rampage_burst.vpcf", PATTACH_POINT_FOLLOW, caster, caster:GetOwner())
        ParticleManager:ReleaseParticleIndex(particle)
		
		if event.shamanhaste and event.shamanhaste > 0 then
			event.ability:ApplyDataDrivenModifier(event.caster, event.caster, "modifier_hasteproc25", nil)
		end
		if event.rageproc and event.rageproc > 0 then
            local myevent = {}
            myevent.caster = caster
            myevent.energy = event.rageproc
            AddEnergy(myevent)
		end
		if event.enemyhaste and event.enemyhaste > 0 then
			local myevent = {}
    		myevent.caster = event.caster
    		myevent.target = event.target
    		myevent.buff = "modifier_mindnumb"
			myevent.ability = event.ability
			myevent.dur = event.enemyhaste
			ApplyBuff(myevent)
		end
		if event.qspellcd and event.qspellcd > 0 then
			local abil = target:GetAbilityByIndex(0)
			if abil and abil:GetCooldownTimeRemaining() < event.qspellcd then
				abil:EndCooldown()
				abil:StartCooldown(event.qspellcd)
			end
		end
	else
		if event.feraljumpcd and event.feraljumpcd > 0 then
			event.ability:EndCooldown()
			event.ability:StartCooldown(event.feraljumpcd)
		end
	end
	if event.manasteal and event.manasteal > 0 then
		caster:SetMana(caster:GetMana() + caster:GetMaxMana()*manafactor*event.manasteal/100)
	end
end

function PurgeUnit(event)
    local caster = event.caster
	local target = event.target
	local silencepenalty = false
	if target == nil then
		target = event.unit
	end
	if target == nil then
		target = event.caster
	end
    if event.innercd and event.innercdbuff then
        if caster:HasModifier("modifier_purge_cd_shaman") then
            return
        end
        event.ability:ApplyDataDrivenModifier(caster, caster, event.innercdbuff, {Duration = event.innercd})
    end
    if event.consecutivecasts then
        local cancel = true
        if caster.purge_consecutive_casts_target and target == caster.purge_consecutive_casts_target then
            if not caster.purge_consecutive_casts then
                caster.purge_consecutive_casts = 0
            end
            caster.purge_consecutive_casts = caster.purge_consecutive_casts + 1
            if caster.purge_consecutive_casts >= event.consecutivecasts then
                caster.purge_consecutive_casts = 0
                cancel = false
            end
        end
        caster.purge_consecutive_casts_target = target
        if cancel then
            return
        end
    end
    if event.purgefx then
        local particle = ParticleManager:CreateParticle(event.purgefx, PATTACH_ABSORIGIN_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
    end
	--silence if dot2
	if target:HasModifier("modifier_dot2") and event.trinket == nil then
		silencepenalty = true
	end
    --[[
    if target:HasModifier("modifier_swd") and target.devouringsource then
        local myevent = {}
        local stackcount = target:GetModifierStackCount("modifier_swd", nil)
        myevent.caster = target.devouringsource
        myevent.target = event.caster
        myevent.ability = event.ability
        myevent.damage = 0.0
        myevent.spelldamagefactor = 150*0.75*stackcount
        myevent.attributefactor = 150*0.75*stackcount
        myevent.shadowdmg = 1
        DamageUnit(myevent)
    end ]]
	if event.nopenalty then
		silencepenalty = false
	end

	-- Strong Dispel
	local RemovePositiveBuffs = false
	local RemoveDebuffs = true
	local BuffsCreatedThisFrameOnly = false
	local RemoveStuns = true
	local RemoveExceptions = false


	target:RemoveModifierByName("modifier_voodoo_datadriven")
	target:RemoveModifierByName("modifier_silence")
	target:RemoveModifierByName("modifier_zonesilence")


	target:Purge( RemovePositiveBuffs, RemoveDebuffs, BuffsCreatedThisFrameOnly, RemoveStuns, RemoveExceptions)

	-- do the silence
	if silencepenalty == true then
		--local damage_table = {}
 		--damage_table.Duration = 5
		--event.ability:ApplyDataDrivenModifier(event.caster, event.caster, "modifier_silence", damage_table)
		--print("self silence penalty cuz of dispel")
		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.caster
		myevent.buff = "modifier_silence"
		myevent.ability = event.ability
		myevent.dur = 5
		ApplyBuff(myevent)
	end

	if event.trinket then
		target:RemoveModifierByName("modifier_dot4")
		target:RemoveModifierByName("modifier_infested")
		target:RemoveModifierByName("modifier_cyclone_self")
	end

	if event.massdispel then
		--print("try")
		target:RemoveModifierByName("modifier_cyclone_self")
		target:RemoveModifierByName("modifier_infested")
	end
    OnPurgeProcs(caster, target, event.ability)
end

function PurgeEnemyUnit(event)
	if event.purge and event.purge == 0 then
		return
	end
    if event.purge then
        local particle = ParticleManager:CreateParticle("particles/generic_gameplay/generic_purge.vpcf", PATTACH_ABSORIGIN_FOLLOW, event.target)
        ParticleManager:ReleaseParticleIndex(particle)
    end
	local target = event.target
	if target == nil then
		target = event.unit
	end
	-- Strong Dispel
	local RemovePositiveBuffs = true
	local RemoveDebuffs = false
	local BuffsCreatedThisFrameOnly = false
	local RemoveStuns = false
	local RemoveExceptions = false
	target:Purge( RemovePositiveBuffs, RemoveDebuffs, BuffsCreatedThisFrameOnly, RemoveStuns, RemoveExceptions)
	if event.massdispel then
		--print("try")
		target:RemoveModifierByName("modifier_invul")
		target:RemoveModifierByName("modifier_frostarmorbuff")
	end
end

function BuffFriendlyTarget ( event )
    local caster = event.caster
    local target = event.target
    if target ~= nil and caster:GetTeamNumber()==target:GetTeamNumber() then
    	event.ability:ApplyDataDrivenModifier(caster, target, event.buff, nil)
	end
end

function ReduceAbilityCooldown ( event )
    local caster = event.caster
    event.ability = caster:GetAbilityByIndex(event.index)
    ReduceCooldown(event)
end

function HealUnit( event )
    local caster = event.caster
    local target = event.target
    local isaoe = false
    local ability = event.ability
    if event.isaoeheal and event.isaoeheal >= 1 then
        isaoe = true
    end
    local displaynumber = true

    if event.heal_owner and caster then
        --caster = caster.owner
        target = caster
    end
    if event.heal_summoner and caster and caster.owner then
        caster = caster.owner
        target = caster.owner
    end
    if event.retridmgtoheal ~= nil then
    	target = caster
    	event.heal = event.heal*2
    end
    if event.shadowdmgtoheal ~= nil then
    	target = caster
    	event.heal = event.heal*event.shadowdmgtoheal / 100
    end
    if event.attacktargetswitch ~= nil then
    	target = caster
    end
    if event.affectattacker then
    	target = event.attacker
    end
    if target == nil and caster ~= nil then
    	target = caster
    end
    if event.change_target_to_unit then
        target = event.unit
    end
    if event.most_injured_target then
        target = MostWoundedTarget({range = 1500, caster = caster, target = caster, onlyhero = true})
    end
    if target == nil then
    	return
    end
    if caster and caster.has_used_ravencraft_abilitypoint_item and not caster:HasModifier("modifier_pathbuff_088") then
        return
    end
    if caster and caster.triumpABPGiven and not HeroHasNeutralItem(caster, "item_neutral_31") then
        return
    end
    --if target:GetUnitLabel() == "tower" then
    --	return
    --end
    if target:HasModifier("modifier_cyclone_self") and not event.healthroughcyclone then
  		return
    end
    if target:HasModifier("modifier_denial_aura") then
        return
    end
    if target:HasModifier("modifier_pet_system") then
        return
    end
    if event.only_heal_on_caster_buff_condition and not caster:HasModifier(event.only_heal_on_caster_buff_condition) then
        return
    end
    if event.heal2buffconditions1 then
        if not caster:HasModifier(event.heal2buffconditions1) and not caster:HasModifier(event.heal2buffconditions2) then
            return
        end
    end
    if event.demoncondition and not caster:HasModifier("modifier_item_demonglaive") then
        return
    end
    if event.health_threshold and target:GetHealth() / target:GetMaxHealth() >= event.health_threshold then
        return
    end
    if event.heal_inner_cd and event.heal_inner_cd_buff then
        if caster:HasModifier(event.heal_inner_cd_buff) then
            return
        else
            ability:ApplyDataDrivenModifier(caster, caster, event.heal_inner_cd_buff, {Duration = event.heal_inner_cd * GetInnerCooldownFactor(caster)})
            local particle = ParticleManager:CreateParticle("particles/dazzle_holy_wave_b.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,75))
            ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin()+Vector(0,0,75))
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
    if event.only_heal_when_low then
        if target:GetHealth() / target:GetMaxHealth() >= event.only_heal_when_low then
            return
        else
            if event.only_heal_when_low_with_cost then
                if caster:GetMana() >= event.only_heal_when_low_with_cost then
                    caster:SetMana(caster:GetMana() - event.only_heal_when_low_with_cost)
                else
                    return
                end
            end
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nyx_assassin/nyx_assassin_vendetta_blood.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
            ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
            ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
            if event.fire_fx_when_low then
                ability:ApplyDataDrivenModifier(caster, target, "modifier_healfxpriest2", nil)
            end
        end
    end
    if caster and caster.spelldamage == nil then
    	caster.spelldamage = 0.0
    end
    if event.heal == nil then
    	event.heal = 0.0
    end

    if event.spelldamagefactor == nil then
    	event.spelldamagefactor = 0.0
    end

    if event.percenthp then
    	event.heal = event.heal + event.percenthp*target:GetMaxHealth()/100.0
    end
    -- Spelldamage
    local spelldamagefromitem = 0
    -- add spelldamage
    if event.spelldamagefactor > 0.0 and event.FromGuardian ~= 1 then
    	spelldamagefromitem = GetSpellpower(event)
    	event.heal = event.heal + event.spelldamagefactor*(caster.spelldamage+spelldamagefromitem)/100.0
    end
    -- healing from stats
    --also add bonus factor
    local statbonus = 1.0
    if event.attributefactor ~= nil then
    	-- normal heroes
    	if event.attributechangeint ~= nil then
    		event.heal = event.heal + GetIntellectCustom(caster)*event.attributefactor*statbonus/100.0
    	elseif event.attributechangestr ~= nil then
    		event.heal = event.heal + GetStrengthCustom(caster)*event.attributefactor*statbonus/100.0
    	elseif event.attributechangeagi ~= nil then
    		event.heal = event.heal + GetAgilityCustom(caster)*event.attributefactor*statbonus/100.0
    	elseif event.attributechangeall ~= nil then
    		event.heal = event.heal + GetAgilityCustom(caster)*event.attributefactor*statbonus/100.0 + GetStrengthCustom(caster)*event.attributefactor*statbonus/100.0 + GetIntellectCustom(caster)*event.attributefactor*statbonus/100.0
    	else
    		if caster:IsHero() then
    			event.heal = event.heal + GetPrimaryStatValueCustom(caster)*event.attributefactor*statbonus/100.0
    		end
    	end
	end

    local base_healing = event.heal
	-- lifebloom increases per stack
	if event.lifebloom ~= nil then
		local stackcount = target:GetModifierStackCount("modifier_lifebloom", caster)
		if target:HasModifier("modifier_lifebloomfull") then
			stackcount = target:GetModifierStackCount("modifier_lifebloomfull", caster)
		end
	    event.heal = event.heal * stackcount
	    --print("stack count considered" .. caster:GetPrimaryStatValue()*event.attributefactor)
	end

    --flat bonuses
    if caster.talents then
        if caster.talents[8] and not event.no_bonus_talent then
            local ancient = 1
            if caster:HasModifier("modifier_item_silverblood4") then
                ancient = 2
            end
            event.heal = event.heal + caster:GetHealth() * 0.005 * caster.talents[8] * ancient
        end
    end

    --healprocs
    if event.bloodwolf then
        ChannelProcs(caster)
    end

	-- spellcrit  NEW NEW NEW
	local critchancefactor = 1.0
    local critdmgbonusfactor = 1.0
    local critchance = 0
    local critpossible = true
    if event.cannotcrit then
    	critpossible = false
    end
    if event.critchancefactor ~= nil then
 		critchancefactor = event.critchancefactor
 	end
 	if event.critdmgbonusfactor ~= nil then
 		critdmgbonusfactor = event.critdmgbonusfactor
 	end
    local artifact_crit_dmg = caster:GetModifierStackCount("modifier_mythic_critdmg", nil)
    if artifact_crit_dmg > 0 then
        critdmgbonusfactor = critdmgbonusfactor + 0.01 * artifact_crit_dmg
    end
    if caster:HasModifier("modifier_crit_aura_dragon") then
        critdmgbonusfactor = critdmgbonusfactor + 0.2
    end
    if caster:HasModifier("modifier_element_chaos") then
        critdmgbonusfactor = critdmgbonusfactor + 0.3
    end
    if ability then
        critdmgbonusfactor = critdmgbonusfactor + LunarEclipseProc(caster)
    end
    if caster:HasModifier("modifier_path_shadowform") then
        critdmgbonusfactor = critdmgbonusfactor + 0.3 * caster.talents[73]
    end
    local riggedDiceModifier = event.caster:FindModifierByName("modifier_item_crit_myth")
    if critpossible == true and riggedDiceModifier then
        local riggedDiceModifierAbility = riggedDiceModifier:GetAbility()
        if(riggedDiceModifierAbility) then
            critchance = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor
            local critDmgFactor = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat4") / 100
    
            if caster:HasModifier("modifier_crit_myth") then
                critchance = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat5")*critchancefactor
                critDmgFactor = riggedDiceModifierAbility:GetSpecialValueFor("bonus_stat6") / 100
            end
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local worldBreakerModifier = event.caster:FindModifierByName("modifier_item_crit_pure_immortal2")
    if critpossible == true and worldBreakerModifier then
        local worldBreakerModifierAbility = worldBreakerModifier:GetAbility()
        if(worldBreakerModifierAbility) then
            critchance = worldBreakerModifierAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor
            local critDmgFactor = worldBreakerModifierAbility:GetSpecialValueFor("bonus_stat2") / 100
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local tributeOfBloodModifier = event.caster:FindModifierByName("modifier_item_crit_pure_5")
    if critpossible == true and tributeOfBloodModifier then
        local tributeOfBloodModifierAbility = tributeOfBloodModifier:GetAbility()
        if(tributeOfBloodModifierAbility) then
            critchance = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor
            local critDmgFactor = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat4") / 100
    
            if caster:HasModifier("modifier_item_crit_pure_5_lifesteal") then
                critchance = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat6")*critchancefactor
                critDmgFactor = tributeOfBloodModifierAbility:GetSpecialValueFor("bonus_stat7") / 100
            end
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_mythic_abilcrit") then
        critchance = critchancefactor * caster:GetModifierStackCount("modifier_mythic_abilcrit", nil)
        if math.random(1,100) <= critchance then
            event.heal = event.heal*5*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    local templeArmorModifier = event.caster:FindModifierByName("modifier_item_crit_pure_immortal3")
    if critpossible == true and templeArmorModifier then
        local templeArmorModifierAbility = templeArmorModifier:GetAbility()
        if(templeArmorModifierAbility) then
            critchance = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor
            local critDmgFactor = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat2") / 100
    
            if event.caster:HasModifier("modifier_item_crit_pure_5_lifesteal_no_ls") then
                critchance = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor
                critDmgFactor = templeArmorModifierAbility:GetSpecialValueFor("bonus_stat4") / 100
            end
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    if critpossible == true and caster.talents and caster.talents[19] and caster.talents[19] > 0 then
        critchance = caster.talents[19] * critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*5*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_crit_aura_dragon_2") then
        critchance = 3*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*5.0*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and caster:HasModifier("modifier_guardianshield") then
        critchance = 100*critchancefactor
        if math.random(1,100) <= critchance then
            caster:RemoveModifierByName("modifier_guardianshield")
            event.heal = event.heal*(1.5 + 0.5 * caster.talents[106])*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_ancient_wolf") then
        critchance = 10*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2.25*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_crit_pure_immortal_2") then
        critchance = 5*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*5*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    local armageddon = event.caster:FindModifierByName("modifier_item_crit_pure_immortal")
    if critpossible == true and armageddon then
        local armageddonAbility = armageddon:GetAbility()
        if(armageddonAbility) then
            critchance = armageddonAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor
            local critDmgFactor = armageddonAbility:GetSpecialValueFor("bonus_stat2") / 100
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local ebonyMasterBowModifier = event.caster:FindModifierByName("modifier_item_warglaive")
    if critpossible == true and ebonyMasterBowModifier then
        local ebonyMasterBowAbility = ebonyMasterBowModifier:GetAbility()
        if(ebonyMasterBowAbility) then
            critchance = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat3")*critchancefactor
            local critDmgFactor = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat4") / 100
    
            if event.caster:HasModifier("modifier_bow_crit_legendary") then
                critchance = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat6")*critchancefactor
                critDmgFactor = ebonyMasterBowAbility:GetSpecialValueFor("bonus_stat7") / 100
            end
    
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    --if critpossible == true and caster.runeword and caster.runeword[20] and caster.runeword[20] > 0 then
    --    critchance = caster.runeword[20]
    --    if math.random(1,100) <= critchance then
    --        event.heal = event.heal*3*critdmgbonusfactor
    --        displaynumber = 1
    --        critpossible = false
    --    end
    --end
    if critpossible == true and event.caster:HasModifier("modifier_item_endgame10") then
        critchance = 5*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*3*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_crit_pure") then
        critchance = 7*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2.5*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_druid_glove_crit") then
        critchance = 7*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2.5*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    local noblePlainstridersModifier = event.caster:FindModifierByName("modifier_item_bootscrit4")
    if critpossible == true and noblePlainstridersModifier then
        local noblePlainstridersModifierAbility = noblePlainstridersModifier:GetAbility()
        if(noblePlainstridersModifierAbility) then
            critchance = noblePlainstridersModifierAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor
            local critDmgFactor = noblePlainstridersModifierAbility:GetSpecialValueFor("bonus_stat3") / 100
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local alphamaneModifier = event.caster:FindModifierByName("modifier_item_bootscrit3")
    if critpossible == true and alphamaneModifier then
        local alphamaneModifierAbility = alphamaneModifier:GetAbility()
        if(alphamaneModifierAbility) then
            critchance = alphamaneModifierAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor
            local critDmgFactor = alphamaneModifierAbility:GetSpecialValueFor("bonus_stat3") / 100
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local tamedFirebatModifier = event.caster:FindModifierByName("modifier_item_bootscrit2")
    if critpossible == true and tamedFirebatModifier then
        local tamedFirebatModifierAbility = tamedFirebatModifier:GetAbility()
        if(tamedFirebatModifierAbility) then
            critchance = tamedFirebatModifierAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor
            local critDmgFactor = tamedFirebatModifierAbility:GetSpecialValueFor("bonus_stat3") / 100
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    if critpossible == true and caster.spiritHealCrit and caster.spiritHealCrit >= 1 then
        critchance = 100*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2.0*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
            caster.spiritHealCrit = caster.spiritHealCrit - 1
        end
    end
    if critpossible == true and caster.talents and caster.talents[45] and caster.talents[45] > 0 and ability and (ability:GetAbilityIndex() == 0 or ability:GetAbilityIndex() == 1) then
        local alphablood_divine = caster:HasModifier("modifier_pathbuff_045")
        local alphablood_chance = 3
        if ability:GetAbilityIndex() == 1 then
            alphablood_chance = 2
            if alphablood_divine then
                alphablood_chance = 4
            end
        end
        critchance = alphablood_chance*caster.talents[45]
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
            PathAlphaBloodProc( caster, ability )
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_endgame9") then
        critchance = 10*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2.0*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_weapon10") then
        critchance = 10*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2.15*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_crit_aura_dragon") then
        critchance = 3*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2.0*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    local legionBannerActiveModifier = caster:FindModifierByName("modifier_guaranteed_crit_once")
    if critpossible == true and legionBannerActiveModifier then
        local legionBannerActiveModifierAbility = legionBannerActiveModifier:GetAbility()
        if(legionBannerActiveModifierAbility) then
            critchance = legionBannerActiveModifierAbility:GetSpecialValueFor("bonus_stat8")*critchancefactor + flatCritChance
            if math.random(1,100) <= critchance then
                local critDmgFactor = legionBannerActiveModifierAbility:GetSpecialValueFor("bonus_stat9") / 100
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
                event.caster:RemoveModifierByName("modifier_guaranteed_crit_once")
            end
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_endgame5") then
    	critchance = 8 * critchancefactor
    	if math.random(1,100) <= critchance then
	    	event.heal = event.heal*2.5*critdmgbonusfactor
    		displaynumber = 1
	    	critpossible = false
	    end
    end
    local itemMultiElementShadowCrits = event.caster:FindModifierByName("modifier_element_shadow")
    if critpossible == true and itemMultiElementShadowCrits then
        local itemMultiElementShadowCritsAbility = itemMultiElementShadowCrits:GetAbility()
        if(itemMultiElementShadowCritsAbility) then
            local critDmgFactor = itemMultiElementShadowCritsAbility:GetSpecialValueFor("bonus_stat3") / 100
            critchance = itemMultiElementShadowCritsAbility:GetSpecialValueFor("bonus_stat2")*critchancefactor
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    if critpossible == true and caster.talents and caster.talents[139] > 0 and ability and ability:GetLevel() == 3 then
        critchance = 5*critchancefactor*caster.talents[139]
        if math.random(1,100) <= critchance then
            event.heal = event.heal*1.5*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and caster.talents and caster.talents[37] and caster.talents[37] > 0 then
        critchance = 3*caster.talents[37]
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_bootscrit") then
    	critchance = 11*critchancefactor
    	if math.random(1,100) <= critchance then
	    	event.heal = event.heal*1.5*critdmgbonusfactor
    		displaynumber = 1
	    	critpossible = false
    	end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_bootscurse") then
        critchance = 15*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    local boneCollectorModifier = caster:FindModifierByName("modifier_item_crit_pure_3")
    if critpossible == true and boneCollectorModifier then
        local boneCollectorModifierAbility = boneCollectorModifier:GetAbility()
        critchance = boneCollectorModifierAbility:GetSpecialValueFor("bonus_stat4")*critchancefactor
        local critDmgFactor = boneCollectorModifierAbility:GetSpecialValueFor("bonus_stat5") / 100
        if math.random(1,100) <= critchance then
            event.heal = event.heal*critDmgFactor*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    local legionBannerModifier = caster:FindModifierByName("modifier_item_crit_pure_4")
    if critpossible == true and legionBannerModifier then
        local legionBannerModifierAbility = legionBannerModifier:GetAbility()
        if(legionBannerModifierAbility) then
            critchance = legionBannerModifierAbility:GetSpecialValueFor("bonus_stat4")*critchancefactor
            local critDmgFactor = legionBannerModifierAbility:GetSpecialValueFor("bonus_stat5") / 100
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local maskOfHorrorModifier = caster:FindModifierByName("modifier_ancient_def")
    if critpossible == true and maskOfHorrorModifier then
        local maskOfHorrorModifierAbility = maskOfHorrorModifier:GetAbility()
        if(maskOfHorrorModifierAbility) then
            critchance = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat8")*critchancefactor
            local critDmgFactor = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat9") / 100
            if caster:HasModifier("modifier_horror_proc") then
                critchance = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat10")*critchancefactor
                critDmgFactor = maskOfHorrorModifierAbility:GetSpecialValueFor("bonus_stat11") / 100
            end
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local bootsOfWonderModifier = caster:FindModifierByName("modifier_item_bootscrit_2")
    if critpossible == true and bootsOfWonderModifier then
        local bootsOfWonderModifierAbility = bootsOfWonderModifier:GetAbility()
        if(bootsOfWonderModifierAbility) then
            critchance = bootsOfWonderModifierAbility:GetSpecialValueFor("bonus_stat1")*critchancefactor
            local critDmgFactor = bootsOfWonderModifierAbility:GetSpecialValueFor("bonus_stat2") / 100
            if math.random(1,100) <= critchance then
                event.heal = event.heal*critDmgFactor*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    local holy_priest_crit = caster:FindAbilityByName("holy2")
    if critpossible == true and holy_priest_crit and holy_priest_crit:GetLevel() >= 3 then
        critchance = 20*critchancefactor
        if math.random(1,100) <= critchance then
            event.heal = event.heal*2*critdmgbonusfactor
            displaynumber = 1
            critpossible = false
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_bowupgradeproc") then
        critchance = 100*critchancefactor
        if math.random(1,100) <= critchance then
            local dist = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
            if dist > 300.0 then
                event.heal = event.heal*1.75*critdmgbonusfactor
                displaynumber = 1
                critpossible = false
            end
        end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_caster6") then
    	critchance = 12*critchancefactor
    	if math.random(1,100) <= critchance then
	    	event.heal = event.heal*1.75*critdmgbonusfactor
    		displaynumber = 1
	    	critpossible = false
    	end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_weapon9") then
    	critchance = 12*critchancefactor
    	if math.random(1,100) <= critchance then
	    	event.heal = event.heal*1.5*critdmgbonusfactor
    		displaynumber = 1
	    	critpossible = false
    	end
    end
    if critpossible == true and event.caster:HasModifier("modifier_item_caster7") and target:GetHealth()/target:GetMaxHealth() < 0.3 then
	    event.heal = event.heal*1.25*critdmgbonusfactor
    	displaynumber = 1
	    critpossible = false
    end
    local holy_priest_crit = caster:FindAbilityByName("holy_priest_crit")
    if critpossible == true and holy_priest_crit and holy_priest_crit:GetLevel() >= 3 then
    	critchance = 10*critchancefactor
    	if math.random(1,100) <= critchance then
	    	event.heal = event.heal*2*critdmgbonusfactor
    		displaynumber = 1
	    	critpossible = false
    	end
    end
    if critpossible == true and caster:HasModifier("modifier_guaranteed_crit") then
    	critchance = 100*critchancefactor
    	if math.random(1,100) <= critchance then
	    	event.heal = event.heal*1.5*critdmgbonusfactor
    		displaynumber = 1
	    	critpossible = false
    	end
    end
    local talentcritstacks = caster:GetModifierStackCount("modifier_crit_stacks", nil)
    if critpossible == true and talentcritstacks > 0 then
    	critchance = talentcritstacks*15*critchancefactor
    	if math.random(1,100) <= critchance then
	    	event.heal = event.heal*1.5*critdmgbonusfactor
    		displaynumber = 1
	    	critpossible = false
    	end
    end
    
    local was_crit = false
    if critpossible == false and not event.cannotcrit then
        was_crit = true
    end

    if event.critmanareg and critpossible == false then
    	caster:SetMana(caster:GetMana()+(caster:GetMaxMana()*event.critmanareg/100.0))
    	local particle = ParticleManager:CreateParticle("particles/items3_fx/mango_active.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end

    local talentshamancritheal = caster:FindAbilityByName("resto6")
    if critpossible == false and not event.crithealnoproc and not event.cannotcrit and talentshamancritheal and talentshamancritheal:GetLevel() >= 3 then
    	talentshamancritheal:ApplyDataDrivenModifier(caster, target, "modifier_shaman_crithot", nil)
    end

    -- Mortal Strike debuff
    if target:HasModifier("modifier_woundpoison") and event.retridmgtoheal == nil then
    	event.heal=event.heal *0.90
    end
    if target:HasModifier("modifier_woundpoison2") and event.retridmgtoheal == nil then
    	event.heal=event.heal *0.85
    end
    if target:HasModifier("modifier_healdebuff10") and event.retridmgtoheal == nil then
    	event.heal=event.heal *0.9
    end
    if target:HasModifier("modifier_healdebuff") and event.retridmgtoheal == nil then
    	event.heal = event.heal / 2
    end
    if target.talents then
        if target.talents[72] and target.talents[72] > 0 then
            event.heal = event.heal / 4
        end
    end
    local fury_heal_stacks = target:GetModifierStackCount("modifier_bleedingpve", nil)
    if fury_heal_stacks and fury_heal_stacks > 0 then
        event.heal=event.heal / fury_heal_stacks
    end
    if target:HasModifier("modifier_healdebuff90") and event.retridmgtoheal == nil and not target:HasModifier("modifier_omni_allow_heal") then
        event.heal = event.heal * 0.1
    end
    if target:HasModifier("modifier_heal_curse") and event.retridmgtoheal == nil then
        event.heal = event.heal * 0.1
    end
    if target:HasModifier("modifier_healdebuff75") and event.retridmgtoheal == nil then
        event.heal = event.heal *0.25
    end
    if target:HasModifier("modifier_healdebuff50") and event.retridmgtoheal == nil then
        event.heal = event.heal *0.5
    end
    if target:HasModifier("modifier_healdebuff25") and event.retridmgtoheal == nil then
        event.heal = event.heal *0.75
    end
    if target:HasModifier("modifier_unholyheal") and event.retridmgtoheal == nil then
    	event.heal = 0
    end
    

    if event.healfactor then
    	event.heal = event.heal * event.healfactor / 100
    end

    
    --if caster.runeword and caster.runeword[13] then
    --    healing_bonus = healing_bonus + 0.01*caster.runeword[13]
    --end
    --if target.runeword and target.runeword[13] then
    --    healing_bonus = healing_bonus + 0.01*target.runeword[13]
    --end
    --local aoe_bonus = 1
    --if isaoe then
    --    aoe_bonus = GetAbilityAOEDamageModifierAdditive(event, caster, real_caster, target, ability, behindtarget, true)
    --    event.heal = event.heal * aoe_bonus
    --end

    -------------------------------------------------------------------------------------------------------------
    --bonus calcs
    local healing_bonus = GetHealingMultiplier(event, caster, ability, target, true, isaoe, was_crit)
    --final heal value
    if event.not_affected_by_heal_bonuses then
        event.heal = base_healing
    end
    if caster:IsRealHero() then
        caster.heal_bonus = healing_bonus
    end
    event.heal = event.heal * healing_bonus
    if caster and caster:IsHero() then
        event.heal = event.heal * GetHealingFactorFromHealerCount()
    end

    -- healing absorb, dk spell
    local healabsorb = target:GetModifierStackCount("modifier_healabsorb", nil)
    if healabsorb > 0 and target.healabsorbability then
    	local diff = event.heal - healabsorb
    	if diff <= 0 then
    		target:SetModifierStackCount("modifier_healabsorb", target.healabsorbability, healabsorb-event.heal)
    		event.heal = 0	
    	else
    		event.heal = event.heal - healabsorb
    		target:RemoveModifierByName("modifier_healabsorb")
    	end
    end
    --heal capped?
    if event.cap_healing_at_max_health then
        local max_heal = target:GetMaxHealth() * event.cap_healing_at_max_health / 100
        if event.heal > max_heal then
            event.heal = max_heal
        end
    end
    --track overhealing
    local missinghealth = target:GetMaxHealth()-target:GetHealth()
    local overhealing = event.heal - missinghealth
    if caster:GetUnitLabel() == "hero" and caster.healingdone then
    	if overhealing > 0 then
    		caster.healingdone = caster.healingdone + missinghealth
    	else
 			caster.healingdone = caster.healingdone + event.heal
 		end
    end

    if COverthrowGameMode.heal_collector and not COverthrowGameMode.heal_collector:IsNull() and target:HasModifier("modifier_heal_collector") then
        target = COverthrowGameMode.heal_collector
    end
    if event.heal > 1000000000 then
        event.heal = 1000000000
    end
    if event.heal > 0 then
        if caster:IsRealHero() then
            caster.healing_done = caster.healing_done + event.heal
        end
        --print("healing unit" .. event.heal)
    	target:Heal(event.heal, caster)
        --print(target:GetName())
        if GetDivineShieldStat(caster) >= 1 and (not isaoe) and (not event.isdot) then
            DivineShieldProc(caster, target, event.heal)
        end
        --aggro from heal in 900 area
        if caster ~= target then
            local aggro_caused = event.heal-overhealing
            if COverthrowGameMode.jungledifficulty <= 1 then
                aggro_caused = aggro_caused / 5
            end
            COverthrowGameMode:PVEAggroAddAOE(caster, target, aggro_caused, 625)
        end
        --talents
        --[[
        if caster.talents and caster.talents[50] then
            if caster.talents[50] > 0 and math.random(1,100) <= 1 then
                local myevent = {}
                myevent.caster = caster
                myevent.target = caster
                myevent.buff = "modifier_talent_onheal_armor"
                myevent.ability = caster.combat_system_ability
                myevent.dur = 3 + 3 * caster.talents[50]
                ApplyBuff(myevent)
                caster.creepertarget = target
                myevent.target = target
                myevent.dur = nil
                myevent.buff = "irongrizzly_summon_proc"
                ApplyBuff(myevent)
            end
        end
        ]]
    else
    	return
    end

    --stat tracking
    local track_ability_stats = true
    if track_ability_stats then
        if not caster.ability_stats_heal then
            caster.ability_stats_heal = {}
        end
        local index = -1
        if event.ability then
            index = event.ability:GetAbilityIndex()
        end
        if index >= 0 then
            if not caster.ability_stats_heal[index] then
                caster.ability_stats_heal[index] = 0
            end
            caster.ability_stats_heal[index] = caster.ability_stats_heal[index] + event.heal
        end
    end

    if event.buffonfullheal and target:GetHealth() / target:GetMaxHealth() >= 1.0 then
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_holy_ring", {Duration = event.buffdur})
    end
    
    if caster:GetUnitLabel() == "pet" and caster.owner and caster.owner.healingdone then
 		caster.owner.healingdone = caster.owner.healingdone + event.heal
    end
    --print("healing for " .. event.heal)

    -- display fx
    if event.hidenumber ~= nil then
    	displaynumber = false
    else
    	CriticalStrikeFX(nil, target, event.heal, 0, displaynumber)
    end

    --proc
    if event.oncritbuff and was_crit then
        local buffTarget = caster
        if event.oncritbuffnotself and target then
            buffTarget = target
        end
        if not event.oncritbuffchance then
            ability:ApplyDataDrivenModifier(caster, buffTarget, event.oncritbuff, nil)
        else
            if math.random(1,100) <= event.oncritbuffchance then
                ability:ApplyDataDrivenModifier(caster, buffTarget, event.oncritbuff, nil)
            end
        end
    end

    if was_crit then
        HealCrit(caster, target, ability)
    end


    --special effect for guardian
    if 	event.FromGuardian ~= nil then
    	local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_omniknight/omniknight_purification.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
		ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 1, Vector(100,0,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end

    --soulpact
    if target and target.soul_pact_heal and target.soul_pact_heal:HasModifier("modifier_dh_soulpact_heal") and not event.FromSoulPact then
        local myevent = {}
        myevent.caster = target
        myevent.target = target.soul_pact_heal
        myevent.FromSoulPact = 1
        myevent.heal = event.heal / 4
        myevent.ability = target:FindAbilityByName("terror4")
        if myevent.ability then
            local particle = ParticleManager:CreateParticle("particles/starsurge.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
            ParticleManager:SetParticleControl(particle, 1, target.soul_pact_heal:GetAbsOrigin() + Vector(0,0,50))
            ParticleManager:ReleaseParticleIndex(particle)
            HealUnit(myevent)
        end
    end

    HealProcs(caster, target, event.isdot)

    if caster:HasModifier("modifier_guardian_self") and event.FromGuardian ~= 1 then
        local all = HeroList:GetAllHeroes()
        for i=1, #all do
            if all[i] and all[i] ~= target and all[i]:HasModifier("modifier_guardian") then
            	local myevent = {}
                myevent.caster = caster
                myevent.target = all[i]
                myevent.FromGuardian = 1
        		myevent.attributefactor = 0.0
        		myevent.spelldamagefactor = 0.0
                myevent.heal = event.heal
                myevent.isaoeheal = 1
                myevent.ability = ability
                HealUnit(myevent)
            end
    	end
    end

    -- sp heal bonus seperate target
    if event.alwaysself ~= nil then
    	if caster ~= target then
    		event.target=caster
    		event.attributefactor = 0.0
    		event.spelldamagefactor = 0.0
    		event.heal = event.heal*event.alwaysself
    		event.alwaysself = nil
    		HealUnit(event)
    	end
    end
end

function Arcane5(event)
	local caster = event.caster
	local target = event.target
	if target:GetTeamNumber() == caster:GetTeamNumber() then
  		ApplyBuff(event)
	else
		event.buff = "modifier_arcane_asslow"
		ApplyBuff(event)
	end
end

function Bookoflight(event)
	local caster = event.caster
	local a = event.event_ability
	if a then
		if a:GetManaCost(a:GetLevel()) > 0.0 then
			Timers:CreateTimer(0.05,function() 
	        	caster:SetMana(caster:GetMana()+2)
	    	end)
		end
	end
end

function RestoreResource( event)
    local caster = event.caster
    if IsManaHero(caster) or caster:HasModifier("modifier_catform_off") then
        RestoreMana(event)
    else
        if event.flat then
            AddEnergy({caster = caster, energy = event.amount, cap = event.cap})
        else
            AddEnergy({caster = caster, energy = event.amount, energypercent = 1, cap = event.cap})
        end
    end
end

function RestoreMana( event)
	local caster = event.caster
	if event.affectunit then
		caster = event.unit
	end
	local manaclass = true
	local amount = event.amount
	if event.percent and not event.flat then
		amount = caster:GetMaxMana()*event.amount/100
	end
	if event.affectmanaform and caster:HasModifier("modifier_catform") and caster.OldMana then
		caster.OldMana = caster.OldMana+amount
	else
		if caster.Energy then
			manaclass = false
		end
		if manaclass or caster:HasModifier("modifier_catform_off") then
			caster:SetMana(caster:GetMana()+amount)
		end
	end

	if event.spfx ~= nil then
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_templar_assassin/templar_assassin_refraction_ring_base.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
	end
end

function PayWithLife( event)
	caster = event.caster
	local reduce = event.life
	if event.percent ~= nil then
		reduce = caster:GetMaxHealth()*event.life/100
	end
	if caster:GetHealth() < reduce then
		caster:SetHealth(1)
	else
		caster:SetHealth(caster:GetHealth()-reduce)
	end
end

function GetSpellhaste( caster, event )
    local speedbonus = 0
    local mods = caster:GetModifierCount()-1
    for i=0, mods do
        local name = caster:GetModifierNameByIndex(i)
        if name == "modifier_itemhaste20" then
            speedbonus = speedbonus + 0.3
        end
        if name == "modifier_item_active5up" then
            speedbonus = speedbonus + 0.2
        end
        if name == "modifier_item_hasteproc" then
            speedbonus = speedbonus + 0.25
        end
        if name == "modifier_bloodlust_ele" then
            speedbonus = speedbonus + 1
        end
        if name == "modifier_bloodlust_ele_monster" then
            speedbonus = speedbonus + 0.5
        end
        if name == "modifier_activemage" then
            speedbonus = speedbonus + 0.25
        end
        if name == "modifier_itemhastebow" then
            speedbonus = speedbonus + 0.25
        end
        if name == "modifier_item_hunterbow" then
            speedbonus = speedbonus + 0.25
        end
        if name == "modifier_item_hunterbow2" then
            speedbonus = speedbonus + 0.5
        end
        if name == "modifier_hasteproc25" then
            speedbonus = speedbonus + 0.75
        end
        if name == "modifier_active5up_haste" then
            speedbonus = speedbonus + 0.25
        end
        if name == "modifier_item_spellhaste_2" then
            speedbonus = speedbonus + 0.5
        end
        if name == "modifier_druid_ms" then
            speedbonus = speedbonus + 0.25
        end
        if name == "modifier_itemhaste50" then
            speedbonus = speedbonus + 0.75
        end
        if name == "modifier_spellhaste_50" then
            speedbonus = speedbonus + 1
        end
        if name == "modifier_stormcrow" then
            speedbonus = speedbonus + 1
        end
        if name == "modifier_itemhaste100" then
            speedbonus = speedbonus + 0.75
        end
        if name == "modifier_itemhaste100_2" then
            speedbonus = speedbonus + 1
        end
        if name == "modifier_as_aura_dragon" then
            speedbonus = speedbonus + 0.5
        end
        if name == "modifier_item_bloodlust" then
            speedbonus = speedbonus + 0.75
        end
        if name == "modifier_item_bloodlust_proc" then
            speedbonus = speedbonus + 1
        end
        if name == "modifier_full_moon" then
            speedbonus = speedbonus + 1
        end
        if name == "modifier_item_bloodlust_2" then
            speedbonus = speedbonus + 1.5
        end
        if name == "modifier_item_bloodlust_proc_2" then
            speedbonus = speedbonus + 2
        end
        if name == "modifier_element_fire" then
            speedbonus = speedbonus + 0.5
        end
        if name == "modifier_divine_haste" then
            speedbonus = speedbonus + 2
        end
        if name == "modifier_item_agihaste_2" or name == "modifier_item_agihaste" then
            speedbonus = speedbonus + 0.0075 * GetAgilityCustom(caster)
        end
        if name == "modifier_whiterobe2" then
            speedbonus = speedbonus + GetStrengthCustom(caster) / 100
        end
        if name == "modifier_whiterobe" then
            speedbonus = speedbonus + GetStrengthCustom(caster) / 200
        end
        local shadow_stance_cleric = caster:GetModifierStackCount("modifier_shadow_stance", nil)
        if shadow_stance_cleric > 0 and name == "modifier_shadow_stance" then
            speedbonus = speedbonus + 0.05 * shadow_stance_cleric
        end
        local keeper1_stacks = caster:GetModifierStackCount("modifier_keeper_spellhaste", nil)
        if keeper1_stacks > 0 and name == "modifier_keeper_spellhaste" then
            speedbonus = speedbonus + 0.15 * keeper1_stacks
        end
    end
    local warlock_haste_talent = caster:FindAbilityByName("Fear_Warlock")
    if warlock_haste_talent and warlock_haste_talent:GetLevel() >= 3 then
        speedbonus = speedbonus + 0.25
    end
    if (heroName == "npc_dota_hero_furion" and caster:GetAbilityByIndex(5):GetLevel() >= 4) then
        speedbonus = speedbonus + 1
    end
    if caster:HasModifier("modifier_bloodflow") then
        speedbonus = speedbonus + 2.5
    end
    if caster:HasModifier("modifier_soulcoil_haste") then
        speedbonus = speedbonus + 0.75
    end
    if caster:HasModifier("modifier_mana_shield") then
        speedbonus = speedbonus + 0.75
    end
    if caster:HasModifier("modifier_shadow_rage") then
        speedbonus = speedbonus + 2.5
    end
    if caster:HasModifier("modifier_druid_as_buff") then
        speedbonus = speedbonus + 0.5
    end
    if caster:HasModifier("modifier_stormbringer") then
        speedbonus = speedbonus + 5
    end
    if caster:HasModifier("modifier_elune_grace") then
        speedbonus = speedbonus + 0.25
    end
    if HeroHasNeutralItem(caster, "item_neutral_38") then
        speedbonus = speedbonus + 0.5
    end
    if (event.hastebonus and event.hastebonus == 25) then
        speedbonus = speedbonus + 0.25
    end
    if GetLevelOfAbility(caster, "Lightning_Storm") >= 3 then
        speedbonus = speedbonus + caster:GetPhysicalArmorValue(false) / 100
    end
    if GetLevelOfAbility(caster, "ench1") >= 3 then
        speedbonus = speedbonus + 0.5
    end
    if caster.talents and caster.talents[15] then
        speedbonus = speedbonus + caster.talents[15] * 0.2
    end
    speedbonus = speedbonus + 0.01 * caster:GetModifierStackCount("modifier_mythic_sph", nil)
    if caster.talents and caster.talents[119] and caster.talents[119] > 0 then
        local factor = 0.005
        if caster:HasModifier("modifier_stormgiant") then
            factor = factor * 2
        end
        local passiveASBonus = caster:GetAttackSpeed(true) * 100 - 100
        local bonus = passiveASBonus * factor
        if bonus > 0 then
            speedbonus = speedbonus + bonus
        end
    end
    if caster.talents and caster.talents[26] and caster.talents[26] > 0 then
        local int_to_haste = 0.0003 * caster.talents[26] * GetIntellectCustom(caster)
        local haste_cap = 0.7 + 0.1 * caster.talents[26]
        if int_to_haste > haste_cap then
            int_to_haste = haste_cap
        end
        speedbonus = speedbonus + int_to_haste
    end
    if caster.talents and caster.talents[32] and caster.talents[32] > 0 then
        speedbonus = speedbonus + 0.3 * caster.talents[32]
    end
    if caster.spellhaste_system_bonus and caster.spellhaste_system_bonus > 0 then
        speedbonus = speedbonus + caster.spellhaste_system_bonus / 100
    end
    return speedbonus
end

function ChannelManaFixStart( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local heroName = caster:GetUnitName()
    --caster:GiveMana(event.mana)  

    if event.requires_souls then
        if not caster.souls or not (caster.souls >= event.requires_souls) then
            ability:ApplyDataDrivenModifier(caster, caster, "modifier_silence", {Duration = 0.1})
        end
    end
    if caster.Castbar ~= nil then
    	ParticleManager:DestroyParticle(caster.Castbar,true)
        ParticleManager:ReleaseParticleIndex(caster.Castbar)
    end
    local particle = nil

    ability.wasinstant = false
    ability.is_casttime_ability = true

    --first reset if it has ever been changed
    if ability.originalcastpoint ~= nil then
    	ability:SetOverrideCastPoint(ability.originalcastpoint)
    end
    --invis fix patrol and ambush
    if caster:HasModifier("modifier_invisible") then
        caster:RemoveModifierByName("modifier_invisible")
    end

    --handle instant casttime, warlock item
    local isalreadyinstant = 0
    if event.casttimeadjust ~= nil then
    	ability.warlockinstant = 0
    	if caster:HasModifier("modifier_activewarlock") then
    		if ability.originalcastpoint == nil then
    			ability.originalcastpoint = ability:GetCastPoint()
	    	end
	    	isalreadyinstant = 1
	    	ability.warlockinstant = 1
	    	local castpoint = 0.2
	    	event.casttime = castpoint
	    	ability:SetOverrideCastPoint(castpoint)
    	end
    end
    if isalreadyinstant == 0 and event.instantcast and event.instantcast == 1 then
        if ability.originalcastpoint == nil then
            ability.originalcastpoint = ability:GetCastPoint()
        end
        ability.wasinstant = true
        isalreadyinstant = 1
        local castpoint = 0.2
        event.casttime = castpoint
        ability:SetOverrideCastPoint(castpoint)
    end
    local reload = caster:GetModifierStackCount("modifier_lockreload", caster)
	if isalreadyinstant == 0 and reload >= 10 then
        if ability:GetName() == "wind7" then
            if ability.originalcastpoint == nil then
                ability.originalcastpoint = ability:GetCastPoint()
            end
            ability.wasinstant = true
            isalreadyinstant = 1
            local castpoint = 0.2
            event.casttime = castpoint
            ability:SetOverrideCastPoint(castpoint)
        end
        if reload >= 11 then
            caster:SetModifierStackCount("modifier_lockreload", caster:GetAbilityByIndex(1), reload-10)
        else
            caster:RemoveModifierByName("modifier_lockreload")
        end
        
	end
	--priest proc
	local priestcharge = caster:GetModifierStackCount("modifier_light_charge", caster)
	if isalreadyinstant == 0 and priestcharge >= 4 and ability:GetName() == "Light_of_Heaven" then
		if ability.originalcastpoint == nil then
			ability.originalcastpoint = ability:GetCastPoint()
    	end
    	ability.wasinstant = true
    	isalreadyinstant = 1
    	local castpoint = 0.2
    	event.casttime = castpoint
    	ability:SetOverrideCastPoint(castpoint)
	end
    --retri proc
    local retricharge = caster:GetModifierStackCount("modifier_fanatism", nil)
    if isalreadyinstant == 0 and retricharge >= 10 and event.retriinstant then
        if ability.originalcastpoint == nil then
            ability.originalcastpoint = ability:GetCastPoint()
        end
        ability.wasinstant = true
        isalreadyinstant = 1
        local castpoint = 0.2
        event.casttime = castpoint
        ability:SetOverrideCastPoint(castpoint)
    end
	--druid lifebloom proc
	if target then
		local lifebloomfull = target:HasModifier("modifier_lifebloomfull")
        local lifebloomcharges = target:GetModifierStackCount("modifier_lifebloom", nil)
		if isalreadyinstant == 0 and event.instantlifebloom and event.instantlifebloom == 1 and (lifebloomfull or lifebloomcharges >= 3) and ability:GetName() == "Regrowth" then
			if ability.originalcastpoint == nil then
				ability.originalcastpoint = ability:GetCastPoint()
	    	end
	    	ability.wasinstant = true
	    	isalreadyinstant = 1
	    	local castpoint = 0.2
	    	event.casttime = castpoint
	    	ability:SetOverrideCastPoint(castpoint)
		end
	end
	--moonkin instant roots
	local mooncharge = caster:GetModifierStackCount("modifier_suncharge", caster)
	if isalreadyinstant == 0 and event.rootinstant and mooncharge >= 5 then
		if ability.originalcastpoint == nil then
			ability.originalcastpoint = ability:GetCastPoint()
    	end
    	ability.wasinstant = true
    	isalreadyinstant = 1
    	local castpoint = 0.2
    	event.casttime = castpoint
    	ability:SetOverrideCastPoint(castpoint)
	end

	local instantbolt = caster:GetModifierStackCount("modifier_instantbolt", nil)
	if isalreadyinstant == 0 and instantbolt > 0 then
        if instantbolt == 1 then
            caster:RemoveModifierByName("modifier_instantbolt")
        else
            caster:SetModifierStackCount("modifier_instantbolt", event.ability, instantbolt-1)
        end
		if ability.originalcastpoint == nil then
			ability.originalcastpoint = ability:GetCastPoint()
    	end
    	ability.wasinstant = true
    	isalreadyinstant = 1
    	local castpoint = 0.2
    	event.casttime = castpoint
    	ability:SetOverrideCastPoint(castpoint)
	end
	if isalreadyinstant == 0 and caster.book_of_runes_instants and caster.book_of_runes_instants > 0 then
		caster.book_of_runes_instants = caster.book_of_runes_instants - 1
		if caster.book_of_runes_ability then
			caster:SetModifierStackCount("modifier_book_instant_casts", caster.book_of_runes_ability, caster.book_of_runes_instants)
		end
		if ability.originalcastpoint == nil then
			ability.originalcastpoint = ability:GetCastPoint()
    	end
    	ability.wasinstant = true
    	isalreadyinstant = 1
    	local castpoint = 0.2
    	event.casttime = castpoint
    	ability:SetOverrideCastPoint(castpoint)
	end

    local channel = ability:GetChannelTime()

    local speedbonus = GetSpellhaste(caster, event)
    local slowbonus = 0
    if caster:HasModifier("modifier_cripple_curse") then
        slowbonus = slowbonus + 1
    end
    if caster:HasModifier("modifier_mindnumb") then
        slowbonus = slowbonus + 0.2
    end

    --local castpoint
   	if isalreadyinstant == 0 and channel <= 0.1 then
        --set spell data
        caster.spellhaste = speedbonus
        if ability.originalcastpoint == nil then
            ability.originalcastpoint = ability:GetCastPoint()
        end
        local castpoint = ability:GetCastPoint()
        if caster:HasModifier("modifier_itemhaste100_2") then
            castpoint = castpoint - 0.25
        end
        if caster:HasModifier("modifier_pathbuff_119") then
            castpoint = castpoint - 0.5
        end
        if caster:HasModifier("modifier_pathbuff_104") then
            castpoint = castpoint - 0.25
        end
        castpoint = castpoint * (1 + slowbonus) / ( 1 + speedbonus)
        event.casttime = castpoint
        ability:SetOverrideCastPoint(castpoint)
	end


    if event.casttime ~= nil then
    	--print("casttime " .. event.casttime)
    	if event.casttime == 2.5 then
    		particle = ParticleManager:CreateParticle("particles/castbar25.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
    	elseif event.casttime >= 5 then
    		particle = ParticleManager:CreateParticle("particles/castbar5.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 0.35 then --almost instant, wont be noticable
			particle = ParticleManager:CreateParticle("particles/castbar02.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 1.77 and event.casttime >= 1.63 then
			particle = ParticleManager:CreateParticle("particles/castbar16.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 1.96 and event.casttime >= 1.78 then
			particle = ParticleManager:CreateParticle("particles/castbar1.92.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 2.45 and event.casttime >= 2.3 then
			particle = ParticleManager:CreateParticle("particles/castbar2.4.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 1.62 and event.casttime >= 1.53 then
			particle = ParticleManager:CreateParticle("particles/castbar160.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 1.52 and event.casttime >= 1.3 then
			particle = ParticleManager:CreateParticle("particles/castbar14.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 2.2 and event.casttime >= 2.03 then
			particle = ParticleManager:CreateParticle("particles/castbar21.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime == 1 then
			particle = ParticleManager:CreateParticle("particles/castbar1.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		elseif event.casttime <= 2.02 and event.casttime >= 1.98 then
			particle = ParticleManager:CreateParticle("particles/castbar.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
    	elseif event.casttime <= 3.25 and event.casttime >= 2.75 then
    		particle = ParticleManager:CreateParticle("particles/castbar3.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        elseif event.casttime >= 0.36 and event.casttime < 0.5 then
            particle = ParticleManager:CreateParticle("particles/castbar04.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        elseif event.casttime >= 0.5 and event.casttime < 0.7 then
            particle = ParticleManager:CreateParticle("particles/castbar06.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        elseif event.casttime >= 0.7 and event.casttime < 0.9 then
            particle = ParticleManager:CreateParticle("particles/castbar08.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        elseif event.casttime >= 0.9 and event.casttime < 1.1 then
            particle = ParticleManager:CreateParticle("particles/castbar10.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        elseif event.casttime >= 1.1 and event.casttime < 1.3 then
            particle = ParticleManager:CreateParticle("particles/castbar12.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
    	end
    else
    	particle = ParticleManager:CreateParticle("particles/castbar.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
    	--particle = ParticleManager:CreateParticle("particles/castbardynamic.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
    	--ParticleManager:SetParticleControl(particle, 1, Vector(0.3,0,0))
    end

    --if particle then
    --    ParticleManager:ReleaseParticleIndex(particle)
    --end
    
    --print("casttime "..event.casttime)
    --Set IsCasting
    caster.IsCasting = 1
    caster.Castbar = particle

    if caster:HasAbility("pveboss_system") then
        particle = ParticleManager:CreateParticle("particles/techies_suicide_dud_arcana_skull.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:SetParticleControlEnt(particle, 3, caster, PATTACH_POINT_FOLLOW, "attach_origin", caster:GetAbsOrigin(), true)
        ParticleManager:ReleaseParticleIndex(particle)
        --particle = ParticleManager:CreateParticle("particles/units/heroes/hero_oracle/oracle_false_promise_dmg_burst.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
    end

    --no longer change animation cuz of startpoint use
    --if event.ability:GetName() == "Snipe" then
    	--StartAnimation(caster, {activity=ACT_DOTA_CAST_ABILITY_4, duration=2.0, rate=0.5})
    --elseif event.ability:GetName() == "RootsDruid" or event.ability:GetName() == "CycloneDruid" then
    	--StartAnimation(caster, {activity=ACT_DOTA_CAST_ABILITY_4, duration=2.0, rate=0.5})
    --else
    	--StartAnimation(caster, {activity=ACT_DOTA_ATTACK, duration=2.0, rate=0.3})
    --end

    --aggro
    if caster and target and caster:IsRealHero() then
        local myevent = {}
        myevent.unit = target
        myevent.attacker = caster
        myevent.damagetaken = 5
        COverthrowGameMode:PVEAggroAdd(myevent)
    end
end

function ChannelInterrupt( event )
    local caster = event.caster
    local ability = event.ability
    caster.IsCasting = 0
    caster.is_channeling = false
    StopAllChannels(caster)
    EndAnimation(caster)
    if caster.Castbar ~= nil then
    	ParticleManager:DestroyParticle(caster.Castbar,true)
        ParticleManager:ReleaseParticleIndex(caster.Castbar)
    end

    --[[if ability.originalcastpoint ~= nil then
	    if ability:GetCastPoint() ~= ability.originalcastpoint then
	    	ability:SetOverrideCastPoint(ability.originalcastpoint)
	    	print("resetting castpoint")
	    end
	end]]
    

end

function StopAllChannels( caster )
    if caster.channelCastID and caster.channelCasts then
        for i=1, caster.channelCastID - 1 do
            caster.channelCasts[i] = false
        end
    end
end

function ChannelManaFixEnd( event )
    local caster = event.caster
    local ability = event.ability

    caster.IsCasting = 0
    caster.is_channeling = false
    if caster.Castbar ~= nil then
    	ParticleManager:DestroyParticle(caster.Castbar,true)
        ParticleManager:ReleaseParticleIndex(caster.Castbar)
    end

    if ability.warlockinstant ~= nil then
    	if ability.warlockinstant == 1 then
    		caster:RemoveModifierByName("modifier_activewarlock")
    	end
    end

    --event.is_end_of_channel = true

    --[[if ability.originalcastpoint ~= nil then
	    if ability:GetCastPoint() ~= ability.originalcastpoint then
	    	ability:SetOverrideCastPoint(ability.originalcastpoint)
	    	print("resetting castpoint")
	    end
	end]]
end

function round(num)
    return math.floor(num+.5)
end

function TalentBlinkPassive( event )
	local ability = event.event_ability
    local caster = event.caster
    event.ability = caster:FindAbilityByName("Fire_Lance")
    if event.ability then
        event.buff = "modifier_lavalance_proc"
        event.target = caster
        event.aoe = 600
        event.dontbreakccbuff = 1
        ApplyBuffAOE(event)
        event.buff = "modifier_lavalance_proc_delay"
        ApplyBuffAOE(event)
    end
    
    --[[old stuff
	if event.dmgtaken then
        local blinkability = event.caster:GetAbilityByIndex(5)
		if blinkability and blinkability:GetLevel() >= 4 and event.dmgtaken > event.caster:GetMaxHealth()*0.15 then
  			blinkability:EndCooldown()
  			local particle = ParticleManager:CreateParticle("particles/econ/events/ti5/blink_dagger_end_ti5.vpcf", PATTACH_POINT_FOLLOW, event.caster)
  			EmitSoundOn("DOTA_Item.ClarityPotion.Activate", event.caster)
		end
		return
	end
	if ability:GetName() == "antimage_blink" then
		local caster = event.caster
        if ability:GetLevel() >= 2 then
            local myevent = {}
            myevent.caster = event.caster
            myevent.target = event.caster
            myevent.ability = caster:GetAbilityByIndex(3)
            myevent.buff = "modifier_reduction_50"
            myevent.dur = 3
            ApplyBuff(myevent)
        end
        
		if ability:GetLevel() >= 3 then
			event.ability = caster:GetAbilityByIndex(1)
			event.buff = "modifier_lavalance_proc"
			event.target = caster
			event.aoe = 600
			event.dontbreakccbuff = 1
			ApplyBuffAOE(event)
			event.buff = "modifier_lavalance_proc_delay"
			ApplyBuffAOE(event)
		end
		if ability:GetLevel() >= 2 then
			RemoveSlows(event)
		end
	end
    --]]
end

function LavaLanceProc( event )
	local caster = event.caster
	local target = event.attacker
    local lavalance = caster:FindAbilityByName("Fire_Lance")
    if lavalance then
        lavalance:ApplyDataDrivenModifier(caster, target, "modifier_lavalance_proc", nil)
    end
end

function OutOfCombat( event )
    if event.onflamebasher then
        event.caster.ooc = 8
        event.caster:RemoveModifierByName("modifier_oocmana")
    end
    if event.onattacked then
        event.attacker.ooc = 8
        event.caster.ooc = 8
        event.attacker:RemoveModifierByName("modifier_oocmana")
        event.caster:RemoveModifierByName("modifier_oocmana")
    end
	if event.onattack then
		event.attacker.ooc = 8
		event.target.ooc = 8
		event.attacker:RemoveModifierByName("modifier_oocmana")
		event.target:RemoveModifierByName("modifier_oocmana")
	end
	if event.onspell ~= nil then
		local ability = event.event_ability
		if ability:GetName() == "ShapeshiftFeral" or ability:GetName() == "Shapeshift" or ability:GetName() == "item_bootsswiftup" then
			return
		end
		event.caster.ooc = 8
		event.caster:RemoveModifierByName("modifier_oocmana")
		--if event.target ~= nil then
			--print(event.target:GetName())

		--	event.target.ooc = 8
		--	event.target:RemoveModifierByName("modifier_oocmana")
		--end
	end
	--print(caster:GetName())
end

function RemoveOutOfCombat( event )
	local caster = event.caster
	caster.ooc = 8
	caster:RemoveModifierByName("modifier_oocmana")
	--print(caster:GetName())
end

function StartLoopSound( event )
    local caster = event.caster
	EmitSoundOn(event.sound, caster)
end

function StopLoopSound( event )
    local caster = event.caster
    StopSoundOn(event.sound, caster)
end

function SetChannelTarget( event )
    local caster = event.caster
    local target = event.target
    caster.channeltarget = target
end

function StopChannelTarget( event )
    local caster = event.caster
    local target = caster.channeltarget
    if target and not target:IsNull() then
        target:RemoveModifierByName(event.buff)
    end
end

function DruidTalentManaregen( event )
    local caster = event.caster
	local mana = caster:GetConstantBasedManaRegen() + caster:GetStatsBasedManaRegen()
	mana = math.floor(mana * event.percent / 10)
	caster:RemoveModifierByName("modifier_shapeshifttravel_mana_value")
	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_shapeshifttravel_mana_value", nil)
	caster:SetModifierStackCount("modifier_shapeshifttravel_mana_value", event.ability, mana)
end

function DruidTalentAOERoots( event )
    local caster = event.caster
    local target = event.target
    if event.dur and event.dur > 0 then
        local entangle_ability_for_talents = caster:FindAbilityByName("RootsDruid")
        if entangle_ability_for_talents then
            event.ability = entangle_ability_for_talents
        end
    	event.buff = "modifier_rootsdruid"
    	CCTarget(event)
    	if event.ability:GetLevel() >= 4 and entangle_ability_for_talents then
    		event.buff = "modifier_mindnumb"
    		event.dur = 15
    		CCTarget(event)
    	end
    end
end

function OutOfCombatCounter( event )
	local caster = event.caster

    --[[
	if caster:HasModifier("modifier_item_aether_lens") then
		if caster:HasModifier("modifier_oocmana") then
			event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_aether_lens_mana", nil)
			event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_aether_lens_mana", nil)
			--caster:SetMana(caster:GetMana()+2)
		else
			event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_aether_lens_mana", nil)
			--caster:SetMana(caster:GetMana()+1)
		end
	end]]
	if caster.OOCCounter ~= 1 or event.OOCCounterallow ~= nil then
		caster.OOCCounter = 1
		event.OOCCounterallow = 1
		if caster.ooc == nil then
			caster.ooc = 8
		end
		caster.ooc = caster.ooc - 1
		if caster.ooc < 0 then
			caster.ooc = 0
		end
		--print(caster:GetName())
		--print(caster.ooc)
		if caster.ooc == 0 then
			--mount
			local heroName = caster:GetUnitName()
            local mount_speed = 50
            if caster:HasModifier("modifier_snowl2") or caster:HasModifier("modifier_item_myth_def") or caster:HasModifier("modifier_moonlighttiger") or caster:HasModifier("modifier_pathbuff_014") or caster:HasModifier("modifier_pathbuff_018") or caster:HasModifier("modifier_item_crit_frost_immortal2") or caster:HasModifier("modifier_item_bootscrit3") or caster:HasModifier("modifier_item_bootscrit4") or caster:HasModifier("modifier_crusader_mount") then --caster.hasmount and caster.hasmount == 2 then
                mount_speed = 75 --45
            end
			if caster:HasModifier("modifier_snowl") or caster:HasModifier("modifier_item_bootscrit2") or caster:HasModifier("modifier_item_lotusguard2") or caster:HasModifier("modifier_item_crit_frost_immortal") or caster:HasModifier("modifier_item_bootsblood3") then --heroName == "npc_dota_hero_mirana" or heroName == "npc_dota_hero_abaddon" or heroName == "npc_dota_hero_chen" or heroName == "npc_dota_hero_disruptor" or caster:HasModifier("modifier_mount_standard") or (caster.hasmount and caster.hasmount == 1) then
                mount_speed = 65 --30
			end
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_mount_speed", nil)
            caster:SetModifierStackCount("modifier_mount_speed", event.ability, mount_speed)
            
			--homeland speed
			if COverthrowGameMode.GameState == 4 then
				if caster:HasModifier("modifier_fountain_aura_buff") then
					event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_homeland_speed", nil)
				end
			end

			if caster.oocmana > 0 or GetMapName() == "10vs10_city_raid" or COverthrowGameMode.junglemode then
				event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_oocmana", nil)
			end
			local nightbladebonus = 0
			if caster:HasModifier("modifier_item_nightblade") or caster:HasModifier("modifier_item_rogueblades") then
				nightbladebonus = 1
			end
			if caster.oocmana == 2 then
				--stealth users here
				local ability = caster:GetAbilityByIndex(5)
				if ability ~= nil then
					local cdremaining = ability:GetCooldownTimeRemaining()
					if cdremaining > 0.1 and not caster:HasModifier("modifier_stealthrogue") then
						ability:EndCooldown()
						ability:StartCooldown(cdremaining-(3+nightbladebonus))
						local particle = ParticleManager:CreateParticle("particles/items3_fx/glimmer_cape_initial_flash_smoke.vpcf", PATTACH_POINT_FOLLOW, caster)
                        ParticleManager:ReleaseParticleIndex(particle)
					end
 					--if ability:GetCooldownTimeRemaining() <= 10.0 and ability:GetCooldownTimeRemaining() > 0.1 then
 					--	ability:EndCooldown()
 					--	local particle = ParticleManager:CreateParticle("particles/econ/events/ti4/blink_dagger_steam_ti4.vpcf", PATTACH_POINT_FOLLOW, caster)
 					--end
				end
			end
			if caster.oocmana == 3 then
				--feral druid here
				local ability = caster:GetAbilityByIndex(3)
				if ability ~= nil then
					local cdremaining = ability:GetCooldownTimeRemaining()
					if cdremaining > 0.1 and not caster:HasModifier("modifier_stealthcat") then
						ability:EndCooldown()
						ability:StartCooldown(cdremaining-(3+nightbladebonus))
						local particle = ParticleManager:CreateParticle("particles/items3_fx/glimmer_cape_initial_flash_smoke.vpcf", PATTACH_POINT_FOLLOW, caster)
                        ParticleManager:ReleaseParticleIndex(particle)
					end
					--print(ability:GetName())
 					--if ability:GetName() == "Feral1" and ability:GetCooldownTimeRemaining() > 0.1 and ability:GetCooldownTimeRemaining() <= 10.0 then
 					--	ability:EndCooldown()
 					--	local particle = ParticleManager:CreateParticle("particles/econ/events/ti4/blink_dagger_steam_ti4.vpcf", PATTACH_POINT_FOLLOW, caster)
 					--end
				end
			end
		else
			caster:RemoveModifierByName("modifier_mount_speed")
            caster:RemoveModifierByName("modifier_mount_speed_epic")
		end
		Timers:CreateTimer(1.0,function() 
        	OutOfCombatCounter(event)
    	end)
	end
end

function OutOfCombatManaReg( event )
	local caster = event.caster
	local oldpos = caster.OOCPosition
	if oldpos ~= nil then
		local distance = (oldpos-caster:GetAbsOrigin()):Length()
		if distance < 25.0 and (caster.oocmana == 1 or caster.oocmana == 3) then
			local amount = 0.03
			if COverthrowGameMode.junglemode then
				amount = 0.05
			end
			caster:SetMana(caster:GetMana()+caster:GetMaxMana()*amount)
			if (COverthrowGameMode.GameState >= 2 or COverthrowGameMode.junglemode) and caster:GetMana() / caster:GetMaxMana() < 1.0 then
				local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_obsidian_destroyer/obsidian_destroyer_sanity_eclipse_mana_loss.vpcf", PATTACH_POINT_FOLLOW, caster)
				ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
				ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
                ParticleManager:ReleaseParticleIndex(particle)
			end
		end
		if distance < 25.0 and (GetMapName() == "10vs10_city_raid" or COverthrowGameMode.junglemode) and caster:GetHealth() / caster:GetMaxHealth() < 1.0 then
			--city raid hp regen
			--if GetMapName() == "10vs10_city_raid" then
                HealUnit({caster = caster, target = caster, ability = event.ability, heal = caster:GetMaxHealth()*0.03, ignore_temple_class_penalty = true})
				--caster:SetHealth(caster:GetHealth()+caster:GetMaxHealth()*0.03)
				local particle = ParticleManager:CreateParticle("particles/generic_gameplay/generic_lifesteal.vpcf", PATTACH_POINT_FOLLOW, caster)
                ParticleManager:ReleaseParticleIndex(particle)
		  	--end
		end
	end
	caster.OOCPosition = caster:GetAbsOrigin()
end

function GameMechanics:DamageTaken(event)
	--print("damage taken")
	--print(event.damage)
end

SwitchStancesLvl1 = {0,0,0,0,0,0,0,0,0,0}
SwitchStancesLvl2 = {0,0,0,0,0,0,0,0,0,0}
SwitchStancesLvl3 = {0,0,0,0,0,0,0,0,0,0}

-- Warrior -------------------------------------------------------------------------------------------------------------------------------------------------------------

function ShieldReflect(event)
	--DeepPrintTable(event)

	local caster = event.caster
	local target = event.attacker
	local damage = event.dmg
	--print(event.ability)
    --make totem not imune in reflect zone
    if caster:HasModifier("modifier_affix_totem_aura") then
        return
    end
    if not event.dontheal then
	   caster:Heal(damage, caster)
    end
	if target:HasModifier("modifier_shieldreflect") then

	else
		if event.lowcondition and caster:GetHealth()/caster:GetMaxHealth() >= event.lowcondition/100.0 then
            return
        end
        if event.returnfactor then
            damage = damage * event.returnfactor / 100
        end
        if damage > caster:GetMaxHealth()*0.25 then
            damage = caster:GetMaxHealth()*0.25
        end
        if event.attackerhpcap and damage > target:GetMaxHealth() * event.attackerhpcap then
            damage = target:GetMaxHealth()*event.attackerhpcap
        end
        event.damage = damage
		event.target = target
		--event.ability = caster:GetAbilityByIndex(5)
		event.attributefactor = 0.0
        event.spelldamagefactor = 0.0
        event.cannotcrit = 1
        event.isreflected = true
        event.changedmgtypetomagical = 1
    	DamageUnit(event)
    end
end

function FixCDStance(event)
	--print("charge test")
end

function SwitchStances(event)
	local hero = event.caster
	local abil1 = hero:GetAbilityByIndex(0)
	local abil2 = hero:GetAbilityByIndex(1)
	local abil3 = hero:GetAbilityByIndex(2)
	local id = hero:GetPlayerOwnerID()+1

	if abil1:GetAbilityName() == "Wounding_Strike" then
		--print("to defensive")
		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_defstance", nil)
		SwitchStancesLvl1[id]=abil1:GetLevel()
		SwitchStancesLvl2[id]=abil2:GetLevel()
		SwitchStancesLvl3[id]=abil3:GetLevel()

  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:RemoveAbility(abil3:GetAbilityName())

  		hero:AddAbility("WarriorCharge")
  		hero:FindAbilityByName("WarriorCharge"):SetLevel(hero:FindAbilityByName("Switch_Battle_Stance"):GetLevel())
  		hero:AddAbility("Shield_Reflect")
  		hero:FindAbilityByName("Shield_Reflect"):SetLevel(hero:FindAbilityByName("Switch_Battle_Stance"):GetLevel())
  		hero:AddAbility("Terror_Shout")
  		hero:FindAbilityByName("Terror_Shout"):SetLevel(hero:FindAbilityByName("Switch_Battle_Stance"):GetLevel())
  	else
  		--print("to offensive")
  		hero:RemoveModifierByName("modifier_defstance")
  		-- fix crash on switch while charging
		if hero:HasModifier("modifier_WarriorCharge") then
	 		Timers:CreateTimer(1.0,function() 
		        fixChargeStanceSwitch(hero)
		    end)
		else
	  		hero:RemoveAbility(abil1:GetAbilityName())
	  		hero:AddAbility("Wounding_Strike")
	  		hero:FindAbilityByName("Wounding_Strike"):SetLevel(SwitchStancesLvl1[id])
		end

  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:AddAbility("Mortal_Swing")
  		hero:FindAbilityByName("Mortal_Swing"):SetLevel(SwitchStancesLvl2[id])

  		hero:RemoveAbility(abil3:GetAbilityName())
  		hero:AddAbility("Concussive_Blow")
  		hero:FindAbilityByName("Concussive_Blow"):SetLevel(SwitchStancesLvl3[id])
  		
  	end
end

function fixChargeStanceSwitch(hero)
	if hero:HasModifier("modifier_WarriorCharge") then
 		Timers:CreateTimer(1.0,function() 
	        fixChargeStanceSwitch(hero)
	    end)
	else
		local abil1 = hero:GetAbilityByIndex(0)
  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:AddAbility("Wounding_Strike")
  		local id = hero:GetPlayerOwnerID()+1
  		hero:FindAbilityByName("Wounding_Strike"):SetLevel(SwitchStancesLvl1[id])
	end
end

function SwordStorm(event)
	DamageAOE(event)
	Timers:CreateTimer(1.5,function() 
        DamageAOE(event)
    end)
    Timers:CreateTimer(3.0,function() 
        DamageAOE(event)
    end)
    Timers:CreateTimer(4.5,function() 
        DamageAOE(event)
    end)
    Timers:CreateTimer(6.0,function() 
        DamageAOE(event)
    end)
    --event.amount=60
    --event.interval=0.1
    --PurgePeriodic(event)
end

function PurgePeriodic(event)
	for i=0,event.amount-1 do 
		local RemovePositiveBuffs = false
		local RemoveDebuffs = true
		local BuffsCreatedThisFrameOnly = false
		local RemoveStuns = true
		local RemoveExceptions = false
		Timers:CreateTimer(i*event.interval+0.01,function() 
        	event.caster:Purge( RemovePositiveBuffs, RemoveDebuffs, BuffsCreatedThisFrameOnly, RemoveStuns, RemoveExceptions)
        	if i%3==0 then
        		StartAnimation(event.caster, {activity=ACT_DOTA_CAST_ABILITY_3, duration=0.3, rate=1.2})
        		local target = event.caster
				local particle = ParticleManager:CreateParticle("particles/econ/items/axe/axe_weapon_bloodchaser/axe_attack_blur_counterhelix_bloodchaser.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
                ParticleManager:ReleaseParticleIndex(particle)
				--StartSoundEventFromPosition("sounds/weapons/hero/axe/counterhelix.wav" ,event.caster:GetOrigin())
				--event.caster:EmitSound("sounds/weapons/hero/axe/counterhelix.wav")
				EmitSoundOn( "Hero_Axe.CounterHelix_Blood_Chaser", event.caster)
        	end
    	end)
		
	end
end

function DamageUnitConditional(event)
    local caster = event.caster
    local target = event.target

    if caster:GetTeamNumber() == target:GetTeamNumber() then

    else
        DamageUnit(event)
    end
end

function ApplyBuffFriendEnemy(event)
    local caster = event.caster
    local target = event.target

    if caster:GetTeamNumber() == target:GetTeamNumber() then
        event.buff = event.bufffriend
        ApplyBuff(event)
    end
    if caster:GetTeamNumber() ~= target:GetTeamNumber() then
        event.buff = event.buffenemy
        ApplyBuff(event)
    end
end

function ApplyBuffConditional(event)
    local caster = event.caster
    local target = event.target

    if caster:GetTeamNumber() == target:GetTeamNumber() and event.onlyfriend then
        ApplyBuff(event)
    end
    if caster:GetTeamNumber() ~= target:GetTeamNumber() and event.onlyenemy then
        ApplyBuff(event)
    end
end

function NinjaSetBuff(event)
    local caster = event.caster
    --if caster:HasModifier("modifier_talent_enrage") then
    --    event.dur = event.dur * 2
    --end
    ApplyBuff(event)
end

function GuardianSpear(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster:GetTeamNumber() == target:GetTeamNumber() then
        ability:ApplyDataDrivenModifier(caster, target, "temple_guardian_hot", {Duration = event.dur})
    else
        event.buff = "temple_guardian_spearslow"
        ApplyBuff(event)
        DamageUnit(event)
    end
end

function PurgeConditional(event)
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() == target:GetTeamNumber() then
        PurgeUnit(event)
    else
        PurgeEnemyUnit(event)
    end
end

function PurgeIfFriend(event)
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() == target:GetTeamNumber() then
        PurgeUnit(event)
    end
end

function RestoreManaIfFriend(event)
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() == target:GetTeamNumber() then
        RestoreMana(event)
    end
end

function HealUnitIfFriend(event)
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() == target:GetTeamNumber() then
        HealUnit(event)
    end
end

function WarlockPurge(event)
	local caster = event.caster
	local target = event.target

	if caster:GetTeamNumber() == target:GetTeamNumber() then
		PurgeUnit(event)
	else
		PurgeEnemyUnit(event)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_slow50"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)
	end
end

--Paladin -------------------------------------------------------------------------------------------------------------------------------------------

function HolyJudgement(event)
	local caster = event.caster
	local target = event.target

	if caster:GetTeamNumber() == target:GetTeamNumber() then
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_judgement_spellres", {Duration = event.spellresduration})
		HealUnit(event)
	else
		event.spelldamagefactor = event.spelldamagefactor * event.dmgfactor/100
		event.attributefactor = event.attributefactor * event.dmgfactor/100
        event.critdmgbonusfactor = nil
		DamageUnit(event)
		local table = {}
		table.Duration = 5
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_wisdom", table)
	end
end

function Penance(event)
    local caster = event.caster
    local target = event.target

    if caster:GetTeamNumber() == target:GetTeamNumber() then
        if event.ability:GetLevel() >= 4 then
            local event2 = {caster = caster, target = target, ability = event.ability, max = 8, buff = "modifier_judgement_spellres2", dur = 6}
            ApplyBuffStack(event2)
            --event.ability:ApplyDataDrivenModifier(caster, target, "modifier_judgement_spellres", {Duration = 6})
        end
        HealUnit(event)
    else
        if event.darkstacks and event.darkstacks > 0 then
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.darkstacks = event.darkstacks
            ShadowCrippleStacks(myevent)
        end
        event.spelldamagefactor = event.spelldamagefactor * event.dmgfactor/100
        event.attributefactor = event.attributefactor * event.dmgfactor/100
        DamageUnit(event)
    end
end

function HealPercentage( event )
	local caster = event.target
	if event.selftarget ~= nil then
		caster = event.caster
	end
	caster:SetHealth(caster:GetHealth()+caster:GetMaxHealth()*event.heal/100)
end

-- Rogue -----------------------------------------------------------------------------------------------------------------------------------------------------

function AddCPEffect(event)

	local caster = event.caster
	local cp = caster.ComboPoints
	if cp == nil or caster == nil then
		return
	end

	if caster.cpparticle then
		ParticleManager:DestroyParticle(caster.cpparticle, false)
	end

	local fx = "particles/combopoint3.vpcf"
	if caster:GetName() == "npc_dota_hero_dazzle" then
		fx = "particles/combopoint4.vpcf"
	end

	local particle = ParticleManager:CreateParticleForPlayer(fx, PATTACH_POINT_FOLLOW, caster, caster:GetOwner())
	if caster.ComboPoints == 1 then
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
	elseif caster.ComboPoints == 2 then
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
	elseif caster.ComboPoints == 3 then
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 3, Vector(1,0,0))
	elseif caster.ComboPoints == 4 then
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 3, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 4, Vector(1,0,0))
	elseif caster.ComboPoints == 5 then
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 3, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 4, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 5, Vector(1,0,0))
	end
    --ParticleManager:ReleaseParticleIndex(particle)
	caster.cpparticle = particle
	
end

function RemoveCPEffect(event)

	local caster = event.caster
	local cp = caster.ComboPoints

	if caster.cpparticle then
		ParticleManager:DestroyParticle(caster.cpparticle, false)
	end

	local fx = "particles/combopoint3.vpcf"
	if caster:GetName() == "npc_dota_hero_dazzle" then
		fx = "particles/combopoint4.vpcf"
	end

	local particle = ParticleManager:CreateParticleForPlayer(fx, PATTACH_POINT_FOLLOW, caster, caster:GetOwner())
	--if caster.ComboPoints == 1 then
	--	ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
	--elseif caster.ComboPoints == 2 then
	--	ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
	--	ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
	--elseif caster.ComboPoints >= 3 then
	--	ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
	--	ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
	--	ParticleManager:SetParticleControl(particle, 3, Vector(1,0,0))
	--end
	caster.cpparticle = particle
	
end

function NumbingCut(event)
	local caster = event.caster
	local target = event.target
	local cp = caster.ComboPoints
	local damage_table = {}

	if cp and cp > 0 then
		--damage_table.Duration = cp*event.buffduration
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_stunned", damage_table)
        if event.ability:GetLevel() >= 3 then
            AddAttackSpeed(caster, 100, 25)
        end
        if cp >= 3 and caster:HasModifier("modifier_npc_dota_hero_phantom_assassin") then
            AddAttackSpeed(caster, 450, 10)
        end
		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_stunned"
		myevent.ability = event.ability
		myevent.dur = cp*event.buffduration
		ApplyBuff(myevent)
        local myevent2 = {}
        myevent2.caster = caster
        myevent2.ability = event.ability
        myevent2.buff = "modifier_rogue_ambush_bonus2"
        myevent2.target = caster
        myevent2.dur = event.dur2
        ApplyBuff(myevent2)
        event.dur = event.dur * cp
        ApplyBuffStack(event)
        caster.ComboPoints = 0
        caster:RemoveModifierByName("modifier_combopoint")
	else
		event.ability:EndCooldown()
	end

	-- test todo
	--DebugDrawText(caster:GetOrigin() , "IIIIIIIIII", true, 10.0)
	--Text(caster:GetOrigin(), 20, "Yo |||||||||", 10.0, 5, 5, 5, 5, 10.0)
	--CDebugOverlayScriptHelper:VectorText3D(caster:GetOrigin(), caster:GetAngles(), "Yo |||||||||", 5, 5, 5, 5, 5, 10.0)
	--DebugDrawBoxDirection(caster:GetOrigin(), caster:GetOrigin(), caster:GetOrigin()*3, caster:GetOrigin(), caster:GetOrigin(), 100.0, 10.0) 
end

function SetPositionAhead( event )
    local caster = event.caster
    local target = event.target
    local offset = caster:GetForwardVector():Normalized()*event.range*20
    --print(offset)
    target:SetAbsOrigin(offset)
end

function FatalThrow(event)
    local caster = event.caster
    local target = event.target
    local cp = caster.ComboPoints
    caster.FatalThrowCP = 0

    if cp > 0 then
        caster.FatalThrowCP = cp
        if ConsumeComboPoints(caster, target) then
            caster.ComboPoints = 0
            caster:RemoveModifierByName("modifier_combopoint")
        end
        if event.ability:GetLevel() >= 4 then
            if cp >= 3 then
                Timers:CreateTimer(0.05, function()
                    local offset = target:GetForwardVector():Normalized()*150
                    offset = Vector(offset[1], offset[2],0)
                    caster:SetAbsOrigin(target:GetAbsOrigin()-offset)
                    caster:SetForwardVector(target:GetForwardVector())
                end)
                local tab = {}
                tab.Duration = 0.2
                event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", tab)
                local attacks = 3
                for i=1, attacks do
                    Timers:CreateTimer(0.05 + 0.15*(i-1), function()
                        CheckForAutoAttackCriticalStrikeProcs(caster, target)
                        caster:PerformAttack(target, true, true, true, true, true, false, false)
                    end)
                end
            end
        end
    end
end

function ItemCastAllowed(event)
	local caster = event.caster
	if caster:HasModifier("modifier_voodoo_datadriven") then
		return false
	end
	return true
end

function Lightbringer(event)
	local caster = event.caster
	local ability = event.ability
	if true or ItemCastAllowed(event) then --itemcastallowed could be used later
		ApplyBuff(event)
	else
 		ability:EndCooldown()
	end
end

function SmokeBomb(event)
	local caster = event.unit
	local target = event.target
	--print(caster:GetName())
	--print(target:GetName())
	if target == nil or caster == target or (target:HasModifier("modifier_smokebomb") and caster:HasModifier("modifier_smokebomb")) or (not target:HasModifier("modifier_smokebomb") and not caster:HasModifier("modifier_smokebomb"))  then
		return
	else
		--print("smoke bombed")	
		event.dur = 0.1
		event.buff = "modifier_silence"
		event.target = caster
		ApplyBuff(event)
		
		Timers:CreateTimer(0.03, function()
			caster:Stop()
		end)
		local particle = ParticleManager:CreateParticleForPlayer("particles/screen_smoke_1.vpcf", PATTACH_POINT_FOLLOW, caster, caster:GetOwner())
        ParticleManager:ReleaseParticleIndex(particle)
		--local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_riki/riki_tricks_cast.vpcf", PATTACH_POINT_FOLLOW, caster)
		--particle = ParticleManager:CreateParticle("particles/econ/events/ti4/dagon_ti4.vpcf", PATTACH_POINT_FOLLOW, target)
		--ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin()+Vector(0,0,80))
		--ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
		--EmitSoundOn("Hero_BountyHunter.Target", caster)
	end
end

function Envenom(event)
    local caster = event.caster
    local target = event.target
    local cp = caster.ComboPoints
    caster.cpbaseddmg = cp

    if cp > 0 then
        if ConsumeComboPoints(caster, target) then
            caster.ComboPoints = 0
            caster:RemoveModifierByName("modifier_combopoint")
        end

        local stacks = target:GetModifierStackCount("modifier_deadlypoison", nil)
        if stacks >= 1 and event.ability:GetLevel() >= 5 then
            target:RemoveModifierByName("modifier_deadlypoison")
            event.attributefactor = event.attributefactor * 2
        end

        --event.ability:ApplyDataDrivenModifier(caster, target, "modifier_envenom", nil)
        event.attributefactor = event.attributefactor * cp
        DamageUnit(event)
        event.target = event.caster
        ApplyBuff(event)
        if event.cd3rd and event.cd3rd > 0 then
            local shiv = caster:FindAbilityByName("combat2")
            if shiv then
                shiv:EndCooldown()
            end
        end
    else
        event.ability:EndCooldown()
    end
end

function EnvenomAOE(event)
    local caster = event.caster
    local target = event.target
    if caster.envenom_toxic_explosion then
        DamageUnit(event)
    end
end

function EnvenomAOEFX( event )
    local caster = event.caster
    local target = event.target
    local ability = caster:FindAbilityByName("combat3")
    if math.random(1,100) <= 30 and ability and ability:GetLevel() >= 4 and caster:HasModifier("modifier_bladerush") then
        caster.envenom_toxic_explosion = true
        local particle = ParticleManager:CreateParticle("particles/econ/items/undying/undying_manyone/undying_pale_tombstone.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
    else
        caster.envenom_toxic_explosion = false
    end
end

function Bladerush(event)
	local caster = event.caster
	local cp = caster.ComboPoints
	if cp > 0 then
		caster.ComboPoints = 0
		caster:RemoveModifierByName("modifier_combopoint")
		local tab = {}
		tab.Duration = 7*cp
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_bladerush", tab)
	else
		event.ability:EndCooldown()
	end
end

function Tigerfury(event)
    local caster = event.caster
    local cp = caster.ComboPoints

    if cp > 0 then
        if ConsumeComboPoints(caster, target) then
          caster.ComboPoints = 0
          caster:RemoveModifierByName("modifier_combopoint")
        end
        local tab = {}
        tab.Duration = event.dur*cp
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_tigerfury", tab)
    else
        event.ability:EndCooldown()
        event.ability:StartCooldown(1)
    end
end

function FatalThrowHit(event)
	local caster = event.caster
	local target = event.target

	if caster.FatalThrowCP and caster.FatalThrowCP > 0 then
        local cp = caster.FatalThrowCP

		--local myevent = {}
		--myevent.caster = caster
		--myevent.target = target
		--myevent.buff = "modifier_silence"
		--myevent.ability = event.ability
		--myevent.dur = caster.FatalThrowCP*event.silence
		--ApplyBuff(myevent)
        SpellInterrupt({caster = caster, target = target, dur = 5, ability = event.ability})

        if caster.fatalThrowBonus and caster.fatalThrowBonus >= 1 then
            event.fatalThrowBonus = 1
        end
		event.attributefactor = event.attributefactor * cp
        event.includeauto = event.includeauto * cp
		DamageUnit(event)

		--damage_table.Duration = caster.FatalThrowCP*2
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_slow50", damage_table)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_slow50"
		myevent.ability = event.ability
		myevent.dur = cp * event.slow
		ApplyBuff(myevent)
		
        if caster:HasModifier("modifier_shadowblend") and caster:HasModifier("modifier_item_rogueblades2") then
            ChainProjectile( caster, target, event.ability, 1, "particles/units/heroes/hero_phantom_assassin/phantom_assassin_stifling_dagger.vpcf", {target}, "Hero_PhantomAssassin.Dagger.Cast", 0.25, 600 )
        end
	end
end

function ListContainsString( list, text )
    for i=1, #list do
        if list[i] == text then
            return true
        end
    end
    return false
end

function ChainProjectile( caster, target, ability, count, projectile_fx, targets_hit, sound, delay, jumprange )
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), target:GetAbsOrigin(), caster, jumprange, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    local enemies_valid = {}
    if count < 1 then
        return
    end
    count = count - 1
    for _,enemy in pairs(enemies) do
        if enemy and ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) and not ListContainsString( targets_hit, enemy ) then
            table.insert(enemies_valid, enemy)
        end
    end
    if #enemies_valid > 0 then
        local newtarget = enemies_valid[math.random(1,#enemies_valid)]
        local info = {
            Target = newtarget,
            Source = target,
            Ability = ability,
            EffectName = projectile_fx,
            bDodgeable = true,
            bProvidesVision = true,
            iMoveSpeed = 600,
            iVisionRadius = 300,
            iVisionTeamNumber = caster:GetTeamNumber(),
            iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_HITLOCATION
        }
        ProjectileManager:CreateTrackingProjectile( info )
        EmitSoundOn(sound, caster)
        table.insert(targets_hit, newtarget)
        Timers:CreateTimer(delay, function()
            ChainProjectile( target, newtarget, ability, count, projectile_fx, targets_hit, sound, delay, jumprange )
        end)
    end
end

function Ambush(event)
	local caster = event.caster
	local target = event.target

	local angleDiff = target:GetAngles()[2]-caster:GetAngles()[2]
	if angleDiff < 0.0 then
		angleDiff = -angleDiff
	end

	if (angleDiff <= 90.0 or angleDiff >= 270.0) then
		local damage_table = {}
		damage_table.Duration = -1
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_combopoint", damage_table)
		caster.ComboPoints = caster.ComboPoints + 3
		if caster.ComboPoints > 3 then
   			caster.ComboPoints = 3
   		end
   		caster:SetModifierStackCount("modifier_combopoint", event.ability, caster.ComboPoints)
   		AddCPEffect(event)
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nyx_assassin/nyx_assassin_vendetta_blood.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
   		DamageUnit(event)
   	else
   		--print("end")
   		--event.ability:EndCooldown()
	end

	--print(caster:GetAngles()[2])

	--if caster:GetRotat
end

function Stealth(event)
	--print("steaklth test")
	local hero = event.caster
	local level = event.ability:GetLevel()
	local abil1 = hero:GetAbilityByIndex(0)
	local abil2 = hero:GetAbilityByIndex(1)

	hero.StealthSpell1=abil1:GetLevel()
	hero.StealthSpell2=abil2:GetLevel()

	hero:RemoveAbility(abil1:GetAbilityName())
	hero:RemoveAbility(abil2:GetAbilityName())

	if hero:GetName() == "npc_dota_hero_bounty_hunter" then
		hero:AddAbility("combat7")
		hero:FindAbilityByName("combat7"):SetLevel(level)
	else
		hero:AddAbility("Narcotic_Strike")
		hero:FindAbilityByName("Narcotic_Strike"):SetLevel(level)
	end
	hero:AddAbility("Paralyse")
	hero:FindAbilityByName("Paralyse"):SetLevel(level)
	hero:FindAbilityByName("Paralyse"):EndCooldown()
    if hero:HasModifier("modifier_npc_dota_hero_pa2") then
        hero.fatalThrowBonus = 3
    end
end

function Paralyse(event)
    local caster = event.caster

    local ability6Level = caster:FindAbilityByName("combat6"):GetLevel()
    if ability6Level < 5 then
        return
    end

    local myevent = {caster = caster, amount = 1000, ability = caster:FindAbilityByName("combat5") }
    ReduceCooldown(myevent)
end

function StealthSapBuffFix(event)
	local caster = event.caster
	local damage_table = {}
 	damage_table.Duration = 10
 	if caster:GetName() == "npc_dota_hero_riki" then
 		caster:FindAbilityByName("hawk6"):ApplyDataDrivenModifier(caster, caster, "modifier_invisible", damage_table)
 	elseif caster:GetName() == "npc_dota_hero_bounty_hunter" then
		caster:FindAbilityByName("combat6"):ApplyDataDrivenModifier(caster, caster, "modifier_invisible", damage_table)
	else
		caster:FindAbilityByName("Shadow_Walk"):ApplyDataDrivenModifier(caster, caster, "modifier_invisible", damage_table)
	end
	StartAnimation(caster, {activity=ACT_DOTA_ATTACK, duration=0.3, rate=3.0})
end

function StealthEnd(event)
	local hero = event.caster

	if event.checkinvisbreak then
		local a = event.event_ability
		if a then
			if a:GetName() == "Shadow_Blend" or a:GetName() == "Ambush" or a:GetName() == "Fatal_Throw" or a:GetName() == "hawk4" or a:GetName() == "hawk3" or a:GetName() == "hawk7" or a:GetName() == "combat5" or a:GetName() == "combat4" or a:GetName() == "combat2" then
				hero:RemoveModifierByName("modifier_invisible")
				hero:RemoveModifierByName("modifier_stealthrogue")
			end
		end
		return
	end

	hero:RemoveModifierByName("modifier_invisible")
	hero:RemoveModifierByName("modifier_stealthrogue")

	local abil1 = hero:GetAbilityByIndex(0)
	local abil2 = hero:GetAbilityByIndex(1)

	hero:RemoveAbility(abil1:GetAbilityName())
	hero:RemoveAbility(abil2:GetAbilityName())

	if hero:GetName() == "npc_dota_hero_riki" then
		hero:AddAbility("hawk1")
		hero:FindAbilityByName("hawk1"):SetLevel(hero.StealthSpell1)
		hero:AddAbility("hawk2")
		hero:FindAbilityByName("hawk2"):SetLevel(hero.StealthSpell2)
	elseif hero:GetName() == "npc_dota_hero_bounty_hunter" then
		hero:AddAbility("combat1")
		hero:FindAbilityByName("combat1"):SetLevel(hero.StealthSpell1)
		hero:AddAbility("combat3")
		hero:FindAbilityByName("combat3"):SetLevel(hero.StealthSpell2)
	else
		hero:AddAbility("Dagger_Strike")
		hero:FindAbilityByName("Dagger_Strike"):SetLevel(hero.StealthSpell1)
		hero:AddAbility("Numbing_Cut")
		hero:FindAbilityByName("Numbing_Cut"):SetLevel(hero.StealthSpell2)
	end
end



-- Mage ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function Waterelemental (event)
	local caster = event.caster
	local owner = caster:GetOwner()
	local teamid = caster:GetTeamNumber()
	local origin = caster:GetAbsOrigin() + RandomVector(100)

	if caster.Pet ~= nil and not caster.Pet:IsNull() then
		UTIL_Remove(caster.Pet)
	end

	caster.Pet = CreateUnitByName("npc_dota_creature_waterelemental", origin, true, owner, nil, teamid)
    caster.Pet.isWaterEle = true
	--caster.Pet:SetPlayerID(owner:GetPlayerID())
 	caster.Pet:SetControllableByPlayer(caster:GetPlayerID(), true)
 	caster.Pet:CreatureLevelUp(event.ability:GetLevel()-1)
 	caster.Pet.owner = caster

 	local ability = caster.Pet:GetAbilityByIndex(0)
	if ability and event.ability then
		ability:SetLevel(event.ability:GetLevel())
	end

 	event.ability:ApplyDataDrivenModifier(event.caster, caster.Pet, "modifier_phased", {Duration = -1})
 	event.ability:ApplyDataDrivenModifier(event.caster, caster.Pet, "modifier_wefx", nil)

 	if caster.artifact_ring and caster.artifact_ring >= 7 then
		local particle = ParticleManager:CreateParticle("particles/econ/courier/courier_wyvern_hatchling/courier_wyvern_hatchling_ice.vpcf", PATTACH_POINT_FOLLOW, caster.Pet)
		--ParticleManager:SetParticleControlEnt(particle, 1, caster.Pet, PATTACH_POINT_FOLLOW, "attach_attack1", caster.Pet:GetAbsOrigin(), true)
        ParticleManager:ReleaseParticleIndex(particle)
		--particle = ParticleManager:CreateParticle("particles/econ/courier/courier_wyvern_hatchling/courier_wyvern_hatchling_ice.vpcf", PATTACH_POINT_FOLLOW, caster.Pet)
        --ParticleManager:ReleaseParticleIndex(particle)
		--ParticleManager:SetParticleControlEnt(particle, 1, caster.Pet, PATTACH_POINT_FOLLOW, "attach_attack2", caster.Pet:GetAbsOrigin(), true)
	end

	if event.ringoffrost and event.ringoffrost == 1 then
		caster.Pet:AddAbility("ringoffrost"):SetLevel(1)
	end

	ability = caster.Pet:GetAbilityByIndex(2)
	if ability and event.ability then
		ability:SetLevel(event.ability:GetLevel())
	end
    event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_pet_system", nil)
end

-- Shaman --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function ElementalConversion (event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local range = event.radius

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), event.target_points[1], caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	--print(#enemies)
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) then
					local table = {}
					table.Duration = event.dur
					ability:ApplyDataDrivenModifier(caster, enemy, "modifier_elemental_lust", table)
				end
			end
		end
	end

	enemies = FindUnitsInRadius( caster:GetTeamNumber(), event.target_points[1], caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	--print(#enemies)
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) then
					local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_dark_seer/dark_seer_wall_of_replica_replicate.vpcf", PATTACH_POINT_FOLLOW, enemy)
					ParticleManager:SetParticleControl(particle, 0, enemy:GetAbsOrigin())
					ParticleManager:SetParticleControl(particle, 1, enemy:GetAbsOrigin())
                    ParticleManager:ReleaseParticleIndex(particle)
					event.target = enemy
					PurgeEnemyUnit(event)
				end
			end
		end
	end
end

function LightningStorm (event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local range = 350

	local tab = {}
	tab.Duration = event.stun


	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	--print(#enemies)
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) then
					--[[
					vec = enemy:GetAbsOrigin()-caster:GetAbsOrigin()
					vec = vec:Normalized()
					--enemy:ApplyAbsVelocityImpulse(vec)
					local npc = enemy
					Physics:Unit(npc)
					npc:PreventDI(false)
					npc:SetAutoUnstuck(true)
					npc:SetNavCollisionType(PHYSICS_NAV_BOUNCE)
					npc:FollowNavMesh(true)
					npc:SetPhysicsVelocityMax(1000)
					npc:SetPhysicsFriction(0.05)
					npc:Hibernate(false)
					npc:SetGroundBehavior(PHYSICS_GROUND_LOCK)
					npc:SetPhysicsVelocity(500 * vec)
					--enemy:AddVelocity(vec, Vector(0,0,0))
					]]
					event.fixedforce = 300
					event.target = enemy
					KnockBack(event)

					--event.ability:ApplyDataDrivenModifier(caster, npc, "modifier_stunned", tab)

					local myevent = {}
					myevent.caster = caster
					myevent.target = enemy
					myevent.buff = "modifier_stunned"
					myevent.ability = event.ability
					myevent.dur = event.stun
					ApplyBuff(myevent)

					Timers:CreateTimer(3.0, function()
						local table = {}
						table.Duration = 0.02
					   	event.ability:ApplyDataDrivenModifier(caster, enemy, "modifier_phased", table)
					end)
				end
			end
		end
	end

	caster:SetMana(caster:GetMana()+caster:GetMaxMana()*event.manapercent/100)
end

function Holybolt(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local range = 300

	local tab = {}
	tab.Duration = event.dur


	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), target:GetOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	--print(#enemies)
	if #enemies > 0 then
		
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) and enemy ~= target then
					
					--event.ability:ApplyDataDrivenModifier(enemy, target, "modifier_stunnedshackle", tab)
					--event.ability:ApplyDataDrivenModifier(target, enemy, "modifier_stunnedshackle", tab)
					--event.ability:ApplyDataDrivenModifier(caster, enemy, "modifier_stunned", tab)
					--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_stunned", tab)
					event.buff = "modifier_stunnedshackle"
					event.caster = enemy
					event.target = target
					ApplyBuff(event)
					event.buff = "modifier_stunnedshackle"
					event.caster = target
					event.target = enemy
					ApplyBuff(event)
                    --[[
					event.buff = "modifier_stunned"
					event.caster = caster
					event.target = enemy
					ApplyBuff(event)
					event.buff = "modifier_stunned"
					event.caster = caster
					event.target = target
					ApplyBuff(event)]]
				end
			end
		end
	end
end

function SetWardDamage( event )
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local attack_damage_min = (GetPrimaryStatValueCustom(caster) + GetSpellpower(event)) * event.dmg / 100
	local attack_damage_max = (GetPrimaryStatValueCustom(caster) + GetSpellpower(event)) * event.dmg / 100

	target:SetBaseDamageMax(attack_damage_max)
	target:SetBaseDamageMin(attack_damage_min)

	if event.fireele then
		caster.fireele = target
	end
	--target:SetOriginalModel("models/props_structures/statue_dragon003.vmdl")
end

function SetFireElementalReference( event )
    event.caster.fireele = event.target
end

function FireEleNova( event )
	local caster = event.caster
	if caster.fireele and not caster.fireele:IsNull() and caster.fireele:IsAlive() then
		event.target_points = {}
		event.target_points[1] = caster.fireele:GetAbsOrigin()
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ember_spirit/ember_spirit_hit_fire.vpcf", PATTACH_POINT_FOLLOW, caster.fireele)
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticle("particles/econ/items/earthshaker/egteam_set/hero_earthshaker_egset/earthshaker_echoslam_start_magma_egset.vpcf", PATTACH_POINT_FOLLOW, caster.fireele)
        ParticleManager:ReleaseParticleIndex(particle)
		DamageAOE(event)
	end
end

function SetWardDamageResto( event )
	local target = event.target
	local ability = event.ability
	target:CreatureLevelUp(event.ability:GetLevel()-1)
	target.warddontbreakit = 1
end

function SetWardAnimationResto( event )
	local target = event.target
	StartAnimation(target, {activity=ACT_DOTA_IDLE, duration=10.0, rate=1.0})
end

function WardDeathAnimationResto( event )
	local target = event.target
	StartAnimation(target, {activity=ACT_DOTA_DIE, duration=4.0, rate=1.0})
end

function voodoo_start( keys )
	local target = keys.target
	local model = keys.model

	if target:IsIllusion() then
		target:ForceKill(true)
	else
		if target:GetModelName() == "models/props_gameplay/chicken.vmdl" or target:GetModelName() == "models/props_gameplay/frog.vmdl" then
			--print("skip saving old model, is already saved")
			if model == target:GetModelName() then
				-- no change in model
			else
				target:SetOriginalModel(model)
			end
		else
			target.aftersheepmodel = target:GetModelName()
			target:SetOriginalModel(model)
		end
	end
end

function voodoo_end( keys )
	local target = keys.target

	-- Checking for errors
	if target.aftersheepmodel ~= nil then
		target:SetModel(target.aftersheepmodel)
		target:SetOriginalModel(target.aftersheepmodel)
		target.aftersheepmodel = nil
	end
end

function HideWearablesByItemValue(event)
    DestroyWearablesByItemValue(event.caster)
end

function DestroyWearablesByItemValue(hero) -- not working
    print("destroy wears")
    local item_value = 0
    local k
    for k=0, 5 do
        local item = hero:GetItemInSlot(k)
        if item then
            item_value = item_value + item:GetCost()
        end
    end
    item_value = item_value / 6 -- get average item value
    local item_rank = 0
    if item_value >= 100 then
        item_rank = 1
    end
    if item_value >= 1000 then
        item_rank = 2
    end
    if item_value >= 10000 then
        item_rank = 3
    end
    if item_value >= 30000 then
        item_rank = 4
    end
    local children = hero:GetChildren()
    for _,child in ipairs(children) do
      if child:GetClassname() == "dota_item_wearable" then
        local name = child:GetModelName()
        print(name)
        if IsServer() and name and string.len(name) > 2 then
            --if child:GetModelName() ~= "models/heroes/dazzle/dazzle_mohawk.vmdl" and child:GetModelName() ~= "models/items/dazzle/dotapit_s3_sunshield_back/dotapit_s3_sunshield_back.vmdl" and child:GetModelName() ~= "models/items/dazzle/headdress_of_the_yuwipi/headdress_of_the_yuwipi.vmdl" and child:GetModelName() ~= "models/items/dazzle/back_feathery/back_feathery.vmdl" and child:GetModelName() ~= "models/items/dazzle/shadowflame_back_s1/shadowflame_back_s1.vmdl" then
            child:AddNoDraw()
        end
      end
    end
end

function HideWearables( event )
    --print("hide wears")
    --if true then
    --    return
    --end
	local target = event.caster
	if event.target ~= nil then
		target = event.target
	end

	--gladiator gear
	RemoveCosmetics(target)

	local children = target:GetChildren()

    for _,child in ipairs(children) do
      if child:GetClassname() == "dota_item_wearable" then
      	--print("hiding")
      	--print(child:GetModelName())
      	--keep the head model
      	if IsServer() then
            --print("hide wear")
            --print(child:GetModelName())
	      	--if child:GetModelName() ~= "models/heroes/dazzle/dazzle_mohawk.vmdl" and child:GetModelName() ~= "models/items/dazzle/dotapit_s3_sunshield_back/dotapit_s3_sunshield_back.vmdl" and child:GetModelName() ~= "models/items/dazzle/headdress_of_the_yuwipi/headdress_of_the_yuwipi.vmdl" and child:GetModelName() ~= "models/items/dazzle/back_feathery/back_feathery.vmdl" and child:GetModelName() ~= "models/items/dazzle/shadowflame_back_s1/shadowflame_back_s1.vmdl" then
	        if event.destroywearables then
                UTIL_Remove(child)
            else
                child:AddEffects(EF_NODRAW)
            end
	        --end
    	end
      end
    end

    --treant form
    if IsServer() then
        if target.treanthead and not target.treanthead:IsNull() then
            target.treanthead:AddEffects(EF_NODRAW)
        end
        if target.treanthead and not target.treanthead:IsNull() then
            target.treanthead:AddEffects(EF_NODRAW)
        end
        if target.treanthand and not target.treanthand:IsNull() then
            target.treanthand:AddEffects(EF_NODRAW)
        end
        if target.treantfeet and not target.treantfeet:IsNull() then
            target.treantfeet:AddEffects(EF_NODRAW)
        end
    end
end

function ShowWearables( event )
    --print("show wears")
    --if true then
    --    return
    --end
	if not IsServer() then
		return
	end
	local target = event.target
	if target == nil then
		target = event.caster
	end
	local children = target:GetChildren()
	if target:HasModifier("modifier_catform") or target:HasModifier("modifier_shapeshifttravel") then
		--print("nope")
	else
		if target ~= nil then
			children = target:GetChildren()
		end

		for _,child in ipairs(children) do
		  if child:GetClassname() == "dota_item_wearable" then
		    child:RemoveEffects(EF_NODRAW)
		  end
		end

		COverthrowGameMode:ShowCosmetics(target)
	end	

    --treant form
    if IsServer() then
        if target.treanthead and not target.treanthead:IsNull() then
            target.treanthead:RemoveEffects(EF_NODRAW)
        end
        if target.treanthead and not target.treanthead:IsNull() then
            target.treanthead:RemoveEffects(EF_NODRAW)
        end
        if target.treanthand and not target.treanthand:IsNull() then
            target.treanthand:RemoveEffects(EF_NODRAW)
        end
        if target.treantfeet and not target.treantfeet:IsNull() then
            target.treantfeet:RemoveEffects(EF_NODRAW)
        end
    end
end

-- Priest Holy ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function SacredShield( event )
	local target = event.target
	local caster = event.caster
	if caster.sacredtarget ~= nil and not caster.sacredtarget:IsNull() then
		caster.sacredtarget:RemoveModifierByName("modifier_sacred_shield")
	end
	target.pwssource = caster
	caster.sacredtarget = target
	--also add bonus factor
    local statbonus = 1.0
    if event.lowbonus and event.lowbonus > 0 and target:GetHealth()/target:GetMaxHealth() < 0.50 then
    	statbonus = statbonus + event.lowbonus/100
    end
    local heavencharge = 1 + caster:GetModifierStackCount("modifier_heaven_charge", caster)*0.5
    caster:RemoveModifierByName("modifier_heaven_charge")
	local max_damage_absorb = (heavencharge * statbonus * (GetPrimaryStatValueCustom(caster) + GetSpellpower(event)) * event.intfactor / 100) * GetAbsorbtionFactor( caster ) * GetHealingMultiplier(event, caster, event.ability, target, true, false, false)
	local shield_size = 75 -- could be adjusted to model scale
	-- Reset the shield
    local maxHealthFactor = 1
    if event.ability:GetLevel() >= 3 then
        maxHealthFactor = 2
    end
    local maxHealth = caster:GetMaxHealth() * maxHealthFactor
    if max_damage_absorb > maxHealth then
        max_damage_absorb = maxHealth
    end
	target.AphoticShieldRemaining = max_damage_absorb
	--target.AphoticShieldPostHealth = target:GetHealth()
	-- Particle. Need to wait one frame for the older particle to be destroyed
	--[[Timers:CreateTimer(0.03, function() 
		target.ShieldParticle = ParticleManager:CreateParticle("particles/abaddon_aphotic_shield_holy2.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
		ParticleManager:SetParticleControl(target.ShieldParticle, 1, Vector(shield_size,0,shield_size))
		ParticleManager:SetParticleControl(target.ShieldParticle, 2, Vector(shield_size,0,shield_size))
		ParticleManager:SetParticleControl(target.ShieldParticle, 4, Vector(shield_size,0,shield_size))
		ParticleManager:SetParticleControl(target.ShieldParticle, 5, Vector(shield_size,0,0))

		-- Proper Particle attachment courtesy of BMD. Only PATTACH_POINT_FOLLOW will give the proper shield position
		ParticleManager:SetParticleControlEnt(target.ShieldParticle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	end)]]
end

function SacredShieldAbsorb( event )
	-- Variables
	local damage = event.DamageTaken
	local unit = event.unit
	local ability = event.ability
	local caster = event.caster

	if event.darkboltchance and event.darkboltchance > 0 then
		if math.random(1,100) <= event.darkboltchance then
			event.ability:ApplyDataDrivenModifier(event.caster, event.attacker, "modifier_darkbolt_proc", nil)
		end
	end

	if unit.AphoticShieldRemaining then 
		unit:SetModifierStackCount("modifier_sacred_shield", event.ability, unit.AphoticShieldRemaining)
	end
	if true then
		return
	end
	
	-- Track how much damage was already absorbed by the shield
	if unit.AphoticShieldRemaining == nil then
		unit.AphoticShieldRemaining = 0
	end
	local shield_remaining = unit.AphoticShieldRemaining
	--print("Shield Remaining: "..shield_remaining)
	--print("Damage Taken pre Absorb: "..damage)

	unit.AphoticShieldRemaining = unit.AphoticShieldRemaining-damage
	-- If the damage is bigger than what the shield can absorb, heal a portion
	local currenthealth = unit:GetHealth()

	
	if damage > shield_remaining then
		--print(currenthealth)
		--print(damage)
		--print(shield_remaining)
		if currenthealth <= 0 then
			--let him die
			--print("special lethal treatment, more dmg than shield")
		else
			local newHealth = currenthealth + shield_remaining
			--print("Old Health: "..unit.OldHealth.." - New Health: "..newHealth.." - Absorbed: "..shield_remaining)
			unit:SetHealth(newHealth)
			if caster and caster.healingdone then
				caster.healingdone = caster.healingdone + shield_remaining
			end
		end
	else
		--print(currenthealth)
		--print(damage)
		--print(shield_remaining)
		if currenthealth <= 0 then
			--let him die
			unit:SetHealth(unit.AphoticShieldPostHealth)
			--print("special lethal treatment, less dmg than shield")
		else
			local newHealth = currenthealth + damage	
			unit:SetHealth(newHealth)
			--print("Old Health: "..unit.OldHealth.." - New Health: "..newHealth.." - Absorbed: "..damage)
		end
		unit:SetModifierStackCount("modifier_sacred_shield", event.ability, unit.AphoticShieldRemaining)
		if caster and caster.healingdone then
			caster.healingdone = caster.healingdone + damage
		end
	end

	--update last dmg info
	unit.AphoticShieldPostHealth = unit:GetHealth()
	-- Reduce the shield remaining and remove
	
	if unit.AphoticShieldRemaining <= 0 then
		unit.AphoticShieldRemaining = nil
		unit:RemoveModifierByName("modifier_sacred_shield")
		unit.AphoticShieldPostHealth = nil
		--print("--Shield removed--")
	end

	--if unit.AphoticShieldRemaining then
		--print("Shield Remaining after Absorb: "..unit.AphoticShieldRemaining)
		--print("---------------")
	--end
	
end

-- Destroys the particle when the modifier is destroyed. Also plays the sound
function EndShieldParticle( event )
	local target = event.target
	ParticleManager:DestroyParticle(target.ShieldParticle,false)
end

function SacredShieldStacks( event )
	local target = event.target
	if target:HasModifier("modifier_sacred_shield") then
		target:SetModifierStackCount("modifier_sacred_shield", event.ability, target.AphoticShieldRemaining)
	end
end

function SacredShieldHealth( event )
	local target = event.target

	target.OldHealth = target:GetHealth()
end

function CycloneDiminishing(event)
	local caster = event.caster
	local target = event.target

	local diminishing = caster:GetModifierStackCount("cyclone_diminishing_return", caster)
	event.dur = event.dur * (event.diminish - diminishing) / event.diminish
	CCTarget(event)
end

function ManaBurn (event)
	local caster = event.caster
	local target = event.target
	local amount = event.mana
	local mana = target:GetMana()

	if event.manaburnpercent then
		amount = amount + event.manaburnpercent*caster:GetMaxMana()/100
		if target:HasModifier("modifier_manaburn_debuff") then
   			amount = amount * 1.4
		end
	end
	if target.Rage ~= nil or ( target.resourcesystem and target:GetUnitName() ~= "npc_dota_hero_dazzle" ) or (target:GetUnitName() == "npc_dota_hero_dazzle" and target:HasModifier("modifier_catform") ) then
		--print("dont fire manaburn")
	else
		if mana >= amount then
			target:SetMana(target:GetMana()-amount)
		else
			target:SetMana(0)
			amount = mana
		end
		event.damage = amount
		DamageUnit(event)
		--manasteal talent
		if event.manasteal and event.manasteal > 0 then
			event.amount = amount * event.manasteal / 100
			RestoreMana(event)
		end
	end
end

function ShadowCreeper (event)
	local caster = event.caster
	local unit = event.target
	caster.Pet = unit
	unit.sourcepriest = caster
	unit:SetHullRadius(35)
	unit:CreatureLevelUp(event.ability:GetLevel()-1)

	Timers:CreateTimer(0.1, function()
		local order = 
		{
			UnitIndex = unit:entindex(),
			OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			TargetIndex = caster.creepertarget:entindex()
		}

		ExecuteOrderFromTable(order)
	end)
end

function WarlockAgonyCounter (event)
	local caster = event.caster
	caster.AgonyCounter = 0.3
    if caster.Pet and not caster.Pet:IsNull() and caster.Pet:IsAlive() and event.ability:GetLevel() >= 4 then
        event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_afflicted", {Duration = 10})
    end
end

function WarlockHauntingTerror (event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if ability:GetLevel() >= 3 then
        ability = caster:GetAbilityByIndex(0)
        if ability and not HasBuffReflect(caster, target) then
            local tickRate = 1
            if ability:GetLevel() <= 1 then
                tickRate = 2
            end
            ApplyBuff({caster = caster, target = target, ability = ability, dur = 20, buff = "modifier_dot1", settickrate = tickRate})
        end
    end
end

function WarlockShadowBolt (event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local chance = event.shadowboltchance
    local count = 1
    if target:HasModifier("modifier_dot1") and target:HasModifier("modifier_dot2") and GetLevelOfAbility(caster, "Pain_Warlock") >= 4 and math.random(1,100) <= 25 then
        count = 3
    end
    if math.random(1,100) <= chance then
        for i=1, count do
            Timers:CreateTimer(0.2 * i - 0.05, function()
                ability:ApplyDataDrivenModifier(caster, target, "modifier_proc_sb", {duration = 0.25})
            end)
        end
    end
end

function WarlockSacrifice (event)
	local caster = event.caster
	local target = caster.owner
	local owner = target
    event.ability:ApplyDataDrivenModifier(caster, target, "modifier_invul_warlock", {Duration = 2.5})
	local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_clinkz/clinkz_death_pact.vpcf", PATTACH_POINT_FOLLOW, owner)
	ParticleManager:SetParticleControl(particle, 1, owner:GetAbsOrigin())
    ParticleManager:ReleaseParticleIndex(particle)

	local health = caster:GetHealth()*event.amount / 100.0
	event.caster = target
	event.target = target
	event.spelldamagefactor = 0.0
	event.attributefactor = 0.0
	event.heal = health
	event.amount = health
	RestoreMana(event)
	HealUnit(event)

	caster:Kill(event.ability, caster)
end

function ShadowCreeperMana (event)
	local caster = event.attacker
	local target = event.target
	local priest = caster.sourcepriest
	if priest ~= nil then
		priest:SetMana(priest:GetMana()+event.amount)	
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_pugna/pugna_life_drain_beam_2b.vpcf", PATTACH_POINT_FOLLOW, priest)
        ParticleManager:SetParticleControlEnt(particle, 0, priest, PATTACH_POINT_FOLLOW, "attach_hitloc", priest:GetAbsOrigin(), true)
		--ParticleManager:SetParticleControl(particle, 0, priest:GetAbsOrigin()+Vector(0,0,90))
		ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin()+Vector(0,0,90))
		ParticleManager:SetParticleControl(particle, 10, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 11, Vector(1,0,0))
		Timers:CreateTimer(0.75, function()
			ParticleManager:DestroyParticle(particle,false)
            ParticleManager:ReleaseParticleIndex(particle)
		end)
	end
	local ability = priest:FindAbilityByName("Shadow_Creeper")
	local myevent = {}
	myevent.caster = priest
	myevent.target = target
	myevent.buff = "modifier_shadowcreepercriple"
	myevent.ability = ability
	myevent.dur = event.dur
	myevent.addstacks = 1
    myevent.max = 10
	ApplyBuffStack(myevent)
end

function ShadowCrippleStacks(event)
	local caster = event.caster
	local target = event.target
	local priest = caster
	if event.darkstacks and event.darkstacks > 0 then
		local ability = priest:FindAbilityByName("Shadow_Creeper")
        if not ability then
            return
        end
		local myevent = {}
		myevent.caster = priest
		myevent.target = target
		myevent.buff = "modifier_shadowcreepercriple"
		myevent.ability = ability
		myevent.dur = 4
        myevent.max = 10
        if event.addstacks then
            myevent.addstacks = event.addstacks
        end
		ApplyBuffStack(myevent)
	end
end

function LightChargeStack(event)
	if event.lightstacks and event.lightstacks > 0 then
		local ability = event.caster:FindAbilityByName("Light_of_Heaven")
        if ability then
		  event.ability = ability
		  ApplyBuffStack(event)
        end
	end
end

function ShadowCreeperEnd (event)
	caster = event.target
	UTIL_Remove(caster)
end

-- Hunter Frost

function HideDeathAnimation (event)
	Timers:CreateTimer(event.delay-1, function()
		event.time = 0
	   	SinkUnitInGround(event)
	end)
end

function SetGroundingTotem (event)
	local caster = event.caster
	local target = event.target
	if event.shaman then
		caster.groundingtotem = target
	end
	if event.victim then
		target.groundingtotemsource = caster.groundingtotem
	end
end

function HideUnitDeathInFrost( event )
    local caster = event.caster
    if event.switchtounit then
        caster = event.unit
    end
    local particle2 = ParticleManager:CreateParticle("particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle2, 0, caster:GetAbsOrigin())
    ParticleManager:SetParticleControl(particle2, 1, Vector(200,1,200))
    ParticleManager:ReleaseParticleIndex(particle2)
    caster:SetModelScale(0.001)
    EmitSoundOn("hero_Crystal.frostbite", caster)
end

function SinkUnitInGround (event)
	local target = event.target
	Timers:CreateTimer(0.1, function()
		if not target:IsNull() then
			event.time = event.time + 1
		   	target:SetAbsOrigin(target:GetAbsOrigin()+Vector(0,0,-1.5))
		   	if event.time < 20 then
		    	SinkUnitInGround(event)
		    end
		end
	end)
end

function SinkUnitInGroundNow (event)
	local target = event.target
	target:SetAbsOrigin(target:GetAbsOrigin()+Vector(0,0,-200))
	target:AddEffects(EF_NODRAW)
end

function GlacierTrapTrigger( event )
	if event.caster.trap.trapused == nil then
		if event.caster.trap ~= nil and not event.caster.trap:IsNull() and not event.target:HasModifier("dummy_unit") then
			event.caster.trap.trapused = 1
			--event.ability:ApplyDataDrivenModifier(event.caster, event.target, "glacier_trap", nil)

			local myevent = {}
			myevent.caster = event.caster
			myevent.target = event.target
			myevent.buff = "glacier_trap"
			myevent.ability = event.ability
			myevent.dur = event.dur

            if event.dealdmg then
                local myevent2 = {}
                myevent2.caster = event.caster
                myevent2.target = event.target
                myevent2.ability = event.ability
                myevent2.damage = 0.0
                myevent2.attributefactor = event.dealdmg
                myevent2.frostdmg = 1
                DamageUnit(myevent2)
            end

			ApplyBuff(myevent)
			--myevent.dur = event.critdur
			--myevent.buff = "glacier_trap_guaranteed_crit"
			--ApplyBuff(myevent)

			EmitSoundOn( "Hero_DrowRanger.Silence", event.caster)
			Timers:CreateTimer(0.5, function()
			if not event.caster.trap:IsNull() then
			   	UTIL_Remove(event.caster.trap)
			end
		end)
		end
	end
end

function TripleFocussedShot( event )
    local caster = event.caster
    if caster:HasModifier("glacier_trap_focus_tripleshot") then
        caster:RemoveModifierByName("glacier_trap_focus_tripleshot")
        local dur = 0.05 + 0.25 * 14
        if caster:HasModifier("modifier_npc_dota_hero_drow_ranger") then
            dur = dur * 3
        end
        event.ability:ApplyDataDrivenModifier(caster, event.target, "modifier_triple_shot", {Duration = dur})
    end
end

function SnakeTrapTrigger( event )
	if event.caster.trap ~= nil and not event.caster.trap:IsNull() and event.caster.trap.trapused == nil and not event.target:HasModifier("dummy_unit") then
		event.caster.trap.trapused = 1
		--event.caster.owner:GetAbilityByIndex(3):ApplyDataDrivenModifier(event.caster.owner, event.target, "snake_trap", nil)
        local caster = event.caster
        local ab = caster:FindAbilityByName("wind4")
        ab:ApplyDataDrivenModifier(caster, caster, "modifier_fireshield", {Duration = 10})

		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.target
		myevent.buff = "snake_trap"
		myevent.ability = ab
		myevent.dur = 0.5
		ApplyBuff(myevent)

		--fire aoe trap
		if event.aoe and event.aoe > 0 then
			local particle = ParticleManager:CreateParticle("particles/econ/items/clockwerk/clockwerk_paraflare/clockwerk_para_rocket_flare_explosion.vpcf", PATTACH_POINT_FOLLOW, event.target)
			ParticleManager:SetParticleControl(particle, 3, event.target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
			particle = ParticleManager:CreateParticle("particles/econ/items/gyrocopter/hero_gyrocopter_gyrotechnics/gyro_calldown_explosion_flash_c.vpcf", PATTACH_POINT_FOLLOW, event.target)
			ParticleManager:SetParticleControl(particle, 3, event.target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
			DamageAOE(event)
			EmitSoundOn("Hero_LegionCommander.Courage", event.target)
		else
			EmitSoundOn("Hero_Sniper.AssassinateDamage", event.target)
		end

		if event.dur and event.dur > 0 then
			ApplyBuffAOE(event)
		end

		Timers:CreateTimer(0.5, function()
			if not event.caster.trap:IsNull() then
			   	UTIL_Remove(event.caster.trap)
			end
		end)
	end
end

function BearTrapTrigger( event )
	local target = event.target
	if event.caster.trap ~= nil and not event.caster.trap:IsNull() and event.caster.trap.trapused == nil then
		target.BearTrapPos = target:GetAbsOrigin()
		event.caster.trap.trapused = 1
		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.target
		myevent.buff = "modifier_bear_trap"
		myevent.dur = event.dur
		myevent.ability = event.ability
		ApplyBuff(myevent)
		EmitSoundOn( "Hero_Beastmaster.Wild_Axes_Damage", target)
		Timers:CreateTimer(0.25, function()
			if not event.caster.trap:IsNull() then
			   	UTIL_Remove(event.caster.trap)
			end
		end)
	end
end

function GhoulMasterEnrage( event )
    local caster = event.caster
    local target = caster.owner
    if target then
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_bearcharge", {Duration = event.buffduration})
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_phased", {Duration = event.buffduration})
    end
end

function GetPrimaryAndSpellpower( target )
    local tab = {caster = target}
    return GetPrimaryStatValueCustom(target) + GetSpellpower(tab)
end

function BloodWolfHeal( event )
    --[[
    local caster = event.caster
    local wolf = event.target
    local heals = 2
    local interval = 4.75
    for i=1, heals do
        Timers:CreateTimer(interval*i,function()
            if wolf and wolf:IsNull() then
                return
            end
            --find target
            local myevent = {}
            myevent.range = 1500
            myevent.target = wolf
            myevent.caster = caster
            myevent.onlyhero = true
            local heal_target = MostWoundedTarget(myevent)
            if heal_target then
                local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_skeletonking/wraith_king_vampiric_aura_lifesteal.vpcf", PATTACH_POINT_FOLLOW, wolf)
                ParticleManager:SetParticleControl(particle, 1, heal_target:GetAbsOrigin())
                ParticleManager:ReleaseParticleIndex(particle)
                local myevent2 = {caster = caster, target = heal_target, heal = heal_target:GetMaxHealth() * 0.01 * caster.talents[46]}
                HealUnit(myevent2)
            end
        end)
    end]]
end

function PetSystem( event )
    local caster = event.target
    local target = event.caster
    --print(target)
    caster.owner = target
    --if event.setpetowner then
    --    target = event.caster
    --end
    if target and caster then
        local dmg = 0
        if event.dmg then
            dmg = dmg + event.dmg
        end
        if event.aa then
            dmg = dmg + event.aa* target:GetAttackDamage()/100 --target:GetAverageTrueAttackDamage(target)/100
        end
        if event.primary then
            dmg = dmg + event.primary*GetPrimaryStatValueCustom(target)/100
        end
        if event.str then
            dmg = dmg + event.str*GetStrengthCustom(target)/100
        end
        if event.agi then
            dmg = dmg + event.agi*GetAgilityCustom(target)/100
        end
        if event.int then
            dmg = dmg + event.int*GetIntellectCustom(target)/100
        end
        if event.sp then
            dmg = dmg + event.sp*GetSpellpower({caster = target})/100
        end
        if event.intsp then
            dmg = dmg + GetPrimaryAndSpellpower(target) * event.intsp / 100
        end
        if event.beastmasterghostwolf and target:HasModifier("modifier_item_beastmaster") then
            dmg = dmg + GetStrengthCustom(target) * 0.25
        end
        if event.beastmasterghostwolf and target:HasModifier("modifier_item_beastmaster2") then
            dmg = dmg + GetStrengthCustom(target) * 0.5
        end

        --as system
        if event.astransfer then
            local stackcount = target:GetIncreasedAttackSpeed(false) * event.astransfer
            if stackcount > 250 then
                stackcount = 250
            end
            event.ability:ApplyDataDrivenModifier(target, caster, "modifier_petas", {Duration = -1})
            caster:SetModifierStackCount("modifier_petas", event.ability, stackcount)
        end

        --talents
        local bonus = 1.0
        if event.talentscale and target.talents and target.talents[event.talentscale] then
            bonus = target.talents[event.talentscale]
        end
        if event.runewordscale and event.runewordscale == 11 and target.runeword and target.runeword[event.runewordscale] then
            bonus = bonus + target.runeword[event.runewordscale]
        end
        dmg = dmg * bonus

        caster:SetBaseDamageMin(dmg)
        caster:SetBaseDamageMax(dmg)
        if (caster:GetAbsOrigin() - target:GetAbsOrigin()):Length() > 1200 then--2250 then
            caster:SetAbsOrigin(target:GetAbsOrigin())
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_chen/chen_teleport.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            if not caster:HasModifier("modifier_phased") then
                local tab = {}
                tab.Duration = 0.5
                event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", tab)
            end
        end
        if not caster.on_summoned_procced then
            OnSummonedUnit(caster, target)
            caster.on_summoned_procced = true
        end
        --talents
        if target and target.talents and target.talents[69] and target.talents[69] > 0 and not caster.path_heal_on_summon_done then
            CruelTaskmasterHeal(target, event.ability, caster)
            local particle = ParticleManager:CreateParticle("particles/items3_fx/glimmer_cape_initial_flash_ember.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
            if target.path_demonic_pact then
                target.path_demonic_pact = target.path_demonic_pact + 1
            else
                target.path_demonic_pact = 1
            end
            Timers:CreateTimer(15,function()
                target.path_demonic_pact = target.path_demonic_pact - 1
            end)
        end
        if event.companionbehavior then
            local target_to_attack = target.last_damaged_target --target.last_attack_target
            if not target_to_attack then
                target_to_attack = target.last_attack_target
            end
            if not target_to_attack then
                target_to_attack = target.creepertarget
            end
            if target_to_attack and not target_to_attack:IsNull() and target_to_attack:IsAlive() and (target_to_attack:GetAbsOrigin() - target:GetAbsOrigin()):Length() < 890 then
                local order = 
                {
                    UnitIndex = caster:entindex(),
                    OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                    TargetIndex = target_to_attack:entindex()
                }
                ExecuteOrderFromTable(order)
            else
                local order = 
                {
                    UnitIndex = caster:entindex(),
                    OrderType = DOTA_UNIT_ORDER_MOVE_TO_TARGET,
                    TargetIndex = target:entindex()
                }
                ExecuteOrderFromTable(order)
            end
        end
    end
end

function BearTrapMoveDamage( event )
	local target = event.target
	local caster = event.caster
	local distance = (target:GetAbsOrigin()-target.BearTrapPos):Length()
	--print(distance)
	target.BearTrapPos = target:GetAbsOrigin()
	if distance > 10.0 then
		--event.damage = caster:GetPrimaryStatValue()*caster:GetAbilityByIndex(2):GetLevelSpecialValueFor("dmgfromstat", (caster:GetAbilityByIndex(2):GetLevel() - 1))
		--print(caster:GetAbilityByIndex(2):GetLevelSpecialValueFor("dmgfromstat", (caster:GetAbilityByIndex(2):GetLevel() - 1)))
		--print(event.damage)
		--event.caster = caster.TrapOwner
		EmitSoundOn( "Hero_Beastmaster.Wild_Axes_Damage", event.caster)
		DamageUnit(event)
		target.beartraplasttick = 1
	else
		target.beartraplasttick = 0
	end
end

function FierceShotProc( event )
    local target = event.target
    local caster = event.caster
    local distance = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Length()
    if distance > 350 then
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_multi_arrows_fierce", {Duration = 0.16})
    end
end

function BearTrapEnd( event )
	local target = event.target
	local caster = event.caster
	if target.beartraplasttick and target.beartraplasttick == 1 then
		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.target
		myevent.buff = "modifier_bear_trap"
		myevent.dur = event.dur
		myevent.ability = event.ability
		ApplyBuff(myevent)
	end
end

function SetTrapOwner( event )
	event.target.TrapOwner = event.caster
	event.target.owner = event.caster
	event.caster.trap = event.target
end

function SetSummonOwner( event )
	event.target.owner = event.caster
end

function SetTrapHunter( event )
	event.caster.trap = event.target
end

function SetLookDirection( event )
    event.target:SetForwardVector(Vector(0,1,0))
end

function TurnUnit( event )
    local target = event.target
    local angle = event.angle
    local radangle = math.rad(angle)
    local cos = math.cos(radangle)
    local sin = math.sin(radangle)
    local forward = target:GetForwardVector()
    local vec = Vector(forward[1]*cos - forward[2]*sin, forward[1]*sin + forward[2]*cos, 0):Normalized()
    target:SetForwardVector(vec)
end

function StopKnockBack ( event )
	local npc = event.target
	if npc ~= nil and npc:IsAlive() and not npc:IsNull() then
		Physics:Unit(npc)
		npc:SetPhysicsVelocity(Vector(0,0,0))
		npc:SetNavCollisionType(PHYSICS_NAV_BOUNCE)
	end
end

function KnockBackNear( event )
    local caster = event.caster
    local target = event.target
    if (target:GetAbsOrigin()-caster:GetAbsOrigin()):Length() < event.neartarget then
        KnockBack(event)
    end
end

function KnockBack ( event )
	local npc = event.target
	local dir = 1
	local jumpdur = 0.5
	local vec
    if not IsServer() then
        return
    end
    if npc and npc.forceimune then
        return
    end
    if event.minrange and (event.caster:GetAbsOrigin() - event.target:GetAbsOrigin()):Length() < event.minrange then
        return
    end
    if event.jumpdur then
        jumpdur = event.jumpdur
    end
    if event.ondealdamagetarget then
        npc = event.unit
    end
    if npc and not npc:IsNull() and not npc:IsAlive() then
        return
    end
	if event.moltenlava then
		vec = -event.target_points[1]+npc:GetAbsOrigin()
	else
		if event.notarget then
			vec = event.caster:GetForwardVector():Normalized()*event.notarget
		else
			if npc == nil then
				vec = event.target_points[1]-event.caster:GetAbsOrigin()
			elseif event.random ~= nil then
				local vec1 = RandomVector(1.0)
				vec = Vector(vec1[1],vec1[2],0)
				if not event.dontface then
					npc:SetForwardVector(vec)
				end
            elseif event.forward then
                local vec1 = npc:GetForwardVector()
                vec = Vector(vec1[1],vec1[2],0)
                if not event.dontface then
                    npc:SetForwardVector(vec)
                end
            elseif event.left then
                local set_pos = event.caster:GetAbsOrigin() - event.caster:GetForwardVector() * 125
                npc:SetAbsOrigin(set_pos)
                local vec1 = RotateVectorAroundAngle(event.caster:GetForwardVector(), 225)
                vec = Vector(vec1[1],vec1[2],0)
                npc:SetForwardVector(vec)
            elseif event.left2 then
                local set_pos = event.caster:GetAbsOrigin() + event.caster:GetForwardVector() * 125
                npc:SetAbsOrigin(set_pos)
                local vec1 = RotateVectorAroundAngle(event.caster:GetForwardVector(), 315)
                vec = Vector(vec1[1],vec1[2],0)
                npc:SetForwardVector(vec)
            elseif event.right then
                local set_pos = event.caster:GetAbsOrigin() - event.caster:GetForwardVector() * 125
                npc:SetAbsOrigin(set_pos)
                local vec1 = RotateVectorAroundAngle(event.caster:GetForwardVector(), 135)
                vec = Vector(vec1[1],vec1[2],0)
                npc:SetForwardVector(vec)
            elseif event.right2 then
                local set_pos = event.caster:GetAbsOrigin() + event.caster:GetForwardVector() * 125
                npc:SetAbsOrigin(set_pos)
                local vec1 = RotateVectorAroundAngle(event.caster:GetForwardVector(), 45)
                vec = Vector(vec1[1],vec1[2],0)
                npc:SetForwardVector(vec)
            elseif event.leftcurve then
                --event.leftcurve = 90
                local angle = event.leftcurve
                if not npc.leftcurve then
                    npc.leftcurve = event.leftcurve
                else
                    npc.leftcurve = npc.leftcurve - 30
                    angle = npc.leftcurve
                end
                if angle < -90 then
                    angle = -30
                    --npc.leftcurve = npc.leftcurve + 15
                    --angle = npc.leftcurve
                end
                local vec1 = RotateVectorAroundAngle(npc:GetForwardVector(), -angle)
                vec = Vector(vec1[1],vec1[2],0)
                npc:SetForwardVector(vec)
            elseif event.rightcurve then
                --event.rightcurve = 90
                local angle = event.rightcurve
                if not npc.rightcurve then
                    npc.rightcurve = event.rightcurve
                else
                    npc.rightcurve = npc.rightcurve - 30
                    angle = npc.rightcurve
                end
                if angle < -90 then
                    angle = -30
                    --npc.rightcurve = npc.rightcurve + 15
                    --angle = npc.rightcurve
                end
                local vec1 = RotateVectorAroundAngle(npc:GetForwardVector(), angle)
                vec = Vector(vec1[1],vec1[2],0)
                npc:SetForwardVector(vec)
            elseif event.zigzag then
                local angle = 30 --event.zigzag
                event.fixedforce = 150
                if not npc.zigzag then
                    --initial force is to the side
                    local vec1 = RotateVectorAroundAngle(npc:GetForwardVector(), 90)
                    vec = Vector(vec1[1],vec1[2],0)
                    npc:SetForwardVector(vec)
                    npc.zigzag = 0
                else
                    --after initial direction, rotate a bit every tick
                    npc.zigzag = npc.zigzag + angle
                    local vec1
                    if (npc.zigzag % 361) < 180 then
                        vec1 = RotateVectorAroundAngle(npc:GetForwardVector(), angle)
                    else
                        vec1 = RotateVectorAroundAngle(npc:GetForwardVector(), -angle)
                    end
                    vec = Vector(vec1[1],vec1[2],0)
                    npc:SetForwardVector(vec)
                end
			else
				if event.aoepull then
					vec = npc:GetAbsOrigin()-event.target_points[1]
				else
					vec = npc:GetAbsOrigin()-event.caster:GetAbsOrigin()
				end
			end
		end
	end

	vec[3] = 0

	-- if its feral charge
	if event.charge ~= nil then
		npc = event.caster
	end

	-- if its the ranger
	if event.chargeranger ~= nil then
		dir = -1
		npc = event.caster
	end
	-- if its feral crush (prot warrior)
	if event.crush then
		npc = event.caster
	end

    local overtimefactor = 1.0
    if event.increaseovertime then
        if npc.forceincreaseovertime then
            npc.forceincreaseovertime = npc.forceincreaseovertime + event.increaseovertime
        else
            npc.forceincreaseovertime = event.increaseovertime
        end
        overtimefactor = overtimefactor + npc.forceincreaseovertime
    end

	Physics:Unit(npc)
	npc:SetPhysicsFriction(0.0)

	if event.fixedforce then
		vec = vec:Normalized()*event.fixedforce*0.85
		npc:SetPhysicsFriction(0.08)
	else
		vec = vec - vec:Normalized()*150
	end

	-- if its deathgrip
	if event.inversed ~= nil then
		dir = -1
	end

	if npc:GetUnitLabel() == "tower" then
 		return
	end
	
	npc:PreventDI(false)
	npc:SetAutoUnstuck(true)
    npc:SetGroundBehavior(PHYSICS_GROUND_LOCK)
    if event.leftcurve or event.rightcurve or event.right or event.left then
        npc:SetNavCollisionType(PHYSICS_NAV_NOTHING)
        npc:SetGroundBehavior(PHYSICS_GROUND_ABOVE)
    else
        npc:SetNavCollisionType(PHYSICS_NAV_BOUNCE)
    end
	npc:FollowNavMesh(true)
	npc:SetPhysicsVelocityMax(2500)
	if event.friction then
		npc:SetPhysicsFriction(event.friction)
        --print("friction" .. event.friction)
	end
	npc:Hibernate(false)
	
	vec = vec * 2.0 * dir * overtimefactor
	if event.upintheair and event.upintheair > 0 then
        vec = vec * 0.5 / jumpdur
		npc:SetGroundBehavior(PHYSICS_GROUND_NOTHING)
		npc:SetNavCollisionType(PHYSICS_NAV_NOTHING)
		vec[3] = 300*event.upintheair
		Timers:CreateTimer(jumpdur/2, function()
			npc:AddPhysicsVelocity(Vector(0,0,-300*event.upintheair*2))
		end)
	end

	if npc.isunderforce then
		npc.isunderforce = npc.isunderforce + 1
	else
		npc.isunderforce = 1
	end

	npc:SetPhysicsVelocity(vec)

    --dust fx
    --local particle = ParticleManager:CreateParticle("particles/econ/events/fall_major_2016/force_staff_fm06_dust.vpcf", PATTACH_POINT_FOLLOW, npc)
    --ParticleManager:ReleaseParticleIndex(particle)
    

	Timers:CreateTimer(jumpdur, function()
		if npc.isunderforce <= 1 then
            if not event.forever and not event.leftcurve and not event.rightcurve and not event.left and not event.right then
                npc:SetPhysicsVelocity(Vector(0,0,0))
                npc:SetGroundBehavior(PHYSICS_GROUND_LOCK)
                npc:SetNavCollisionType(PHYSICS_NAV_BOUNCE)
                npc:Hibernate(true)
            end
		end
		npc.isunderforce = npc.isunderforce - 1
	end)

	Timers:CreateTimer(2.0, function()
        if event.ability and npc and not npc:IsNull() and not event.ability:IsNull() then
	   	   event.ability:ApplyDataDrivenModifier(npc, npc, "modifier_phased", {Duration = 0.02})
        end
	end)
end

function ForceMovementPattern( event )
    local unit = event.target
    local caster = event.caster
    local speed = 15 --event.speed
    local angle = 5 --event.zigzag
    if unit:IsNull() or not unit:IsAlive() then
        return
    end
    if event.zigzag then
        event.fixedforce = 150
        if not event.is_already_initialized then
            --initial force is to the side
            event.is_already_initialized = true
            local forward = event.caster:GetForwardVector()
            local random_hero = COverthrowGameMode:PVERandomTargetNearTarget(caster, 2500)
            if random_hero then
                forward = (random_hero:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
            end
            local new_forward = RotateVectorAroundAngle(forward, -90)
            unit:SetForwardVector(new_forward)
            unit:SetAbsOrigin(unit:GetAbsOrigin()+new_forward*speed)
            unit.zigzag_angle = 0
        else
            --after initial direction, rotate a bit every tick
            local forward = unit:GetForwardVector()
            local new_forward
            --go straight after curve
            if ((unit.zigzag_angle % 361) >= 170 and (unit.zigzag_angle % 361) <= 190) or ((unit.zigzag_angle % 361) >= 350 or (unit.zigzag_angle % 361) <= 10) then
                angle = 0.5
            end
            if (unit.zigzag_angle % 361) < 180 then
                new_forward = RotateVectorAroundAngle(forward, angle)
            else
                new_forward = RotateVectorAroundAngle(forward, -angle)
            end
            unit:SetForwardVector(new_forward)
            unit:SetAbsOrigin(unit:GetAbsOrigin()+new_forward*speed)
            unit.zigzag_angle = unit.zigzag_angle + angle
        end
    end
    if event.circleout then
        if not event.is_already_initialized then
            --initial force is to back
            event.is_already_initialized = true
            local forward = event.caster:GetForwardVector()
            local new_forward = -forward
            unit:SetForwardVector(new_forward)
            unit:SetAbsOrigin(unit:GetAbsOrigin()+new_forward*speed+Vector(0,0,60))
            event.angle = 5
            if math.random(1,100) <= 50 then
                event.angle = -5
            end
        else
            event.angle = event.angle * 0.995
            local forward = RotateVectorAroundAngle(unit:GetForwardVector(), event.angle)
            unit:SetForwardVector(forward)
            unit:SetAbsOrigin(unit:GetAbsOrigin() + forward * speed * 1.5)
        end
    end
    if event.frombehindtofront then
        if not event.is_already_initialized then
            --initial force is to back
            event.is_already_initialized = true
            local forward = event.caster:GetForwardVector()
            local spawnpos = caster:GetAbsOrigin() - forward * 2000
            unit:SetAbsOrigin(spawnpos)
            local all = HeroList:GetAllHeroes()
            local random_target = all[math.random(1,#all)]
            local new_forward = (random_target:GetAbsOrigin() - spawnpos):Normalized()
            unit:SetForwardVector(new_forward)
            unit:SetAbsOrigin(unit:GetAbsOrigin()+new_forward*speed+Vector(0,0,60))
            event.forward = new_forward
        else
            speed = 25
            local forward = event.forward
            unit:SetAbsOrigin(unit:GetAbsOrigin()+forward*speed)
        end
    end
    Timers:CreateTimer(0.03, function()
        ForceMovementPattern( event )
    end)
end

function ForceOvertimeReset(event)
    event.caster.forceincreaseovertime = nil
end

function ArenaTeleporter( event )
	local caster = event.caster
	local npc = event.target
	local amount = event.amount
	local dir = 1
	local power = 1
	local vec = Vector(950,-480,500)
	if caster.teleporter == 2 then
		vec = Vector(-950,480,500)
	end

	local label = npc:GetUnitLabel()
	if label ~= "hero" and label ~= "pet" then
		return
	end

	Physics:Unit(npc)
	npc:PreventDI(false)
	npc:SetAutoUnstuck(true)
	npc:SetNavCollisionType(PHYSICS_NAV_BOUNCE)
	npc:FollowNavMesh(false)
	npc:SetPhysicsVelocityMax(2500)
	
	npc:SetPhysicsFriction(0.05)
	
	npc:Hibernate(false)
	npc:SetGroundBehavior(PHYSICS_GROUND_NOTHING)
	npc:SetPhysicsVelocity(vec)

	--root
	local table1 = {}
	table1.Duration = 1.0
	event.ability:ApplyDataDrivenModifier(npc, npc, "modifier_rootedteleporter", table1)

	Timers:CreateTimer(0.5, function()
		npc:AddPhysicsVelocity(Vector(0,0,-1050))
	end)

	Timers:CreateTimer(1.0, function()
		StopKnockBack(event)
		local table = {}
		table.Duration = 0.02
	   	event.ability:ApplyDataDrivenModifier(npc, npc, "modifier_phased", table)
	end)
end

-- DK

function InfestedWound( event )
	local target = event.target
	if target ~= nil and target:GetHealth() < target:GetMaxHealth()/2 then
		event.attributefactor = event.attributefactor * 1.3
	end
	DamageUnit(event)
end

function DeafeningCoil( event )
	local caster = event.caster
	local target = event.target
	local vec = caster:GetAbsOrigin()-target:GetAbsOrigin() 
	local power = (vec:Length()-200)/400.0
	if power < 0.0 then
		power = 0.0
	end
	
	if power > 1.0 then
		power = 1.0
	end

	local myevent = {}
	myevent.caster = event.caster
	myevent.target = target
	myevent.buff = "modifier_silence"
	myevent.ability = event.ability
	myevent.dur = event.duration*power
    if myevent.dur < 0.25 then
        myevent.dur = 0.25
    end
	ApplyBuff(myevent)

	if power < 1.0 then
		local myevent = {}
		myevent.caster = event.caster
		myevent.target = target
		myevent.buff = "modifier_unholyheal"
		myevent.ability = event.ability
		myevent.dur = event.duration*(1-power)
		ApplyBuff(myevent)
	end
end

function MulticastItem( event )
    local caster = event.caster
    local target = event.target
    local chance = 0
    local dur = 0.7 -- 2 procs, tick = 0.3
    local item = caster:HasModifier("modifier_item_frostfire2")
    if not caster:IsRealHero() and caster.owner then
        item = caster.owner:HasModifier("modifier_item_frostfire2")
    end
    if item then
        chance = 15
        dur = 1.0
    else
        --maybe frostfire old
        item = caster:HasModifier("modifier_item_frostfire")
        if not caster:IsRealHero() and caster.owner then
            item = caster.owner:HasModifier("modifier_item_frostfire")
        end
        if item then
            chance = 10
        end
    end
    if item and math.random(1,100) <= chance then
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_multicast_item", {Duration = dur})
    end
end

function DeathForLife( event )
	local caster = event.caster
	local target = event.target
	if caster ~= nil and target and target:HasModifier("modifier_rotdk") then
		--event.attributefactor = 0.0
		--event.spelldamagefactor = 0.0
		--event.heal = caster:GetMaxHealth()*0.04

		local abil = caster:FindAbilityByName("Rot") --[[Returns:handle
        Retrieve an ability by name from the unit.
        ]]
		--if abil:GetLevel() >= 2 then
		--	local particle = ParticleManager:CreateParticle("particles/items3_fx/octarine_core_lifesteal.vpcf", PATTACH_POINT_FOLLOW, caster)
		--	event.target = caster
			--HealUnit(event)
		--end
        --abil = caster:GetAbilityByIndex(1)
        if abil then
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.buff = "modifier_slow75"
            myevent.ability = abil
            myevent.dur = 5
            ApplyBuff(myevent)
        end
	end
end

-- Warlock ------------------------------------------------------------------

function RemoveTamerOfLegendsBonus(event)
    local caster = event.caster
    if caster.Pet and not caster.Pet:IsNull() then
        UTIL_Remove(caster.Pet)
        caster.Pet = nil
    end
end

function SummonPet (event)
	local caster = event.caster
	local owner = caster:GetOwner()
	local teamid = caster:GetTeamNumber()
	local origin = caster:GetAbsOrigin() + RandomVector(100)
    local ability = event.ability
	if caster.Pet ~= nil and not caster.Pet:IsNull() then
		UTIL_Remove(caster.Pet)
	end
    if caster.PermanentPet ~= nil and not caster.PermanentPet:IsNull() then
        UTIL_Remove(caster.PermanentPet)
    end

	if event.pet == "bear" then
		if caster:HasModifier("modifier_item_beastmaster") or caster:HasModifier("modifier_item_beastmaster2") then
			caster.Pet = CreateUnitByName("npc_dota_creature_wolf", origin, true, owner, nil, teamid)
			EmitSoundOn("hero_Lycan.SummonWolves", caster)
            caster.Pet.tamer_of_legends_wolf = true
		else
			caster.Pet = CreateUnitByName("npc_dota_creature_bear", origin, true, owner, nil, teamid)
			EmitSoundOn("Lycan_Wolf.PreAttack", caster)
		end
        
        
		caster.Pet:GetAbilityByIndex(0):SetLevel(event.ability:GetLevel())
		caster.Pet:GetAbilityByIndex(1):SetLevel(event.ability:GetLevel())
		caster.Pet:GetAbilityByIndex(3):SetLevel(event.ability:GetLevel())
        caster.Pet:GetAbilityByIndex(0):ToggleAutoCast()

        --local dmg = event.scale*caster:GetAverageTrueAttackDamage(caster)/100
        if caster:HasModifier("modifier_item_beastmaster2") then
            --dmg = dmg + 3000
            caster.Pet:SetModelScale(1.35)
        end
        --caster.Pet:SetBaseDamageMin(dmg)
        --caster.Pet:SetBaseDamageMax(dmg)
        event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_pet_system", nil)
	end
	if event.pet == "ghoul" then
		caster.Pet = CreateUnitByName("npc_dota_creature_ghoul", origin, true, owner, nil, teamid)
        caster.GhoulPet = caster.Pet
		if event.crit and event.crit > 0 then
			caster.Pet:AddAbility("pve_passive_as_25"):SetLevel(1)
		end
        --caster.Pet:SetBaseDamageMin(event.damageset*caster:GetStrength()/100)
        --caster.Pet:SetBaseDamageMax(event.damageset*caster:GetStrength()/100)
        if event.frenzymaster then
            caster.Pet:GetAbilityByIndex(1):SetLevel(event.frenzymaster)
        end
        event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_pet_system", nil)
	end
	if event.pet == "fel" then
		caster.Pet = CreateUnitByName("npc_dota_creature_felhunter", origin, true, owner, nil, teamid)
		--event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_felhunterfx", nil)
		caster.Pet:GetAbilityByIndex(0):StartCooldown(6.0)
		caster.Pet:GetAbilityByIndex(1):StartCooldown(6.0)
		event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_felhunterfx", nil)
		event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_aura_voidhp", nil)
		if caster.cosmetic_warlock_pet then
			local particle = ParticleManager:CreateParticle("particles/econ/items/enigma/enigma_world_chasm/enigma_world_chasm_ambient.vpcf", PATTACH_POINT_FOLLOW, caster.Pet)
			ParticleManager:SetParticleControlEnt(particle, 0, caster.Pet, PATTACH_POINT_FOLLOW, "attach_attack1", caster.Pet:GetAbsOrigin(), true)
			ParticleManager:SetParticleControlEnt(particle, 1, caster.Pet, PATTACH_POINT_FOLLOW, "attach_attack2", caster.Pet:GetAbsOrigin(), true)
            ParticleManager:ReleaseParticleIndex(particle)
		end
		if event.freecast and event.freecast == 1 then
			caster.Pet:AddAbility("Felhunter_Freecast"):SetLevel(1)
		end
		event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_pet_system", nil)
        if caster:HasModifier("modifier_class_warlock2") then
            caster.Pet:SetModel("models/items/lycan/wolves/_ascension_of_the_hallowed_beast_summons/_ascension_of_the_hallowed_beast_summons.vmdl")
            caster.Pet:SetOriginalModel("models/items/lycan/wolves/_ascension_of_the_hallowed_beast_summons/_ascension_of_the_hallowed_beast_summons.vmdl")
            caster.Pet:SetModelScale(1.25)
        end
	end
	--caster.Pet:SetPlayerID(owner:GetPlayerID())
 	caster.Pet:SetControllableByPlayer(caster:GetPlayerID(), true)
 	caster.Pet:CreatureLevelUp(event.ability:GetLevel()-1)

 	caster.Pet.owner = caster
    caster.PermanentPet = caster.Pet

 	local table = {}
 	table.Duration = 0.5
 	ability:ApplyDataDrivenModifier(event.caster, caster.Pet, "modifier_phased", table)

 	--instant sacrafice
 	if event.pet == "fel" and event.dur and event.dur > 0 then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_warlockrage", nil)
		--local tab = {}
		--tab.caster = caster.Pet
		--tab.amount = 60.0
        --tab.ability = ability
		--WarlockSacrifice(tab)
	end
end

function BuffPet (event)
	caster = event.caster
	if caster.Pet ~= nil then
		local table = {}
		table.Duration = event.dur
 		event.ability:ApplyDataDrivenModifier(event.caster, caster.Pet, "modifier_companion", table)
 	end
end

function Beastrage (event)
	caster = event.caster
    event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_beastrage", nil)
    caster:SetRenderColor(255, 0, 0)
	if caster.PermanentPet ~= nil and (not caster.PermanentPet:IsNull()) and caster.PermanentPet:IsAlive() then
 		event.ability:ApplyDataDrivenModifier(event.caster, caster.PermanentPet, "modifier_beastrage", nil)
 		caster.PermanentPet:SetRenderColor(255, 0, 0)
 	end
end

function BeastrageEnd(event)
	caster = event.caster
	caster:SetRenderColor(255, 255, 255)
	if caster.PermanentPet ~= nil and (not caster.PermanentPet:IsNull()) and caster.PermanentPet:IsAlive() then
 		caster.PermanentPet:SetRenderColor(255, 255, 255)
 	end
end

function BeastrageCD( event )
    local pet = event.attacker
    local caster = pet.owner
    if caster then
        local ability = caster:FindAbilityByName("Beastrage")
        if ability and ability:GetLevel() >= 3 then
            local myevent = {caster = caster, amount = 1, ability = ability }
            ReduceCooldown(myevent)
        end
    end
end

function Beastheal (event)
	local caster = event.caster
	if caster.Pet ~= nil then
 		event.ability:ApplyDataDrivenModifier(event.caster, caster.Pet, "modifier_beastheal", nil)
 	end
end

function BeasthealProc (event)
	local caster = event.attacker
	if caster ~= nil then
		local target = caster.owner
		if target ~= nil then
			event.heal = caster:GetMaxHealth()*event.amount/100
			event.attributefactor = 0.0
			event.spelldamagefactor = 0.0
			event.caster = target
			event.target = caster
			HealUnit(event)
			event.heal = target:GetMaxHealth()*event.amount/100
			event.target = target
			HealUnit(event)
			local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_lone_druid/lone_druid_bear_blink_start.vpcf", PATTACH_POINT_FOLLOW, target)
			ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
			ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
			particle = ParticleManager:CreateParticle("particles/units/heroes/hero_lone_druid/lone_druid_bear_blink_start.vpcf", PATTACH_POINT_FOLLOW, caster)
			ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
			ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
			if event.focus and event.focus > 0 then
                local myevent = {}
                myevent.caster = target
                myevent.energy = event.focus
                AddEnergy(myevent)
			end
		end
 	end
end

function PetFocusProc (event)
    local caster = event.attacker
    if caster ~= nil then
        local target = caster.owner
        if target ~= nil then
            AddEnergy({caster = target, energy = event.focus, energypercent = 1})
        end
    end
end

function BeasthealProcPassive(event)
	local caster = event.caster
	local pet = caster.Pet
	local amount = event.amount
	if caster then
		event.heal = caster:GetMaxHealth()*amount/100
		event.attributefactor = 0.0
		event.spelldamagefactor = 0.0
		event.caster = caster
		event.target = caster
		HealUnit(event)
		if pet and not pet:IsNull() then
			event.heal = pet:GetMaxHealth()*amount/100
			event.attributefactor = 0.0
			event.spelldamagefactor = 0.0
			event.caster = caster
			event.target = pet
			HealUnit(event)
	 	end
 	end
end

-- Druid

function Lifebloom(event)
	local caster = event.caster
	local ability = event.ability
    local range = 900
    local maxStacks = 3 + GetMaxBuffStackBonus(caster)
    local ally = FindClosestAlly(caster, caster:GetAbsOrigin(), range, false)
	local stackcount = 1
    local targets = {}
    table.insert(targets, caster)
    if ally and ally ~= caster then
        table.insert(targets, ally)
    end
    if ability:GetLevel() >= 4 then
        local mana = caster:GetMana()
        local cost = 35
        if event.freecast then
            cost = 0
        end
        targets = {}
        table.insert(targets, caster)
        local allTargets = FindNearbyAllies(caster, caster:GetAbsOrigin(), range)
        local targetsHealed = 1
        for i=1, #allTargets do
            local target = allTargets[i]
            if target ~= caster and (targetsHealed <= 1 or mana >= cost) then
                table.insert(targets, target)
                targetsHealed = targetsHealed + 1
                if targetsHealed >= 3 then
                    mana = mana - cost
                    caster:SetMana(caster:GetMana() - cost)
                end
            end
        end
    end
    for i=1, #targets do
        local target = targets[i]
        if target:HasModifier("modifier_lifebloom") or target:HasModifier("modifier_lifebloomfull") then
            if target:HasModifier("modifier_lifebloom") then
                stackcount = target:GetModifierStackCount("modifier_lifebloom", caster)+1
            else
                stackcount = target:GetModifierStackCount("modifier_lifebloomfull", caster)+1
            end

            if stackcount > maxStacks then
                stackcount = maxStacks
            end
            local evnt = {}
            evnt.Duration = event.dur
            target:RemoveModifierByName("modifier_lifebloom")
            target:RemoveModifierByName("modifier_lifebloomfull")
            if stackcount == maxStacks then
                local myevent = {}
                myevent.caster = caster
                myevent.target = target
                myevent.buff = "modifier_lifebloomfull"
                myevent.ability = ability
                myevent.dur = event.dur
                ApplyBuff(myevent)

                target:SetModifierStackCount("modifier_lifebloomfull", ability, stackcount)
            else
                local myevent = {}
                myevent.caster = caster
                myevent.target = target
                myevent.buff = "modifier_lifebloom"
                myevent.ability = ability
                myevent.dur = event.dur
                ApplyBuff(myevent)
                target:SetModifierStackCount("modifier_lifebloom", ability, stackcount)
            end
        else
            stackcount = 1
            target:RemoveModifierByName("modifier_lifebloom")
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.buff = "modifier_lifebloom"
            myevent.ability = ability
            myevent.dur = event.dur
            ApplyBuff(myevent)
            target:SetModifierStackCount("modifier_lifebloom", ability, stackcount)
        end
    end
end

function shapeshift_start( keys )
	if COverthrowGameMode.EnableShapeshift == 1 then
		local target = keys.target
		local model = keys.model
		local scale = 1.32
		--new form
		--if target.gladiator >= 1100 then
		--	model = "models/items/courier/jin_yin_black_fox/jin_yin_black_fox.vmdl"
		--	scale = 1.45
		--end
        --tree form
        if keys.ability:GetLevel() >= 4 then
          model = "models/heroes/treant_protector/treant_protector.vmdl"
          scale = 0.75--0.95
        end

        --fake cd to disable accidental shift out
        --keys.ability:EndCooldown()
        --keys.ability:StartCooldown(3.5)
        COverthrowGameMode:RemoveAllCosmeticsGlobal(target)
        HideWearables(keys)
		target:SetOriginalModel(model)
		target:SetModelScale(scale)
        if keys.ability:GetLevel() >= 4 then
            --print("attach feet")
            local feet = SpawnEntityFromTableSynchronous("prop_dynamic", {model = "models/heroes/treant_protector/legs.vmdl"})
            feet:FollowEntity(target, true)
            target.treantfeet = feet
            local head = SpawnEntityFromTableSynchronous("prop_dynamic", {model = "models/heroes/treant_protector/foliage.vmdl"})
            head:FollowEntity(target, true)
            target.treanthead = head
            local hand = SpawnEntityFromTableSynchronous("prop_dynamic", {model = "models/heroes/treant_protector/hands.vmdl"})
            hand:FollowEntity(target, true)
            target.treanthand = hand
        end
		
	end
	RemoveSlows(keys)
	if keys.rootremove and keys.rootremove == 1 then
		RemoveRoots(keys)
	end
end

function RemoveCosmetics(target)
	if target.tier1prop then
		target.tier1prop:RemoveSelf()
		target.tier1prop = nil
		target.tier1 = nil
	end
	if target.tier2prop then
		target.tier2prop:RemoveSelf()
		target.tier2prop = nil
		target.tier2 = nil
	end
	if target.tier3prop then
		target.tier3prop:RemoveSelf()
		target.tier3prop = nil
		target.tier3 = nil
	end
	if target.tier4prop then
		target.tier4prop:RemoveSelf()
		target.tier4prop = nil
		target.tier4 = nil
	end
end

function shapeshift_end( keys )
	if COverthrowGameMode.EnableShapeshift == 1 then
		local target = keys.target
		local model = keys.model
		-- Checking for errors

		target:SetModel(model)
		target:SetOriginalModel(model)
		target:SetModelScale(0.8)
		ShowWearables(keys)

        if target.treantfeet and not target.treantfeet:IsNull() then
            UTIL_Remove(target.treantfeet)
        end
        if target.treanthead and not target.treanthead:IsNull() then
            UTIL_Remove(target.treanthead)
        end
        if target.treanthand and not target.treanthand:IsNull() then
            UTIL_Remove(target.treanthand)
        end
        COverthrowGameMode:EquipArtifactCosmeticRewardsGlobal(target)
	end
	--target:Stop()
	--EndAnimation(target)
	--target:SetAnimation("taunt_bazooka")
end

function FurionRunAnimation( event )
	--StartAnimation(event.caster, {activity=ACT_DOTA_RUN, duration=1.2, rate=1.0})
end

function ShapeshiftOut( event )
	--print("out called")
	local caster = event.caster
	local ability = caster:GetAbilityByIndex(5)

	if not caster:HasModifier("modifier_shapeshifttravel") then
		return
	end
    --tree talent
    if ability:GetLevel() >= 4 then
        if event.event_ability then
            if event.event_ability:GetAbilityIndex() == 0 or event.event_ability:GetAbilityIndex() == 2 or event.event_ability:GetAbilityIndex() == 5 then
                --StartAnimation(caster, {activity=ACT_DOTA_ATTACK, duration=0.25, rate=2.5})
            else
                --StartAnimation(caster, {activity=ACT_DOTA_SPAWN, duration=1.5, rate=0.27})
            end
        end
        return
    end

	--Timers:CreateTimer(0.1, function()
		--print(event.event_ability:GetName())
		if event.event_ability and event.event_ability:GetName() ~= "Shapeshift" then
			ability:ToggleAbility()
		elseif event.ability:GetName() ~= "Shapeshift" then
			ability:ToggleAbility()
		end
		--if event.ability:GetName() == "Shapeshift" then
		--	StartAnimation(event.caster, {activity=ACT_DOTA_RUN, duration=1.2, rate=1.0})
		--end
		--event.ability:TOgg
	   	--caster:RemoveModifierByName("modifier_shapeshifttravel")
		--print(event.ability:GetToggleState())
	--end)
end

function ShapeshiftOutNow( keys )
	local caster = keys.caster
	caster.FurionAnimation = 1
	caster:RemoveModifierByName("modifier_shapeshifttravel")
	Timers:CreateTimer(0.05, function()
	   	EndAnimation(caster)
	   	StartAnimation(caster, {activity=ACT_DOTA_CAST_ABILITY_1, duration=1.95, rate=0.3})
	   	caster.FurionAnimation = nil
	end)
end

function ShapeshiftIn( event )
	local caster = event.caster

	if not caster:HasModifier("modifier_shapeshifttravel") then
		local table = {}
		table.Duration = -1
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_shapeshifttravel", table)
		--print("recur")
	end
end

function IceBlock(event)
	local caster = event.caster
	local target = event.target
	local healamount = event.heal
    local qualities = COverthrowGameMode:GetAllArtifactItemQuality(caster)
	local table = {}
	if caster:GetTeamNumber()==target:GetTeamNumber() then
		--table.Duration = event.duration
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_frostarmorbuff", table)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_frostarmorbuff"
		myevent.ability = event.ability
		myevent.dur = event.duration
		ApplyBuff(myevent)
        if event.ability:GetLevel() >= 4 then
            myevent.buff = "modifier_ice_armor"
            myevent.dur = 60
            ApplyBuff(myevent)
        end
        if qualities and qualities[2] and qualities[2] >= 7 then
            event.ability:ApplyDataDrivenModifier(target, target, "modifier_frostarmorbuff_fx", {Duration = event.duration})
        end
	else
		--table.Duration = event.duration/2
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_frostarmorbuff", table)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_frostarmorbuff"
		myevent.ability = event.ability
		myevent.dur = event.duration*event.percent/100
		ApplyBuff(myevent)
        if qualities and qualities[2] and qualities[2] >= 7 then
            event.ability:ApplyDataDrivenModifier(target, target, "modifier_frostarmorbuff_fx", {Duration = myevent.dur})
        end
	end
end

function ItemProc(event)
	local caster = event.attacker
	local target = event.target
	local proctype = event.proc
	if proctype == "haste" then
		local ability = event.event_ability
		if ability:GetName() == "ShapeshiftFeral" or ability:GetName() == "Shapeshift" then
			return
		end
		caster = event.caster
	end

	-- Basher
	if proctype == "stun" and not (caster:HasModifier("modifier_cdbasher")) then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_cdbasher", nil)
		local table = {}
		table.Duration = 3.5
		if caster:IsRangedAttacker() then
			table.Duration = 2.5
		end
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_stunned", table)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_stunned"
		myevent.ability = event.ability
		myevent.dur = table.Duration
		ApplyBuff(myevent)
		--fx
		--local particle = ParticleManager:CreateParticle("particles/econ/items/phantom_assassin/phantom_assassin_arcana_elder_smith/phantom_assassin_crit_impact_dagger_arcana.vpcf", PATTACH_POINT_FOLLOW, target)
    	--ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
		--ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
		--ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())

		local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5_gold/am_manaburn_basher_ti_5_gold.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)

		particle = ParticleManager:CreateParticle("particles/items2_fx/soul_ring_blood.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
		
		particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_bloodritual_impact_c.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
		
		
		

		EmitSoundOn( "DOTA_Item.DiffusalBlade.Kill", target)
	end

	-- Zeus
	if proctype == "zeus" and not (caster:HasModifier("modifier_cdzeus")) then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_cdzeus", nil)
		--fx
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_disruptor/disruptor_thunder_strike_aoe.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticle("particles/units/heroes/hero_disruptor/disruptor_thunder_strike_bolt.vpcf", PATTACH_POINT_FOLLOW, target)
    	ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticle("particles/units/heroes/hero_zuus/zuus_thundergods_wrath_start.vpcf", PATTACH_POINT_FOLLOW, target)
    	ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
		particle = ParticleManager:CreateParticle("particles/econ/items/zeus/lightning_weapon_fx/zuus_lightning_bolt_castfx_ground2.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
		--sound
		EmitSoundOn( "DOTA_Item.Mjollnir.Activate", target)
		--dmg
		DamageAOE(event)
	end

	-- Fury
	if proctype == "fury" and not (caster:HasModifier("modifier_cdfury")) then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_cdfury", nil)
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_wfproc", nil)
		--sound
		EmitSoundOn( "DOTA_Item.MaskOfMadness.Activate", caster)
	end
	-- Haste Proc 25%
	if proctype == "haste" and not (caster:HasModifier("modifier_cdhasteproc")) then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_cdhasteproc", {Duration = 15 * GetInnerCooldownFactor(caster)})
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_hasteproc25", nil)
		--sound
		EmitSoundOn( "DOTA_Item.MaskOfMadness.Activate", caster)
	end
	
end

function AstralGuardianProcs(event)
	local caster = event.caster
	local target = event.target
    if event.id then
    	if event.id <= 3 then
      		local stack = caster:GetModifierStackCount("modifier_mooncharge", caster)
      		if stack >= 5 then
                if GetLevelOfAbility(caster, "moon2") >= 3 then
                    local buffevent = { caster = caster, target = target, ability = caster:GetAbilityByIndex(2), aoe = 900, buff = "modifier_moon2", dur = 0.25, dontbreakccbuff = 1}
                    ApplyBuffAOE(buffevent)
                end
      			caster:RemoveModifierByName("modifier_mooncharge")	
    	    	if event.id == 1 then
    	    		event.amount = event.procmana
    	    		event.percent = 1
    	    		RestoreMana(event)
                    local ability_6 = caster:FindAbilityByName("moon6")
                    if not ability_6 then
                        ability_6 = caster:FindAbilityByName("moon6Temple")
                    end
                    if ability_6 then
                        ability_6:ApplyDataDrivenModifier(caster, caster, "modifier_astral_ele_bonus", {Duration = 60})
                    end
    	    	end
    	    	if event.id == 2 then
    	    		--event.max = 5
    	    		--event.buff = "modifier_suncharge"
    	    		--ApplyBuffStack(event)
    	    		--event.max = 5
    	    		--event.buff = "modifier_suncharge"
    	    		--ApplyBuffStack(event)
                    event.chooseability = 3
                    event.amount = 8
                    ReduceCooldown(event)
                    event.chooseability = 4
                    ReduceCooldown(event)
    	    	end
      		end
        else
        	local stack = caster:GetModifierStackCount("modifier_suncharge", caster)
      		if stack >= 5 then
                if GetLevelOfAbility(caster, "moon12") >= 3 then
                    local buffevent = { caster = caster, target = target, ability = caster:GetAbilityByIndex(2), aoe = 900, buff = "modifier_moon12", dur = 0.25, dontbreakccbuff = 1}
                    ApplyBuffAOE(buffevent)
                end
      			caster:RemoveModifierByName("modifier_suncharge")
    	    	if event.id == 4 then
    	    		--event.buff = "modifier_stunned"
    	    		--event.dur = event.stun
    	    		--ApplyBuff(event)
                    event.chooseability = 1
                    event.amount = 8
                    ReduceCooldown(event)
                    event.chooseability = 4
                    ReduceCooldown(event)
    	    	end
    	    	if event.id == 5 then
    	    		event.buff = "modifier_fairyfire"
    	    		event.dur = event.moondur
    	    		ApplyBuff(event)
    	    	end
                if event.id == 6 then
                    event.buff = "modifier_druid_sun_crit"
                    event.dur = 30
                    event.ability = caster:GetAbilityByIndex(5)
                    event.target = caster
                    ApplyBuff(event)
                end
      		end
        end
    end
    if event.comboid then
        if event.comboid == 2 then
            local stack = caster:GetModifierStackCount("modifier_mooncharge", caster)
            if stack >= 5 then
                caster.starfallDamage = 1.5
                caster:RemoveModifierByName("modifier_mooncharge")
                local ability_6 = caster:FindAbilityByName("moon6")
                if ability_6 and ability_6:GetCooldownTimeRemaining() < 1 then
                    ability_6:EndCooldown()
                    ability_6:StartCooldown(1)
                end
            end
        end
        local moon6 = caster:FindAbilityByName("moon6")
        if moon6 and moon6:GetLevel() >= 4 then
            if not caster.astral_procs then
                caster.astral_procs = {}
            end
            caster.astral_procs[event.comboid] = true
            for i=1,6 do
                if not caster.astral_procs[i] then
                    return
                end
            end
            for i=1,6 do
                caster.astral_procs[i] = false
            end
            for i=1,3 do
                Timers:CreateTimer(0.25*i, function()
                    AstralShock(caster)
                end)
            end
        end
    end
end

function AstralAOERoots(event)
	local caster = event.caster
	local stack = caster:GetModifierStackCount("modifier_suncharge", caster)
	if stack >= 5 then
		return
		CCTarget(event)
	end
end

function ChainLightningOld(event)
	local caster = event.caster
	local target = event.target
	local heroName = caster:GetUnitName()
	if heroName == "npc_dota_hero_disruptor" then
		event.attributefactor = event.attributefactor*1.4*event.reduction/100
		event.spelldamagefactor = event.spelldamagefactor*1.4*event.reduction/100
	else
		event.attributefactor = event.attributefactor*event.reduction/100
		event.spelldamagefactor = event.spelldamagefactor*event.reduction/100
	end
	
	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), target:GetAbsOrigin(), caster, 400, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	local damagedone = 0
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil and enemy ~= target and damagedone == 0 and ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower"))  then
				if not CheckForBreakableCC(enemy) then
					local oldtarget = event.target
					event.target = enemy
					damagedone = 1

					-- damage delayed
					Timers:CreateTimer(0.4, function()
						local thunderstacks = caster:GetModifierStackCount("modifier_ele_thunder_stacks", nil)
						DamageUnit( event )
						local vec1 = oldtarget:GetAbsOrigin()+Vector(0,0,150)
						local vec2 = event.target:GetAbsOrigin()+Vector(0,0,150)
						local particle = ParticleManager:CreateParticle("particles/econ/items/razor/razor_punctured_crest/razor_storm_lightning_strike_blade.vpcf", PATTACH_POINT_FOLLOW, event.target)
						ParticleManager:SetParticleControl(particle, 0, vec2)
						ParticleManager:SetParticleControl(particle, 1, vec1)
						ParticleManager:SetParticleControl(particle, 2, vec2)
                        ParticleManager:ReleaseParticleIndex(particle)
						EmitSoundOn( "DOTA_Item.Mjollnir.Activate", event.target)
						if thunderstacks >= 3 and event.stun and event.stun > 0 then
							local myevent = {}
							myevent.caster = caster
							myevent.target = enemy
							myevent.buff = "modifier_stunned"
							myevent.ability = event.ability
							myevent.dur = event.stun
							ApplyBuff(myevent)
						end
					end)
				end
			end
		end
	end

	--[[ double hit!
	if damagedone == 0 then
		Timers:CreateTimer(1.0, function()
		    
			local vec1 = caster:GetAbsOrigin()+Vector(0,0,150)
			local vec2 = event.target:GetAbsOrigin()+Vector(0,0,150)
			print(vec1)
			print(vec2)
			local particle = ParticleManager:CreateParticle("particles/econ/items/razor/razor_punctured_crest/razor_storm_lightning_strike_blade.vpcf", PATTACH_POINT_FOLLOW, event.target)
			ParticleManager:SetParticleControl(particle, 0, vec2)
			ParticleManager:SetParticleControl(particle, 1, vec1)
			ParticleManager:SetParticleControl(particle, 2, vec2)
			EmitSoundOn( "DOTA_Item.Mjollnir.Activate", event.target)
			DamageUnit( event )
		end)
		
	end
	]]
end


function ShapeshiftFeral(event)
	local caster = event.caster
	local level = caster:GetAbilityByIndex(5):GetLevel()
	if caster:HasModifier("modifier_catform") then
        -- to human form
        if not caster:HasModifier("modifier_feralcd") then
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_feralcd", {Duration = 30 * GetInnerCooldownFactor(caster)})
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_feraldef", {Duration = 5})
        end

        caster.resourcesystem = nil
        caster.Catform = 0
        caster:RemoveModifierByName("modifier_tigerfury")
		caster:RemoveModifierByName("modifier_combopoint")
		caster:RemoveModifierByName("modifier_season2gladiator")
		caster.ComboPoints = 0
		caster:RemoveModifierByName("modifier_catform")
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_catform_off", nil)
		
		caster.spell1 = caster:GetAbilityByIndex(0):GetLevel()
		caster.spell2 = caster:GetAbilityByIndex(1):GetLevel()
		caster.spell3 = caster:GetAbilityByIndex(2):GetLevel()
		caster.spell4 = caster:GetAbilityByIndex(3):GetLevel()
		caster.spell5 = caster:GetAbilityByIndex(4):GetLevel()
		caster:RemoveAbility("Feral2")
		caster:RemoveAbility("Feral3")
		caster:RemoveAbility("Feral4")
		caster:RemoveAbility("Feral1")
		caster:RemoveAbility("Feral5")
		caster:AddAbility("RegrowthFeral")
		caster:GetAbilityByIndex(0):SetLevel(level)
		caster:AddAbility("RootsDruidFeral")
		caster:GetAbilityByIndex(1):SetLevel(level)
		--if caster:HasModifier("modifier_feralpowercast") then
 		--	caster:AddAbility("CycloneDruidFeralInstant")
		--else
			caster:AddAbility("CycloneDruidFeral")
		--end
		caster:GetAbilityByIndex(2):SetLevel(level)
		caster:AddAbility("empty_spell1")
		caster:GetAbilityByIndex(3):SetLevel(1)
		caster:AddAbility("empty_spell2")
		caster:GetAbilityByIndex(4):SetLevel(1)
        CheckForMaxManaCap(caster)
        caster:SetMana(caster:GetMaxMana()) --(caster.OldMana)
		--model change
		if COverthrowGameMode.EnableShapeshift == 1 then
			local model = "models/heroes/dazzle/dazzle.vmdl"
			caster:SetOriginalModel(model)
			caster:SetModelScale(0.80)
			ShowWearables(event)
			StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
            COverthrowGameMode:EquipArtifactCosmeticRewardsGlobal(caster)
		end
	else 
        -- to feral form
        caster.resourcesystem = 4
        caster.Catform = 1
		caster.OldMana = caster:GetMana()
        caster:RemoveModifierByName("modifier_catform_off")
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_catform", nil)
        if caster.feralfirstshift then
    		caster:RemoveAbility("RegrowthFeral")
    		caster:RemoveAbility("RootsDruidFeral")
    		caster:RemoveAbility("CycloneDruidFeral")
    		caster:RemoveAbility("CycloneDruidFeralInstant")
    		caster:RemoveAbility("empty_spell1")
    		caster:RemoveAbility("empty_spell2")
    		caster:AddAbility("Feral2")
    		caster:GetAbilityByIndex(0):SetLevel(caster.spell1)
    		caster:AddAbility("Feral3")
    		caster:GetAbilityByIndex(1):SetLevel(caster.spell2)
    		caster:AddAbility("Feral4")
    		caster:GetAbilityByIndex(2):SetLevel(caster.spell3)
    		caster:AddAbility("Feral1")
    		caster:GetAbilityByIndex(3):SetLevel(caster.spell4)
    		caster:AddAbility("Feral5")
    		caster:GetAbilityByIndex(4):SetLevel(caster.spell5)
        else
            caster.feralfirstshift = true
        end
        CheckForMaxManaCap(caster)
		--model change, only when synced
		if COverthrowGameMode.EnableShapeshift == 1 then
            COverthrowGameMode:RemoveAllCosmeticsGlobal(caster)
			local model = "models/items/lycan/wolves/hunter_kings_wolves/hunter_kings_wolves.vmdl"
			local scale = 0.9
			--new form
			if caster.artifact_offhand and caster.artifact_offhand == 6 then
				model = "models/items/lycan/wolves/blood_moon_hunter_wolves/blood_moon_hunter_wolves.vmdl"
				scale = 0.9
			end
            if caster.artifact_offhand and caster.artifact_offhand == 7 then
                model = "models/items/lycan/ultimate/blood_moon_hunter_shapeshift_form/blood_moon_hunter_shapeshift_form.vmdl"
                scale = 0.7
            end
            if caster.season2_2vs2 and caster.season2_2vs2 == 1 then
                model = "models/items/lycan/ultimate/hunter_kings_trueform/hunter_kings_trueform.vmdl"
                scale = 0.65
            end

			caster.old_model = caster:GetModelName()
			caster:SetOriginalModel(model)
			caster:SetModelScale(scale)
			HideWearables(event)

			StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
			if caster.season2_2vs2 and caster.season2_2vs2 == 1 then
				caster:GetAbilityByIndex(5):ApplyDataDrivenModifier(caster, caster, "modifier_season2gladiator", nil)
			end
		end
		
	end
end


function RemoveInstantAbility(event)
	local caster = event.caster
	local target = event.target
	Timers:CreateTimer(0.1, function()
		if caster:GetAbilityByIndex(event.position-1):GetName() == "CycloneDruidFeralInstant" then
			caster:RemoveAbility("CycloneDruidFeralInstant")
			caster:AddAbility("CycloneDruidFeral")
			caster:GetAbilityByIndex(2):SetLevel(caster:GetAbilityByIndex(5):GetLevel())
			caster:GetAbilityByIndex(2):StartCooldown(15.0)
			--local tab = {}
			--tab.Duration = event.time*GetCCPower(event)
			--caster:GetAbilityByIndex(2):ApplyDataDrivenModifier(caster, target, "modifier_cyclone_self", tab)

			local myevent = {}
			myevent.caster = caster
			myevent.target = target
			myevent.buff = "modifier_cyclone_self"
			myevent.ability = caster:GetAbilityByIndex(2)
			myevent.dur = event.time*GetCCPower(event)
			ApplyBuff(myevent)
			--print(tab.Duration)
		end
	end)
end

function FeralAttackHeal(event)
	local caster = event.attacker
	if caster ~= nil and caster:GetUnitName() == "npc_dota_hero_dazzle" then
		event.caster = caster
		event.target = caster
		event.heal = GetStrengthCustom(caster)*0.4
		event.spelldamagefactor = 0.0
		event.attributefactor = 0.0
		HealUnit(event)
		particle = ParticleManager:CreateParticle("particles/units/heroes/hero_dazzle/dazzle_shadow_wave_magic.vpcf", PATTACH_POINT_FOLLOW, caster)
		ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
		ParticleManager:ReleaseParticleIndex(particle)
	end
end

function Feral5(event)
	local caster = event.caster
	local target = event.target
	
	Timers:CreateTimer(0.35, function()
			if target:IsAlive() then
				local vec2 = RandomVector(125)
				local vec = target:GetAbsOrigin()+Vector(vec2[1],vec2[2],0)
				caster:SetAbsOrigin(vec)
			end
		end)
end

function Bleed1(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	
	--[[
	if target:HasModifier("modifier_bleed1_1") then
		target:RemoveModifierByName("modifier_bleed1_1")
		ability:ApplyDataDrivenModifier(caster, target, "modifier_bleed1_2", nil)
		target:SetModifierStackCount("modifier_bleed1_2", ability, 2)
	elseif target:HasModifier("modifier_bleed1_2") then
		target:RemoveModifierByName("modifier_bleed1_2")
		ability:ApplyDataDrivenModifier(caster, target, "modifier_bleed1_3", nil)
		target:SetModifierStackCount("modifier_bleed1_3", ability, 3)
	elseif target:HasModifier("modifier_bleed1_3") then
		target:RemoveModifierByName("modifier_bleed1_3")
		ability:ApplyDataDrivenModifier(caster, target, "modifier_bleed1_3", nil)
		target:SetModifierStackCount("modifier_bleed1_3", ability, 3)
	else
		ability:ApplyDataDrivenModifier(caster, target, "modifier_bleed1_1", nil)
		target:SetModifierStackCount("modifier_bleed1_1", ability, 1)
	end--]]

	if target:HasModifier("modifier_bleedslow") then
		local stackcount = target:GetModifierStackCount("modifier_bleedslow", caster)+1
		if stackcount > 3 then
			stackcount = 3
		end
		target:RemoveModifierByName("modifier_bleedslow")
		--ability:ApplyDataDrivenModifier(caster, target, "modifier_bleedslow", nil)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_bleedslow"
		myevent.ability = ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		target:SetModifierStackCount("modifier_bleedslow", ability, stackcount)
	else
		--ability:ApplyDataDrivenModifier(caster, target, "modifier_bleedslow", nil)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_bleedslow"
		myevent.ability = ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		target:SetModifierStackCount("modifier_bleedslow", ability, 1)
	end
end

function HealAbsorb(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability

	local stackcount = target:GetModifierStackCount("modifier_healabsorb", caster)

	local stackcount = stackcount + event.amount*GetPrimaryStatValueCustom(caster)/100

	local tab = {}
	tab.Duration = event.dur
	target:RemoveModifierByName("modifier_healabsorb")
	--ability:ApplyDataDrivenModifier(caster, target, "modifier_healabsorb", tab)

	local myevent = {}
	myevent.caster = caster
	myevent.target = target
	myevent.buff = "modifier_healabsorb"
	myevent.ability = ability
	myevent.dur = event.dur
	ApplyBuff(myevent)

	target:SetModifierStackCount("modifier_healabsorb", ability, stackcount)
	target.healabsorbability = ability
end

function FeralFinisher(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    
    if caster.ComboPoints > 0 then
        if event.mana and event.mana > 0 then
            caster.OldMana = caster.OldMana + event.mana*caster.ComboPoints
        end
        --caster.FeralPowerCast = 1 + caster.ComboPoints/5
        if caster.ComboPoints >= 4 then
            ability:ApplyDataDrivenModifier(caster, caster, "modifier_instantbolt", nil)
            caster:SetModifierStackCount("modifier_instantbolt", ability, 1)
            if ability:GetLevel() >= 2 then
                AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 250, aacrit_chance = 100})
            end
        end
        --caster:SetModifierStackCount("modifier_feralpowercast", ability, caster.ComboPoints)
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_dazzle/dazzle_shadow_wave_magic.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
        ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)

        
        caster.FeralFinisher = caster.ComboPoints / 4
        if ConsumeComboPoints(caster, target) then
            caster.ComboPoints = 0
            caster:RemoveModifierByName("modifier_combopoint")
        end
        --ability:ApplyDataDrivenModifier(caster, target, "modifier_bleed2", nil)

        if event.chance and event.chance < 100 then
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.buff = "modifier_bleed2"
            myevent.ability = ability
            myevent.dur = event.dur
            myevent.settickrate = 1
            ApplyBuff(myevent)
        else
            for i=0, 3 do
                Timers:CreateTimer(0.20*i, function()
                    local myevent = {}
                    myevent.caster = caster
                    myevent.target = target
                    myevent.damage = 0.0
                    myevent.attributefactor = event.dmgfromstat * caster.FeralFinisher
                    myevent.attributechangestragi = 1
                    myevent.ability = ability
                    --myevent.feral4x = 1
                    myevent.critchancefactor = event.critchancefactor
                    myevent.t3bonus = event.t3bonus
                    DamageUnit(myevent)
                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_POINT_FOLLOW, target)
                    ParticleManager:ReleaseParticleIndex(particle)
                    EmitSoundOn("Hero_LoneDruid.TrueForm.Attack", target)
                end)
            end
        end
    end
end

function ShieldBash(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local stackcount = 0
    local stacks_added = 1
    if caster:HasModifier("modifier_npc_dota_hero_dragon_knight") then
        stacks_added = 5
    end
	if caster:HasModifier("modifier_shieldbash") then

		stackcount = caster:GetModifierStackCount("modifier_shieldbash", caster) + stacks_added
		if stackcount > event.stacks then
			stackcount = event.stacks
		end
		target:RemoveModifierByName("modifier_shieldbash")
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_shieldbash", nil)
		caster:SetModifierStackCount("modifier_shieldbash", ability, stackcount)
	else
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_shieldbash", nil)
		stackcount = stacks_added
		caster:SetModifierStackCount("modifier_shieldbash", ability, stackcount)
	end

	event.shieldbashbonus = stackcount
	DamageUnit(event)

end

function SwordSwipe(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local stackcount = 0
	caster.swordSwipeLevel = ability:GetLevel()
	local range = 250

	local targetamount = 0

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), event.target_points[1], caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower")) then
					targetamount = targetamount + 1
				end
			end
		end
	end

    if targetamount > event.swordcap then
        targetamount = event.swordcap
    end
	event.attributefactor = event.attributefactor + event.attributefactor*targetamount*event.aoebonus/100
    --event.includeauto = event.includeauto + event.includeauto*targetamount*event.aoebonus/100

	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower")) then
                    if CountBuffs( caster, "modifier_prot_str_bonus" ) <= 30 then
					   ability:ApplyDataDrivenModifier(caster, caster, "modifier_prot_str_bonus", nil)
                    end
					local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_POINT_FOLLOW, enemy)
                    ParticleManager:ReleaseParticleIndex(particle)
					event.target = enemy
					DamageUnit(event)
				end
			end
		end
	end

end
	
function Crush(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local pos = event.target_points[1]
	local range = 250

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )

	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower")) then
					local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_POINT_FOLLOW, enemy)
                    ParticleManager:ReleaseParticleIndex(particle)
					--ability:ApplyDataDrivenModifier(caster, enemy, "modifier_slow25", nil)

					local myevent = {}
					myevent.caster = caster
					myevent.target = enemy
					myevent.buff = "modifier_slow25"
					myevent.ability = ability
					myevent.dur = event.dur
					ApplyBuff(myevent)
				end
			end
		end
	end

	Timers:CreateTimer(3.0, function()
        if event.thunder and event.thunder > 0 then
            particle = ParticleManager:CreateParticle("particles/units/heroes/hero_disruptor/disruptor_thunder_strike_bolt.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
            ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
            ParticleManager:SetParticleControl(particle, 2, caster:GetAbsOrigin())
            ParticleManager:SetParticleControl(particle, 3, caster:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn( "DOTA_Item.Mjollnir.Activate", caster)
            Timers:CreateTimer(0.5, function()
                particle = ParticleManager:CreateParticle("particles/units/heroes/hero_disruptor/disruptor_thunder_strike_bolt.vpcf", PATTACH_POINT_FOLLOW, caster)
                ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
                ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
                ParticleManager:SetParticleControl(particle, 2, caster:GetAbsOrigin())
                ParticleManager:SetParticleControl(particle, 3, caster:GetAbsOrigin())
                ParticleManager:ReleaseParticleIndex(particle)
                EmitSoundOn( "DOTA_Item.Mjollnir.Activate", caster)
            end)
            Timers:CreateTimer(1.0, function()
                particle = ParticleManager:CreateParticle("particles/units/heroes/hero_disruptor/disruptor_thunder_strike_bolt.vpcf", PATTACH_POINT_FOLLOW, caster)
                ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
                ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
                ParticleManager:SetParticleControl(particle, 2, caster:GetAbsOrigin())
                ParticleManager:SetParticleControl(particle, 3, caster:GetAbsOrigin())
                ParticleManager:ReleaseParticleIndex(particle)
                EmitSoundOn( "DOTA_Item.Mjollnir.Activate", caster)
            end)
        else
		    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ursa/ursa_earthshock.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn( "Hero_DragonKnight.BreathFire", caster)
        end
        
        local procs = 1
        if event.thunder and event.thunder > 0 then
            procs = 3
        end
        for k=1,procs do
            Timers:CreateTimer(0.05+(0.5*(k-1)), function()
        		local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
        		if #enemies > 0 then
        			for _,enemy in pairs(enemies) do
        				if enemy ~= nil then
        					if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower")) then
                                if k == 1 then
            						local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_POINT_FOLLOW, enemy)
                                    ParticleManager:ReleaseParticleIndex(particle)
            						local myevent = {}
            						myevent.caster = caster
            						myevent.target = enemy
            						myevent.buff = "modifier_slow75"
            						myevent.ability = ability
            						myevent.dur = event.dur
            						ApplyBuff(myevent)
                                end
                                if event.thunder and event.thunder > 0 then
                                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_disruptor/disruptor_thunder_strike_aoe.vpcf", PATTACH_ABSORIGIN_FOLLOW, enemy)
                                    ParticleManager:ReleaseParticleIndex(particle)
                                    local myevent = {}
                                    myevent.caster = caster
                                    myevent.target = enemy
                                    myevent.ability = ability
                                    myevent.damage = 0.0
                                    myevent.spelldamagefactor = 0.0
                                    myevent.attributefactor = event.thunder
                                    myevent.naturedmg = 1
                                    myevent.isaoe = 1
                                    DamageUnit(myevent)
                                end
        					end
        				end
        			end
        		end
    	   end)
        end
    end)
end

function CloakOfConceal(event)
	local caster = event.caster
	local heroName = caster:GetUnitName()
	if heroName == "npc_dota_hero_phantom_assassin" or heroName == "npc_dota_hero_riki" or heroName == "npc_dota_hero_bounty_hunter" or COverthrowGameMode.junglemode  then

		local target = event.target
		local ability = event.ability
		local pos = event.target_points[1]
		local range = 450

		local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )

		local tab = {}
		tab.Duration = 12
		if #enemies > 0 then
			for _,enemy in pairs(enemies) do
				if enemy ~= nil then
					if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) and not enemy:IsNull() then
						local particle = ParticleManager:CreateParticle("particles/generic_gameplay/rune_invisibility_refract_plasma_sparks.vpcf", PATTACH_POINT_FOLLOW, enemy)
                        ParticleManager:ReleaseParticleIndex(particle)
						ability:ApplyDataDrivenModifier(caster, enemy, "modifier_invisible", tab)
						ability:ApplyDataDrivenModifier(caster, enemy, "modifier_cloakitem", tab)
					end
				end
			end
		end
	end
end

function Counterblow( event )
	local target = event.target
	local caster = event.caster

    local myevent = {}
	if event.protstun and event.protstun > 0.0 then
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_stunned"
		myevent.ability = event.ability
		myevent.dur = event.protstun
	end
	DamageUnit(event)
    if event.protstun and event.protstun > 0.0 then
        ApplyBuff(myevent)
    end
end

function Kingsguard( event )
	local target = event.target
	local caster = event.caster
	local vec = (event.target:GetAbsOrigin()-event.caster:GetAbsOrigin()):Length()

	if vec >= 900 then
		target:RemoveModifierByName("modifier_kingsguard")
	end
end

function SwitchStancesProt(event)

	local hero = event.caster
	local abil1 = hero:GetAbilityByIndex(0)
	local abil2 = hero:GetAbilityByIndex(1)
	local abil3 = hero:GetAbilityByIndex(2)

	if abil1:GetAbilityName() == "Protect1" then
		--print("to defensive")
		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_defstance", nil)
        hero:RemoveModifierByName("modifier_offstance")
		hero.abil1=abil1:GetLevel()
		hero.abil2=abil2:GetLevel()
		hero.abil3=abil3:GetLevel()

  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:RemoveAbility(abil3:GetAbilityName())

  		hero:AddAbility("WarriorCharge")
  		hero:FindAbilityByName("WarriorCharge"):SetLevel(hero:FindAbilityByName("Switch_Battle_Stance_Prot"):GetLevel())
  		hero:AddAbility("Shield_Reflect")
  		hero:FindAbilityByName("Shield_Reflect"):SetLevel(hero:FindAbilityByName("Switch_Battle_Stance_Prot"):GetLevel())
  		hero:AddAbility("Terror_ShoutProt")
  		hero:FindAbilityByName("Terror_ShoutProt"):SetLevel(hero:FindAbilityByName("Switch_Battle_Stance_Prot"):GetLevel())
        --fix charges
        hero:RemoveModifierByName("modifier_charges")
        hero:RemoveModifierByName("modifier_charges")
        hero:RemoveModifierByName("modifier_charges")
  	else
  		--print("to offensive")
        if event.alwaysdef and event.alwaysdef == 1 then
            event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_offstance", nil)
        end
  		hero:RemoveModifierByName("modifier_defstance")
  		-- fix crash on switch while charging
		if hero:HasModifier("modifier_WarriorCharge") then
	 		Timers:CreateTimer(1.0,function() 
		        fixChargeStanceSwitchProt(hero)
		    end)
		else
	  		hero:RemoveAbility(abil1:GetAbilityName())
	  		hero:AddAbility("Protect1")
	  		hero:FindAbilityByName("Protect1"):SetLevel(hero.abil1)
		end



  		

  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:AddAbility("Protect2")
  		hero:FindAbilityByName("Protect2"):SetLevel(hero.abil2)

  		hero:RemoveAbility(abil3:GetAbilityName())
  		hero:AddAbility("Protect3")
  		hero:FindAbilityByName("Protect3"):SetLevel(hero.abil3)
  		
        --fix charges
        local abilityName = "Protect1"
        local ability = hero:FindAbilityByName(abilityName)
        if ability then
            hero[abilityName.."_is_init"] = true
            hero:AddNewModifier(hero, ability, "modifier_charges",
                {
                    max_count = 5,
                    start_count = 1,
                    replenish_time = 3
                }
            )
        end
  	end
end

function fixChargeStanceSwitchProt(hero)
	if hero:HasModifier("modifier_WarriorCharge") then
 		Timers:CreateTimer(1.0,function() 
	        fixChargeStanceSwitchProt(hero)
	    end)
	else
		local abil1 = hero:GetAbilityByIndex(0)
  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:AddAbility("Protect1")
  		hero:FindAbilityByName("Protect1"):SetLevel(hero.abil1)
	end
end

function SwitchStancesFury(event)

	local hero = event.caster
	local abil1 = hero:GetAbilityByIndex(0)
	local abil2 = hero:GetAbilityByIndex(1)
	local abil3 = hero:GetAbilityByIndex(2)

	if abil1:GetAbilityName() == "fury1" then
		--print("to defensive")
		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_defstance", nil)
		hero.abil1=abil1:GetLevel()
		hero.abil2=abil2:GetLevel()
		hero.abil3=abil3:GetLevel()

  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:RemoveAbility(abil3:GetAbilityName())

  		hero:AddAbility("WarriorCharge")
  		hero:FindAbilityByName("WarriorCharge"):SetLevel(hero:FindAbilityByName("fury6"):GetLevel())
  		hero:AddAbility("Shield_Reflect")
  		hero:FindAbilityByName("Shield_Reflect"):SetLevel(hero:FindAbilityByName("fury6"):GetLevel())
  		hero:AddAbility("Terror_ShoutFury")
  		hero:FindAbilityByName("Terror_ShoutFury"):SetLevel(hero:FindAbilityByName("fury6"):GetLevel())
        --fix charges
        hero:RemoveModifierByName("modifier_charges")
        hero:RemoveModifierByName("modifier_charges")
        hero:RemoveModifierByName("modifier_charges")
  	else
  		--print("to offensive")
  		hero:RemoveModifierByName("modifier_defstance")
  		-- fix crash on switch while charging
		if hero:HasModifier("modifier_WarriorCharge") then
	 		Timers:CreateTimer(1.0,function() 
		        fixChargeStanceSwitchFury(hero)
		    end)
		else
	  		hero:RemoveAbility(abil1:GetAbilityName())
	  		hero:AddAbility("fury1")
	  		hero:FindAbilityByName("fury1"):SetLevel(hero.abil1)
		end

  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:AddAbility("fury2")
  		hero:FindAbilityByName("fury2"):SetLevel(hero.abil2)

  		hero:RemoveAbility(abil3:GetAbilityName())
  		hero:AddAbility("fury3")
  		hero:FindAbilityByName("fury3"):SetLevel(hero.abil3)
  		
        --fix charges
        local abilityName = "fury1"
        local ability = hero:FindAbilityByName(abilityName)
        if ability then
            hero[abilityName.."_is_init"] = true
            hero:AddNewModifier(hero, ability, "modifier_charges",
                {
                    max_count = 5,
                    start_count = 1,
                    replenish_time = 1.5
                }
            )
        end
  	end
end

function fixChargeStanceSwitchFury(hero)
	if hero:HasModifier("modifier_WarriorCharge") then
 		Timers:CreateTimer(1.0,function() 
	        fixChargeStanceSwitchFury(hero)
	    end)
	else
		local abil1 = hero:GetAbilityByIndex(0)
  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:AddAbility("fury1")
  		hero:FindAbilityByName("fury1"):SetLevel(hero.abil1)
	end
end

function LightningFurySetup( event )
	local target = event.caster
	if target.LFury then
		if target.LFury > 0 then
			target.LFury = target.LFury + event.charges
		else
			target.LFury = event.charges + 1
		end
	else
		target.LFury = event.charges + 1
	end
end

function LightningFury( event )
	local caster = event.attacker
	caster.LFury = caster.LFury - 1
	if caster.LFury <= 0 then
		caster:RemoveModifierByName("modifier_lightningfury")
		caster.LFury = 0
	end
end

function LightningFuryEnd( event )
	event.target.LFury = 0
end

function GhostWolf1(event)
	local caster = event.caster
	local unit = event.target
	unit.owner = caster
	caster.Pet1 = unit
	unit:CreatureLevelUp(event.ability:GetLevel()-1)

	unit:SetHullRadius(35)
end

function GhostWolf2(event)
	local caster = event.caster
	local unit = event.target
	unit.owner = caster
	caster.Pet2 = unit
	unit:CreatureLevelUp(event.ability:GetLevel()-1)

	unit:SetHullRadius(35)
end

function GhostWolfAttack (event)
	local caster = event.attacker
	local damage = event.heal
	local target = caster.owner
	if target ~= nil then
		target:SetMana(target:GetMana()+damage)
		--target:SetHealth(target:GetHealth()+damage)
		--local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_rubick/rubick_fade_bolt_head_b.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_skeletonking/wraith_king_vampiric_aura_lifesteal.vpcf", PATTACH_POINT_FOLLOW, target)
        
		--ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
		ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
		event.target = target
		event.caster = target	
		HealUnit(event)
	end
end

function PetLifestealOwner(event)
	local caster = event.attacker
    if event.factor then
        event.heal = event.factor * event.heal / 100
    end
	local target = caster.owner
	if target ~= nil then
		local particle = ParticleManager:CreateParticle("particles/generic_gameplay/generic_lifesteal_lanecreeps.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
		--ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
		event.target = target
		event.caster = target
		HealUnit(event)
	end
end

function StormWard(event)
	local caster = event.caster
	local unit = event.target
    caster.stormfuryTotem = unit
	unit.owner = caster
	if event.offset ~= nil then
		unit:SetAbsOrigin(unit:GetAbsOrigin()+Vector(event.offset,0,0))
	end
	unit:CreatureLevelUp(event.ability:GetLevel()-1)
	event.target:SetForwardVector(Vector(0,-1,0))
	unit:SetRenderColor(255, 255, 255)
	EmitSoundOn("DOTA_Item.Cyclone.Activate", unit)
end

function WFTotem(event)
	local caster = event.caster
	if caster and caster:HasModifier("modifier_stormaurabuff1") then
		local abil = caster:FindAbilityByName("Ghost1")
		if abil then
			if event.ability:GetLevel() >= 4 then
				--aoe talent
				local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetOrigin(), caster, 99999, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
				if #enemies > 0 then
					for _,enemy in pairs(enemies) do
						if enemy ~= nil then
							if enemy:HasModifier("modifier_stormaurabuff1") then
								local myevent = {}
								myevent.caster = caster
								myevent.target = enemy
								myevent.buff = "modifier_lightningfury"
								myevent.ability = abil
								myevent.dur = nil
								myevent.charges = event.charges
								ApplyBuff(myevent)
								local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_brewmaster/brewmaster_windwalk_sparks.vpcf", PATTACH_POINT_FOLLOW, enemy)
                                ParticleManager:ReleaseParticleIndex(particle)
								EmitSoundOn("DOTA_Item.Cyclone.Activate", enemy)
								myevent.caster = enemy
								LightningFurySetup(myevent)
							end
						end
					end
				end
			else
				abil:ApplyDataDrivenModifier(caster, caster, "modifier_lightningfury", nil)
				local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_brewmaster/brewmaster_windwalk_sparks.vpcf", PATTACH_POINT_FOLLOW, caster)
                ParticleManager:ReleaseParticleIndex(particle)
				EmitSoundOn("DOTA_Item.Cyclone.Activate", caster)
				LightningFurySetup(event)
			end
		end
	end
end

function SummonSuccubus(event)
	--local caster = event.caster
	local unit = event.target
	local caster = event.caster
	
	if caster.Pet ~= nil and not caster.Pet:IsNull() then
		UTIL_Remove(caster.Pet)
	end
	
	local vec = caster:GetForwardVector():Normalized()*event.offset
	if event.offset ~= nil then
		unit:SetAbsOrigin(unit:GetAbsOrigin()+vec)
	end
	unit:CreatureLevelUp(event.ability:GetLevel()-1)
	caster.Pet = unit
	unit.owner = caster
	--Attachments:AttachProp(unit, "attach_hitloc", "models/items/queenofpain/unchained_tormented_wings/unchained_tormented_wings.vmdl", 1.0)
	--Attachments:AttachProp(unit, "mouth", "models/items/queenofpain/dotapit_s3_abyssal_temptress_head/dotapit_s3_abyssal_temptress_head.vmdl", 1.0)
	
	local ability = unit:GetAbilityByIndex(0)
	if ability and event.ability then
		ability:SetLevel(event.ability:GetLevel())
	end
	ability = unit:GetAbilityByIndex(1)
	if ability and event.ability then
		ability:SetLevel(event.ability:GetLevel())
	end
end

function SummonImpReset(event)
    local caster = event.caster
    caster.impcounter = 1
    for i=1,3 do
        if caster.imps and caster.imps[i] and not caster.imps[i]:IsNull() then
            UTIL_Remove(caster.imps[i])
            caster.imps[i] = nil
        end
    end
    caster.imps = {}
end

function SummonImp(event)
	--local caster = event.caster
	local unit = event.target
	local caster = event.caster

	unit:CreatureLevelUp(event.ability:GetLevel()-1)
	unit.owner = caster

    if caster:HasModifier("modifier_class_pugna2") then
        unit:SetOriginalModel("models/creeps/lane_creeps/creep_2021_dire/creep_2021_dire_ranged.vmdl")
    end

    local health = caster:GetMaxHealth() * 0.2
    unit:SetBaseMaxHealth(health)
    unit:SetMaxHealth(health)
    unit:SetHealth(health)
    caster.imps[caster.impcounter] = unit
    caster.impcounter = caster.impcounter + 1

    CruelTaskmasterHeal(caster, event.ability, unit)
    OnSummonedUnit(unit, caster)
end

function ImpFireballProc(event)
    local target = event.target
    local caster = event.caster
    if caster:HasModifier("modifier_class_pugna2") then
        if event.spellid == 1 then
            return
        end
    else
        if event.spellid == 4 then
            return
        end
    end
    local ability = caster:FindAbilityByName("destro6")
    if ability then
        for i=1,3 do
            if ability and caster.imps and caster.imps[i] and not caster.imps[i]:IsNull() and caster.imps[i]:IsAlive() then
                ability:ApplyDataDrivenModifier(caster.imps[i], target, event.buff, nil)
            end
        end
    end
end

function UriSummonCheck(event)
    local caster = event.caster
    if caster:GetName() == "npc_dota_hero_enchantress" then
        caster:FindAbilityByName("ench1"):ApplyDataDrivenModifier(caster, caster, "modifier_spawn_uri", nil)
    end
end

function SummonUri(event)
    --local caster = event.caster
    local unit = event.target
    local caster = event.caster

    unit:CreatureLevelUp(event.ability:GetLevel()-1)
    unit.owner = caster

    if caster:HasModifier("modifier_class_pugna2") then
        unit:SetOriginalModel("models/creeps/lane_creeps/creep_2021_dire/creep_2021_dire_ranged.vmdl")
    end

    local health = caster:GetMaxHealth() * 0.2
    unit:SetBaseMaxHealth(health)
    unit:SetMaxHealth(health)
    unit:SetHealth(health)

    CruelTaskmasterHeal(caster, event.ability, unit)
    OnSummonedUnit(unit, caster)
end

function ElementalFuryFX( event )
    local caster = event.caster
    if caster:GetModifierStackCount("modifier_elementalfury", nil) >= 10 then
        local particle = ParticleManager:CreateParticle("particles/econ/items/storm_spirit/strom_spirit_ti8/storm_spirit_ti8_overload_flash.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function EleBalance(event)
    local caster = event.caster
    local target = event.target
    local stackcount = caster:GetModifierStackCount("modifier_elementalfury", caster)
    if ConsumeComboPoints(caster, target) then
       caster:RemoveModifierByName("modifier_elementalfury")
    end

    --self stun
    local stuntime = 10 - stackcount
    if stuntime > 0 then
        --local damage_table = {}
        --damage_table.Duration = stuntime*0.75
        --event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_stunned", damage_table)

        local myevent = {}
        myevent.caster = caster
        myevent.target = caster
        myevent.buff = "modifier_stunned"
        myevent.ability = event.ability
        myevent.dur = stuntime*0.75
        ApplyBuff(myevent)

        local particle = ParticleManager:CreateParticle("particles/econ/items/zeus/lightning_weapon_fx/zuus_lightning_bolt_castfx_ground2.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        EmitSoundOn( "DOTA_Item.Mjollnir.Activate", caster)
    end

    if stackcount <= 0 then
        return
    end

    event.spelldamagefactor = stackcount*event.spelldamagefactor/10
    event.attributefactor = stackcount*event.attributefactor/10

    if caster:GetTeamNumber()==target:GetTeamNumber() then
        
        local vec1 = caster:GetAbsOrigin()+Vector(0,0,150)
        local vec2 = target:GetAbsOrigin()+Vector(0,0,150)
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_earth_spirit/espirit_magnet_arclightning.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControl(particle, 0, vec2)
        ParticleManager:SetParticleControl(particle, 1, vec1)
        ParticleManager:SetParticleControl(particle, 2, vec2)
        ParticleManager:ReleaseParticleIndex(particle)
        particle = ParticleManager:CreateParticle("particles/units/heroes/hero_undying/undying_fg_heal_impact_body.vpcf", PATTACH_POINT_FOLLOW, target)
        
        EmitSoundOn("DOTA_Item.HealingSalve.Activate", target)

        HealUnit(event)
        if event.ability:GetLevel() >= 4 and stackcount >= 10 then
            PurgeUnit({caster = caster, target = target, purgefx = "particles/units/heroes/hero_brewmaster/brewmaster_dispel_magic.vpcf"})
        end
    else
        event.spelldamagefactor = event.spelldamagefactor / 2
        event.attributefactor = event.attributefactor / 2

        local vec1 = caster:GetAbsOrigin()+Vector(0,0,150)
        local vec2 = target:GetAbsOrigin()+Vector(0,0,150)
        local particle = ParticleManager:CreateParticle("particles/econ/items/razor/razor_punctured_crest/razor_storm_lightning_strike_blade.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControl(particle, 0, vec2)
        ParticleManager:SetParticleControl(particle, 1, vec1)
        ParticleManager:SetParticleControl(particle, 2, vec2)
        ParticleManager:ReleaseParticleIndex(particle)
        EmitSoundOn( "DOTA_Item.Mjollnir.Activate", target)

        DamageUnit(event)
    end
    if stackcount >= 10 and event.lightningdur and event.lightningdur > 0 then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_lightning_shield", {Duration = event.lightningdur})
    end
end

function EleConv(event)
	local caster = event.attacker

	if caster:HasModifier("modifier_elementalfury") then
		local stackcount = caster:GetModifierStackCount("modifier_elementalfury", caster)+1
		if stackcount > 10 then
			stackcount = 10
		end
		caster:SetModifierStackCount("modifier_elementalfury", event.ability, stackcount)
	else
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_elementalfury", nil)
		caster:SetModifierStackCount("modifier_elementalfury", event.ability, 1)
	end
end

function Fanatism(event)
	local caster = event.attacker
	local target = event.target

	if caster:HasModifier("modifier_fanatism") then
		local stackcount = caster:GetModifierStackCount("modifier_fanatism", caster)+1
		caster:SetModifierStackCount("modifier_fanatism", event.ability, stackcount)
		if stackcount > 5 then
			local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5_gold/am_basher_c_gold.vpcf", PATTACH_POINT_FOLLOW, event.target)
			ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
			local vec = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
			ParticleManager:SetParticleControlForward(particle, 1, vec)
		end
	end
end

function ShadowDanceFXGladiator(event)
    local caster = event.attacker
    local target = event.target

    if caster.season4_2vs2 and caster.season4_2vs2 == 1 then
        local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5/am_basher_c.vpcf", PATTACH_POINT_FOLLOW, event.target)
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
        local vec = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
        ParticleManager:SetParticleControlForward(particle, 1, vec)
    end
end

function TraumFX(event)
	local caster = event.attacker
	local target = event.target
	if event.swap then
		caster = event.caster
		target = event.attacker
	end

	local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5/am_basher_c.vpcf", PATTACH_POINT_FOLLOW, target)
	ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
    ParticleManager:ReleaseParticleIndex(particle)
	local vec = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
	ParticleManager:SetParticleControlForward(particle, 1, vec)
end

function FanatismSetup(event)
	local caster = event.attacker
	caster:SetModifierStackCount("modifier_fanatism", event.ability, 1)
end

function Punishment( event )
	local caster = event.caster
	local target = event.target
	local vec = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
	if vec < 100.0 then
		vec = 100.0
	else
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nyx_assassin/nyx_assassin_mana_burn_bloom.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
	end
	if vec > 600.0 then
		vec = 600.0
	end
	vec = vec - 100
	local power = vec/500.0
	if power > 1.0 then
		power = 1.0
	end
	--mana
	caster:SetMana(caster:GetMana()+event.amount*power)
	--stun
	local damage_table = {}
	if power > 0.9 then
		power = 0.9
	end
	--agha
	if caster:HasModifier("modifier_item_straxe2") then
		power = -0.1
	end
	damage_table.Duration = event.dur*(1-power)
	event.dur = event.dur*(1-power)
	StunTarget(event)
    if event.ability:GetLevel() >= 4 then
        Multistrike( {caster = caster, target = target, hits = 5} )
    end
end

function Infested(event)
	local caster = event.caster
	local target = event.target

	local table = {}
	table.Duration = event.dur

	if target:HasModifier("modifier_infested") then
		local stackcount = target:GetModifierStackCount("modifier_infested", caster)+1
		target:RemoveModifierByName("modifier_infested")
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_infested", table)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_infested"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		target:SetModifierStackCount("modifier_infested", event.ability, stackcount)
	else
		event.ability:ApplyDataDrivenModifier(caster, target, "modifier_infested", table)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_infested"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		target:SetModifierStackCount("modifier_infested", event.ability, 1)
	end
end

function Rot(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local pos = event.target_points[1]
	local range = 300

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	local table = {}
	table.Duration = event.dur

	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower")) then
					local myevent = {}
					myevent.caster = caster
					myevent.target = enemy
					myevent.buff = "modifier_rotdk"
					myevent.ability = ability
					myevent.dur = event.dur
                    myevent.settickrate = event.settickrate
					ApplyBuff(myevent)
					--if enemy:GetUnitLabel() == "hero" then
					--	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_blood_weapon", nil)
					--else
					--	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_blood_weapon_1", nil)
					--end
				end
			end
		end
	end
end

function WarlockHeal(event)
	local caster = event.caster
	local target = event.target

	if target:HasModifier("modifier_dot1") or target:HasModifier("modifier_dot2") or event.always ~= nil then
		if event.green ~= nil then
			local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_undying/undying_soul_rip_heal_impact_body.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
		else
			local particle = ParticleManager:CreateParticle("particles/econ/events/ti5/blink_dagger_start_smoke_ti5.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
		end
		event.heal = event.heal*caster:GetMaxHealth()/100.0
		event.target = caster
		HealUnit(event)
	end
end

function ArcanePower(event)
	local caster = event.caster
    local add = 1
    if event.addstackcount then
        add = event.addstackcount
    end
	if caster:HasModifier("modifier_arcanepower") then
		local stackcount = caster:GetModifierStackCount("modifier_arcanepower", caster)+add
        if stackcount > 20 then
            stackcount = 20
        end
		caster:SetModifierStackCount("modifier_arcanepower", event.ability, stackcount)
	else
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_arcanepower", nil)
        caster:SetModifierStackCount("modifier_arcanepower", event.ability, add)
	end
end

function ArcaneBarrier(event)
	local caster = event.caster

	if caster:HasModifier("modifier_arcanebarrierbuff") then
		local stackcount = caster:GetModifierStackCount("modifier_arcanebarrierbuff", caster)+1
		caster:RemoveModifierByName("modifier_arcanebarrierbuff")
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_arcanebarrierbuff", nil)
		caster:SetModifierStackCount("modifier_arcanebarrierbuff", event.ability, stackcount)
	else
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_arcanebarrierbuff", nil)
		caster:SetModifierStackCount("modifier_arcanebarrierbuff", event.ability, 1)
	end
end

function ArcaneBarrageFX(event)
    local caster = event.caster
    local target = event.target
    --if caster.season4_3vs3 and caster.season4_3vs3 == 1 then
    --    event.ability:ApplyDataDrivenModifier(caster, target, "modifier_am_gladiator", {Duration = event.dur})
    --else
    event.ability:ApplyDataDrivenModifier(caster, target, "modifier_am", {Duration = event.dur})
    --end
end

function NetherExplosionStacks( event )
    local caster = event.caster
    local stackcount = caster:GetModifierStackCount("modifier_burning_nether", nil)
    local ability = caster:FindAbilityByName("Arcane3")
    if stackcount > 0 and ability and caster:HasModifier("modifier_npc_dota_hero_invoker") then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_burning_nether", {Duration = 20})
        stackcount = stackcount + 2
        if stackcount > 20 then
            stackcount = 20
        end
        caster:SetModifierStackCount("modifier_burning_nether", ability, stackcount)
    end
end

function Meteor(event)
    local caster = event.caster
    local target = event.target
    --get arcane power stacks
    local stackcount = caster:GetModifierStackCount("modifier_arcanepower", caster)
    if stackcount >= 10 and not caster:HasModifier("modifier_burning_nether") then
        --caster:RemoveModifierByName("modifier_arcanepower")
        caster:SetModifierStackCount("modifier_arcanepower", event.ability, stackcount - 10)
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_burning_nether", {Duration = 20})
        caster:SetModifierStackCount("modifier_burning_nether", event.ability, 5)
    end
    stackcount = caster:GetModifierStackCount("modifier_burning_nether", caster)
    if stackcount > 0 then
        if ConsumeComboPoints(caster, target) then
            stackcount = stackcount - 1
        end
        if stackcount >= 1 then
            caster:SetModifierStackCount("modifier_burning_nether", event.ability, stackcount)
        else
            caster:RemoveModifierByName("modifier_burning_nether")
        end
        if event.arcane and event.arcane == 1 then
            event.ability:ApplyDataDrivenModifier(caster, target, "modifier_meteor_proc_arcane", nil)
        else
            event.ability:ApplyDataDrivenModifier(caster, target, "modifier_meteor_proc", nil)
        end
    else
        caster:SetMana(caster:GetMana() + 45)
    end
end

function MeteorEnd(event)
	local caster = event.caster
    ApplyBuff(event)
    --if caster:HasModifier("modifier_burning_nether") then
    --    ApplyBuff(event)
    --end
	if caster.Meteor ~= nil then
		ParticleManager:DestroyParticle(caster.Meteor,false)
	end
end

function LakeArmorSetup(event)
	local caster = event.caster
	caster.Lake = event.target_points[1]
end

function LakeArmor(event)
	local caster = event.caster
	local vec = (caster.Lake-caster:GetAbsOrigin()):Length()
	if vec > 500.0 then
		caster:RemoveModifierByName("lakearmor")
	end
end

function StormStunCD(event)
	local caster = event.caster
	local abil = caster:FindAbilityByName("Retri4")
	if abil and abil:GetLevel() >= 4 then
 		local cd = abil:GetCooldownTimeRemaining()
    	if cd > 0.1 then
    		abil:EndCooldown()
    		abil:StartCooldown(cd-1)
    	end
	end
end

function PalaUltiCD(event)
	local caster = event.caster
	local abil = event.ability
	if abil:GetLevel() >= 4 then
		abil = caster:FindAbilityByName("Retri6")
        if abil then
     		local ab = abil:GetCooldownTimeRemaining()
        	if ab > 0.1 then
        		abil:EndCooldown()
        		abil:StartCooldown(ab-0.25)
        	end
        end
	end
end

function DPSMeter(event)
	local target = event.unit
	local damage = event.dmg
	
	if target.dmgtaken == nil then
		target.dmgtaken = damage
		target.dpsmetertime = 1
	else
		target.dmgtaken = target.dmgtaken + damage
	end
end

function DPSMeterTimer(event)
	local target = event.caster
	
	if target.dmgtaken ~= nil then
		target.dpsmetertime = target.dpsmetertime + 1
		CriticalStrikeFX(nil, target, target.dmgtaken/target.dpsmetertime, 0, 0)
	end
end

function Eviscerate(event)
    local caster = event.caster
    local target = event.target
    local cp = caster.ComboPoints

    if cp > 0 then
        if cp >= 3 then
            if event.cdreducechance and math.random(1,100) <= event.cdreducechance then
                ReduceCooldown({caster = caster, chooseability = 4, amount = 2, ability = event.ability})
            end
        end
        if event.ability:GetLevel() >= 2 then
            --AddAttackSpeed(caster, 50 * cp, 5)
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_hawkas", {Duration = 5})
            caster:SetModifierStackCount("modifier_hawkas", event.ability, cp)
        end
        if ConsumeComboPoints(caster, target) then
            caster.ComboPoints = 0
            caster:RemoveModifierByName("modifier_combopoint")
        end
        event.attributefactor = event.attributefactor*cp
        DamageUnit(event)
        local buff = "particles/units/heroes/hero_nyx_assassin/nyx_assassin_vendetta.vpcf"
        if caster.season4_2vs2 and caster.season4_2vs2 == 1 then
            buff = "particles/econ/items/riki/riki_immortal_ti6/riki_immortal_ti6_blinkstrike_stab.vpcf"
        end
        if true then
            local particle = ParticleManager:CreateParticle(buff, PATTACH_POINT_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn("Hero_Riki.Backstab", target)
        end
        Timers:CreateTimer(0.25, function()
            DamageUnit(event)
            local particle = ParticleManager:CreateParticle(buff, PATTACH_POINT_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn("Hero_Riki.Backstab", target)
        end)
        Timers:CreateTimer(0.5, function()
            DamageUnit(event)
            local particle = ParticleManager:CreateParticle(buff, PATTACH_POINT_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn("Hero_Riki.Backstab", target)
        end)

        

        local tab = {}
        tab.Duration = 1.0*cp
        --event.ability:ApplyDataDrivenModifier(caster, target, "modifier_slow50", tab)

        local myevent = {}
        myevent.caster = caster
        myevent.target = target
        myevent.buff = "modifier_slow50"
        myevent.ability = event.ability
        myevent.dur = event.dur*cp
        ApplyBuff(myevent)
    end
end

function CheaterStun(event)
    local caster = event.caster
    if caster.cheater then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", {Duration = 10})
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_cheater", {Duration = 10})
        for i=0,5 do
            local item = caster:GetItemInSlot(i)
            caster:RemoveItem(item)
        end
        local base = caster.ArenaControl
        if base then
            caster:SetAbsOrigin(base:GetAbsOrigin())
        end
    end
end

function SinisterStrike(event)
    local caster = event.caster
    local target = event.target
    local buff = "particles/units/heroes/hero_nyx_assassin/nyx_assassin_vendetta.vpcf"
    if caster.season4_2vs2 and caster.season4_2vs2 == 1 then
        buff = "particles/econ/items/riki/riki_immortal_ti6/riki_immortal_ti6_blinkstrike_r_stab.vpcf"
    end
    local particle = ParticleManager:CreateParticle(buff, PATTACH_POINT_FOLLOW, target)
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
    ParticleManager:ReleaseParticleIndex(particle)
end

function Shadowstep(event)
	local caster = event.caster
	local target = event.target
	--local power = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()/600
	--local stack = event.maxstack
	--caster.ShadowstepAttacks = 3
	--if power > 1.0 then
	--	power = 1.0
	--end
	--stack = stack*power
	--event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_shadowstep1", nil)
	--caster:SetModifierStackCount("modifier_shadowstep", event.ability, stack)

	local offset = RandomVector(1):Normalized()*80
	offset = Vector(offset[1], offset[2],0)
	caster:SetAbsOrigin(target:GetAbsOrigin()+offset)
	local table = {}
	table.Duration = 0.05
	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", table)
end

function ShadowstepAttack(event)
	local caster = event.attacker
	if caster.ShadowstepAttacks > 1 then
		caster.ShadowstepAttacks = caster.ShadowstepAttacks - 1
	else
		Timers:CreateTimer(0.1, function()
		    caster:RemoveModifierByName("modifier_shadowstep")
		end)
	end
end

function Blind(event)
	local caster = event.caster
	local target = event.target
    local ability = event.ability
	local duration = event.dur
	local angleDiff = target:GetAngles()[2]-caster:GetAngles()[2]
	if angleDiff < 0.0 then
		angleDiff = -angleDiff
	end

	if not (angleDiff <= 90.0 or angleDiff >= 270.0) then
		duration = duration * 2
        DamageUnit(event)
	end
	local table = {}
	table.Duration = duration
	--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_sap2", table)

	local myevent = {}
	myevent.caster = caster
	myevent.target = target
	myevent.buff = "modifier_sap2"
	myevent.ability = ability
	myevent.dur = duration
	ApplyBuff(myevent)
end

function Preparation(event)
	local caster = event.caster
	caster:GetAbilityByIndex(3):EndCooldown()
	caster:GetAbilityByIndex(5):EndCooldown()
end

--function RogueAgiBonus(event)
--	local caster = event.caster
--	if event.percent > 0 then
--		caster:RemoveModifierByName("modifier_rogue_agi_bonus")
--		local agi = caster:GetAgility()*event.percent/100
		--print("stat bonus " .. agi)
--		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_rogue_agi_bonus", nil)
--		caster:SetModifierStackCount("modifier_rogue_agi_bonus", event.ability, agi)
--	end
--end

function RoguePrimaryBonus(event)
	local caster = event.caster
	if event.percent > 0 then
		caster:RemoveModifierByName("modifier_rogue_primary_bonus")
		local agi = GetPrimaryStatValueCustom(caster)*event.percent/100
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_rogue_primary_bonus", nil)
		caster:SetModifierStackCount("modifier_rogue_primary_bonus", event.ability, agi)
	end
end

function AghaStun( event )
	local caster = event.attacker
	local target = event.target
	--agha
	if caster:HasModifier("modifier_item_straxe2") then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_furycharge_aa_buff", nil)
	end
end

function AxeThrow( event )
	local caster = event.caster
	local target = event.target

	local vec = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
    local farAway = vec > 300
	if farAway then
		event.attributefactor = event.attributefactormax
	end
    event.includeauto = event.attributefactor
    event.attributefactor = 0.0

	DamageUnit(event)
	if caster.AxeThrow ~= nil then
		ParticleManager:DestroyParticle(caster.AxeThrow,false)
	end

    if farAway then
        local myevent = { caster = caster, target = target, dur = 2, buff = "modifier_stunned", ability = event.ability}
        ApplyBuff(myevent)
    end
end

function AxeThrowAxe(event)
	local caster = event.caster
	local target = event.target

	local vec = target:GetAbsOrigin()+Vector(0,0,95)
	local vec2 = caster:GetAbsOrigin()+Vector(0,0,95)

	local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_troll_warlord/troll_warlord_whirling_axe_melee.vpcf", PATTACH_POINT_FOLLOW, caster)
	ParticleManager:SetParticleControl(particle, 0, vec2)
	ParticleManager:SetParticleControl(particle, 1, vec)
	ParticleManager:SetParticleControl(particle, 4, Vector(0.4,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
	caster.AxeThrow = particle
end

function FuryAxeFX(event)
	local caster = event.caster
	local target = event.target
	if event.duration == 0 then
		return
	end

	local vec = target:GetAbsOrigin()+Vector(0,0,95)
	local vec2 = caster:GetAbsOrigin()+Vector(0,0,95)

	local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_troll_warlord/troll_warlord_whirling_axe_melee.vpcf", PATTACH_POINT_FOLLOW, caster)
	ParticleManager:SetParticleControl(particle, 0, vec2)
	ParticleManager:SetParticleControl(particle, 1, vec)
	ParticleManager:SetParticleControl(particle, 4, Vector(event.duration,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
end

function FurySlow(event)
	local caster = event.caster
	local target = event.target

	local power = 10*target:GetHealth()/target:GetMaxHealth()
	--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_furyslow", nil)

	local myevent = {}
	myevent.caster = caster
	myevent.target = target
	myevent.buff = "modifier_furyslow"
	myevent.ability = event.ability
	myevent.dur = event.dur
	ApplyBuff(myevent)

	target:SetModifierStackCount("modifier_furyslow", event.ability, power)
end

function FuryAS(event)
	local caster = event.caster

	if caster:HasModifier("modifier_furyas") then
		local stackcount = caster:GetModifierStackCount("modifier_furyas", caster)+1
		if stackcount > event.max then
			stackcount = event.max
		end
		caster:RemoveModifierByName("modifier_furyas")
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_furyas", nil)
		caster:SetModifierStackCount("modifier_furyas", event.ability, stackcount)
	else
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_furyas", nil)
		caster:SetModifierStackCount("modifier_furyas", event.ability, 1)
	end
end

function BloodArcana(event)
	local caster = event.caster
	local target = event.target
    if caster and target then
        if not event.ignore_crit_effect_cooldown then
            if not COverthrowGameMode.crit_effect_cooldown then
                COverthrowGameMode.crit_effect_cooldown = true
                Timers:CreateTimer(5,function()
                    COverthrowGameMode.crit_effect_cooldown = nil
                end)
            else
                return
            end
        end
    else
        return
    end
	local vec = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Normalized()
	local vec2 = target:GetAbsOrigin()
	local particle
	if event.mech ~= nil then
		particle = ParticleManager:CreateParticle("particles/econ/items/phantom_assassin/phantom_assassin_arcana_elder_smith/phantom_assassin_crit_impact_dagger_mechanical_arcana.vpcf", PATTACH_POINT_FOLLOW, target)
	else
		particle = ParticleManager:CreateParticle("particles/econ/items/phantom_assassin/phantom_assassin_arcana_elder_smith/phantom_assassin_crit_impact_dagger_arcana.vpcf", PATTACH_POINT_FOLLOW, target)
	end
	ParticleManager:SetParticleControl(particle, 0, vec2)
	ParticleManager:SetParticleControl(particle, 1, vec2)
	ParticleManager:SetParticleControlForward(particle, 1, vec)
	ParticleManager:SetParticleControl(particle, 6, vec2)
	ParticleManager:SetParticleControl(particle, 10, vec2)
    ParticleManager:ReleaseParticleIndex(particle)
end

function CosmeticEffectsFromItems( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local qualities = COverthrowGameMode:GetAllArtifactItemQuality(caster)
    if event.pa and qualities and qualities[1] and qualities[1] >= 5 then
        event.ignore_crit_effect_cooldown = true
        BloodArcana(event)
    end
    if (event.pa2 and qualities and qualities[2] and qualities[2] >= 6) or false then
        local particle = ParticleManager:CreateParticle("particles/econ/items/bristleback/ti7_head_nasal_goo/bristleback_ti7_nasal_goo_debuff.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        Timers:CreateTimer(1,function()
            if not target or target:IsNull() or not target:HasModifier("modifier_pa_poison") then
                ParticleManager:DestroyParticle(particle,true)
                ParticleManager:ReleaseParticleIndex(particle)
            else
                return 1
            end
        end)
    end
    if (event.moon and qualities and qualities[1] and qualities[1] >= 6) or false then
        local particle = ParticleManager:CreateParticle("particles/econ/items/mirana/mirana_starstorm_bow/mirana_starstorm_starfall_attack.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if event.moon and ((qualities and qualities[1] and qualities[1] >= 7) or false) then
        local particle = ParticleManager:CreateParticle("particles/invoker_chaos_meteor_fly_blue.vpcf", PATTACH_WORLDORIGIN, target)
        ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + Vector(0,0,900))
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,50))
        ParticleManager:SetParticleControl(particle, 2, Vector(0.5,0,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if event.moon4 and ((qualities and qualities[2] and qualities[1] >= 7) or false) then
        local count = 2
        if event.duration and event.duration >= 3.6 then
            count = 3
        end
        local pos = event.target_points[1]
        for i=1,count do
            local time = i*1.8-0.25
            if time < 0 then
                time = 0
            end
            Timers:CreateTimer(time, function()
                local particle = ParticleManager:CreateParticle("particles/invoker_chaos_meteor_fly_fast.vpcf", PATTACH_WORLDORIGIN, caster)
                ParticleManager:SetParticleControl(particle, 0, pos + Vector(0,0,1000))
                ParticleManager:SetParticleControl(particle, 1, pos + Vector(0,0,50))
                ParticleManager:SetParticleControl(particle, 2, Vector(0.25,0,0))
                ParticleManager:ReleaseParticleIndex(particle)
                EmitSoundOn("Hero_Luna.Eclipse.Cast", target)
            end)
        end
    end
    if (event.holy5 and qualities and qualities[2] and qualities[2] >= 6) or false then
        ability:ApplyDataDrivenModifier(caster, target, event.buff, {Duration = event.dur})
        local particle = ParticleManager:CreateParticle("particles/econ/events/ti7/hero_levelup_ti7_godray.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if (event.stealthfx and qualities and qualities[3] and qualities[3] >= 6) or false then
        local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_pyro.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_ashes.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if (event.armosdot2 and qualities and qualities[1] and qualities[1] >= 6) or false then
        ability:ApplyDataDrivenModifier(caster, target, event.buff, {Duration = event.dur})
    end
    if (event.arcane5 and qualities and qualities[3] and qualities[3] >= 7) or false then
        local particle = ParticleManager:CreateParticle("particles/econ/items/elder_titan/elder_titan_ti7/elder_titan_echo_stomp_ti7_magical.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if (event.wind5 and qualities and qualities[3] and qualities[3] >= 7) or false then
        local pos = event.target_points[1]
        local particle = ParticleManager:CreateParticle("particles/econ/items/legion/legion_overwhelming_odds_ti7/legion_commander_odds_ti7.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, pos+Vector(250,250,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if (event.arms5 and qualities and qualities[1] and qualities[1] >= 7) or false then
        local particle = ParticleManager:CreateParticle("particles/econ/items/legion/legion_overwhelming_odds_ti7/legion_commander_odds_ti7_proj_impact.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function BullRushFX( event )
    local caster = event.caster
    local pos = caster:GetAbsOrigin() + caster:GetForwardVector() * 250
    local particle = ParticleManager:CreateParticle("particles/econ/items/beastmaster/bm_shoulder_ti7/bm_shoulder_ti7_roar.vpcf", PATTACH_POINT_FOLLOW, caster)
    ParticleManager:SetParticleControl(particle, 1, pos)
    ParticleManager:ReleaseParticleIndex(particle)
end

function HookFX(event)
	local caster = event.caster
	local target = event.target

	local vec = Vector(1000,1000,0)
	--local vec2 = target:GetAbsOrigin()

	local particle = ParticleManager:CreateParticle("particles/econ/items/pudge/pudge_dragonclaw/pudge_meathook_dragonclaw.vpcf", PATTACH_POINT_FOLLOW, caster)

	ParticleManager:SetParticleControlEnt(particle, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
	ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	ParticleManager:SetParticleControl(particle, 1, vec)
	ParticleManager:SetParticleControl(particle, 2, Vector(3500,0,0))
	ParticleManager:SetParticleControl(particle, 3, Vector(0.3,0,0))
	ParticleManager:SetParticleControl(particle, 4, Vector(0.3,0,0))
	ParticleManager:SetParticleControl(particle, 5, Vector(0.3,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
	--ParticleManager:SetParticleControlForward(particle, 1, vec)
	--ParticleManager:SetParticleControl(particle, 6, vec2)
	--ParticleManager:SetParticleControl(particle, 10, vec2)
end

function EarthShield( event )
	local target = event.target
	local caster = event.caster
	if caster.earthtarget ~= nil and not caster.earthtarget:IsNull() then
		caster.earthtarget:RemoveModifierByName("modifier_earth_shield")
	end
	caster.earthtarget = target
	target.earthshieldsource = caster
	caster.earthshieldCD = 0
end

function PrayerShield( event )
	local target = event.target
	local caster = event.caster
	if caster.earthtarget ~= nil and not caster.earthtarget:IsNull() then
		caster.earthtarget:RemoveModifierByName("modifier_prayer_shield")
	end
	caster.earthtarget = target
	target.prayershieldsource = caster
	local tab = {}
	tab.Duration = event.dur
	--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_prayer_shield", tab)
	event.buff = "modifier_prayer_shield"
	ApplyBuff(event)
	target:SetModifierStackCount("modifier_prayer_shield", event.ability, event.stack)
end

function InnerFlame( event )
	local target = event.target
	local caster = event.caster
	local tab = {}
	tab.Duration = event.dur
	local buff = "modifier_inner_str"
	if target:GetPrimaryAttribute() == 1 then
		buff = "modifier_inner_agi"
	elseif target:GetPrimaryAttribute() == 2 then
		buff = "modifier_inner_int"
	end
	event.ability:ApplyDataDrivenModifier(caster, target, buff, tab)
	event.buff = buff
	ApplyBuff(event)
end

function EternalLife( event )
	local target = event.target
	local caster = event.caster
	local tab = {}
	tab.Duration = event.dur
	local buff = "modifier_inner_str"
	if target:GetPrimaryAttribute() == 1 then
		buff = "modifier_inner_agi"
	elseif target:GetPrimaryAttribute() == 2 then
		buff = "modifier_inner_int"
	end
	event.ability:ApplyDataDrivenModifier(caster, target, buff, tab)
	event.buff = buff
	ApplyBuff(event)
end

function EarthShieldHeal( event )
	local target = event.unit
	local caster = target.earthshieldsource
	if caster.earthshieldCD <= 0 then
		caster.earthshieldCD = 3
		event.target = target
		event.caster = caster
        local originalHealValue = event.heal
		HealUnit(event)
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_dazzle/dazzle_shadow_wave_b.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin()+Vector(0,0,0))
		ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin()+Vector(0,0,125))
        ParticleManager:ReleaseParticleIndex(particle)
        if caster:HasModifier("modifier_class_sham2") and target ~= caster then
            event.heal = originalHealValue
            event.target = caster
            HealUnit(event)
            particle = ParticleManager:CreateParticle("particles/units/heroes/hero_dazzle/dazzle_shadow_wave_b.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin()+Vector(0,0,125))
            ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin()+Vector(0,0,125))
            ParticleManager:ReleaseParticleIndex(particle)
            local myevent = {caster = caster, amount = 1, ability = event.ability, chooseability = 2 }
            ReduceCooldown(myevent)
        end
		Timers:CreateTimer(event.cd, function()
		    caster.earthshieldCD = 0
		end)
	end
end

function PrayerShieldHeal( event )
	local target = event.unit
	local caster = target.prayershieldsource
	event.target = target
	event.caster = caster
    local stack = target:GetModifierStackCount("modifier_prayer_shield", nil)
    event.spelldamagefactor = event.spelldamagefactor * (1+0.1*stack)
    event.attributefactor = event.attributefactor * (1+0.1*stack)
	HealUnit(event)
	
	if caster and stack > 1 then
		--find target
		event.range = 900
		event.target = target
		event.caster = caster
        event.onlyhero = true
		local newtarget = MostWoundedTarget(event)
		if newtarget == nil then
			target:RemoveModifierByName("modifier_prayer_shield")
			return
		end
		caster.earthtarget = newtarget
		--apply buff
		newtarget.prayershieldsource = caster
		--local tab = {}
		--tab.Duration = 12
		--event.ability:ApplyDataDrivenModifier(caster, newtarget, "modifier_prayer_shield", tab)

		event.buff = "modifier_prayer_shield"
		event.caster = caster
		event.target = newtarget
		event.dur = 12
		ApplyBuff(event)
		newtarget:SetModifierStackCount("modifier_prayer_shield", event.ability, stack-1)

		local particle = ParticleManager:CreateParticle("particles/dazzle_holy_wave_b.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin()+Vector(0,0,75))
		ParticleManager:SetParticleControl(particle, 1, newtarget:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:ReleaseParticleIndex(particle)
	end
	target:RemoveModifierByName("modifier_prayer_shield")
end

function HolyLightMissile( event )
    local caster = event.caster
    local target = event.target
    local particle = ParticleManager:CreateParticle("particles/dazzle_holy_wave_b.vpcf", PATTACH_POINT_FOLLOW, caster)
    ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,75))
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin()+Vector(0,0,75))
    ParticleManager:ReleaseParticleIndex(particle)
end

function resto3(event)
	local caster = event.caster
	local ability = event.ability
	local range = 425
	if caster.meditation ~= nil then
		caster.meditation = caster.meditation + 0.05
	else
		caster.meditation = 1.0
	end

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower")) then
					local table = {}
					table.caster = caster
					table.target = enemy
					table.ability = ability
					table.attributefactor = event.attributefactor * caster.meditation
					table.spelldamagefactor = event.spelldamagefactor * caster.meditation
					table.heal = 0
                    table.isaoeheal = event.isaoeheal
					HealUnit(table)
					local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_dazzle/dazzle_shadow_wave_b.vpcf", PATTACH_POINT_FOLLOW, caster)
					ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,75))
					ParticleManager:SetParticleControl(particle, 1, enemy:GetAbsOrigin()+Vector(0,0,75))
                    ParticleManager:ReleaseParticleIndex(particle)
				end
			end
		end
	end
	if caster.meditation >= 1.29 then
		caster.meditation = nil
	end
end

function Massdispel(event)
	local caster = event.caster
	local ability = event.ability
	local range = 300
	local targetpos = event.target_points[1]

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), targetpos, caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) then
					event.target = enemy
					event.massdispel = 1
					PurgeUnit(event)
					local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_tidehunter/tidehunter_krakenshell_purge_d.vpcf", PATTACH_POINT_FOLLOW, enemy)
                    ParticleManager:ReleaseParticleIndex(particle)
				end
			end
		end
	end
	enemies = FindUnitsInRadius( caster:GetTeamNumber(), targetpos, caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, DOTA_UNIT_TARGET_FLAG_INVULNERABLE, 0, false )
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			--print(enemy:GetName())
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) then
					event.target = enemy
					event.massdispel = 1
					--PurgeEnemyUnit(event) --removed 6.0.6
					local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_tidehunter/tidehunter_krakenshell_purge_d.vpcf", PATTACH_POINT_FOLLOW, enemy)
                    ParticleManager:ReleaseParticleIndex(particle)
					if event.dur and event.dur > 0 then
						--print("mass root ")
						local myevent = {}
						myevent.caster = caster
						myevent.target = enemy
						myevent.buff = event.buff
						myevent.ability = ability
						myevent.dur = event.dur
						ApplyBuff(myevent)
					end
				end
			end
		end
	end
end

function MostWoundedTarget (event)
	local caster = event.caster
	local target = caster --event.target
	local ability = event.ability
	local range = event.range

    local pets = "pet"
    if event.onlyhero then
        pets = "hero"
    end

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), target:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
	local hp = 1.2
	local friend = nil
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()==pets) or (enemy:GetUnitLabel()=="tower")) then --and enemy ~= target then
					local hp2 = enemy:GetHealth()/enemy:GetMaxHealth()
					if hp2 < hp then
 						friend = enemy
 						hp = hp2
					end
				end
			end
		end
	end
	return friend
end

function HealingWaveJump(event, target, from_target, target_list)
    --charges left?
    local caster = event.caster
    local range = event.jumpdistance
    if not event.chainhealtargets or event.chainhealtargets <= 0 or not target then
        return
    end
    event.chainhealtargets = event.chainhealtargets - 1
    --heal
    HealUnit(event)
    local particle = ParticleManager:CreateParticle("particles/dazzle_shadow_wave_green.vpcf", PATTACH_POINT_FOLLOW, from_target)
    ParticleManager:SetParticleControlEnt(particle, 0, from_target, PATTACH_POINT_FOLLOW, "attach_hitloc", from_target:GetAbsOrigin(), true)
    ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
    ParticleManager:ReleaseParticleIndex(particle)
    table.insert(target_list, target)
    --find next target
    local friends = FindUnitsInRadius( caster:GetTeamNumber(), target:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
    local hp = 1.2
    local friend = nil
    if #friends > 0 then
        for _,enemy in pairs(friends) do
            if enemy ~= nil then
                for i=1, #target_list do
                    if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) and (enemy ~= target_list[i] or (event.can_hit_same_target_again and event.can_hit_same_target_again == 1) ) then
                        local hp2 = enemy:GetHealth()/enemy:GetMaxHealth()
                        if hp2 < hp then
                            friend = enemy
                            hp = hp2
                        end
                    end
                end
            end
        end
    end
    --reduce healing for next jump and heal
    Timers:CreateTimer(0.4, function()
        event.attributefactor = event.attributefactor*event.healreduction/100
        event.spelldamagefactor = event.spelldamagefactor*event.healreduction/100
        event.heal = 0
        event.target = friend
        HealingWaveJump(event, friend, target, target_list)
    end)
end

function HealingWave(event)
	local caster = event.caster
	local target = event.target
    local target_list = {}
    if caster:HasModifier("modifier_npc_dota_hero_witch_doctor") then
        event.can_hit_same_target_again = 1
        event.chainhealtargets = event.chainhealtargets + 1
    end
    HealingWaveJump(event, target, caster, target_list)
end

function Resto3Sound( event )
	local caster = event.caster
	EmitSoundOn("Hero_WitchDoctor.Voodoo_Restoration.Loop", caster)
end

function Resto3SoundEnd( event )
	local caster = event.caster
	StopSoundEvent("Hero_WitchDoctor.Voodoo_Restoration.Loop", caster)
end

function DragonFX(event)
	local caster = event.caster
	local target = event.target_points[1]

	local vec = (target-caster:GetAbsOrigin()):Normalized()
	local vec2 = target
	local particle = ParticleManager:CreateParticle("particles/econ/items/dragon_knight/dk_immortal_dragon/dragon_knight_dragon_tail_iron_dragon.vpcf", PATTACH_ABSORIGIN, caster)
	ParticleManager:SetParticleControl(particle, 0, vec2)
	ParticleManager:SetParticleControl(particle, 2, vec2)
	ParticleManager:SetParticleControlForward(particle, 0, vec)
	ParticleManager:SetParticleControl(particle, 4, vec2)
	ParticleManager:SetParticleControl(particle, 5, vec2)
    ParticleManager:ReleaseParticleIndex(particle)

	particle = ParticleManager:CreateParticle("particles/econ/items/lina/lina_head_headflame/lina_spell_dragon_slave_headflame_d.vpcf", PATTACH_ABSORIGIN, caster)
	ParticleManager:SetParticleControl(particle, 0, vec2)
	ParticleManager:SetParticleControl(particle, 3, vec2)
	ParticleManager:SetParticleControlForward(particle, 0, vec)
    ParticleManager:ReleaseParticleIndex(particle)
end

function ItemCourage( event )
	local caster = event.caster
	event.target = caster
	PayWithLife(event)
	Timers:CreateTimer(3.0, function()
	    HealPercentage(event)
	    EmitSoundOn( "DOTA_Item.UrnOfShadows.Activate", caster)
        if event.invis then
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_invisible", {Duration = 5})
        end
	end)
end

function StopChannelMaxRange( event )
	local caster = event.caster
	local target = event.target
	local distance = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length() - GetCastRangeBonus(caster)
	local max = 850
	--if caster:HasModifier("modifier_item_aether_lens") then
	--	distance = distance - 120
	--end
	if event.spellrange then
		max = event.spellrange + 250
	end
	if event.dontbreak and event.dontbreak == 1 then
		max = 99999
	end
	if distance > max or target:HasModifier("modifier_invisible") then
		caster:Stop()
	end
end

function Mindflay( event )
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	if event.ability ~= nil then
		local vec1 = caster:GetAbsOrigin()+Vector(0,0,75)
		local vec2 = caster:GetAbsOrigin()+Vector(0,0,75)
		--local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_puck/puck_dreamcoil_tether.vpcf", PATTACH_ROOTBONE_FOLLOW, target)
		--ParticleManager:SetParticleControl(particle, 0, vec1)
		--ParticleManager:SetParticleControl(particle, 1, vec2)
		--if target:HasModifier("modifier_swd") then
		--ability:ApplyDataDrivenModifier(caster, target, "modifier_slow50", nil)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_slow50"
		myevent.ability = ability
		myevent.dur = event.dur
		ApplyBuff(myevent)
		--end
		local distance = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length() - GetCastRangeBonus(caster)
		if distance > 1000 or target:HasModifier("modifier_invisible") then
			caster:Stop()
		end
	else
		caster:Stop()
		target:RemoveModifierByName("modifier_sh")
	end
end

function DevouringPlague( event )
	local caster = event.caster
	local target = event.target
	local ability = event.ability
    if ability:GetLevel() >= 3 then
        target.devouringsource = caster
    else
        target.devouringsource = nil
    end
	if caster:HasModifier("modifier_shadoworb") then
		event.addstacks = caster:GetModifierStackCount("modifier_shadoworb", nil) + 1
        if event.addstacks > 3 then
            ability:ApplyDataDrivenModifier(caster, caster, "modifier_critsha", {Duration = 2.5})
        end
	end
	caster:RemoveModifierByName("modifier_shadoworb")
	ApplyBuffStack(event)
end

function ShadowFear( event )
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	if caster:HasModifier("modifier_shadoworb") then
		event.dur = event.dur * (caster:GetModifierStackCount("modifier_shadoworb", nil) + 1)
	end
    if event.spselfbuff then
        event.target = caster
    end
	ApplyBuff(event)
end

function HolyForm(event)

	local hero = event.caster
	local abil1 = hero:GetAbilityByIndex(0)
	local abil2 = hero:GetAbilityByIndex(1)
	local abil3 = hero:GetAbilityByIndex(2)

	if abil1:GetAbilityName() == "shadow11" then
		--print("to holy")
		hero:RemoveModifierByName("modifier_shadowstance")
		hero:RemoveModifierByName("modifier_selffxshadow")
		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_holystance", nil)
		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_selffx", nil)
		hero.abil1=abil1:GetLevel()
		hero.abil2=abil2:GetLevel()
		hero.abil3=abil3:GetLevel()

  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:RemoveAbility(abil3:GetAbilityName())

  		hero:AddAbility("spholy1")
  		hero:FindAbilityByName("spholy1"):SetLevel(hero:FindAbilityByName("shadow6"):GetLevel())
  		hero:AddAbility("spholy2")
  		hero:FindAbilityByName("spholy2"):SetLevel(hero:FindAbilityByName("shadow6"):GetLevel())
  		hero:AddAbility("spholy3")
  		hero:FindAbilityByName("spholy3"):SetLevel(hero:FindAbilityByName("shadow6"):GetLevel())
  		hero:SetRenderColor(255, 255, 255)
  		
  		EmitSoundOn("dark_seer_dkseer_respawn_04", hero)		
	
  		
  		Timers:CreateTimer(0.1, function()
		    event.ability:EndCooldown()
  			event.ability:StartCooldown(1.0)
		end)
  	else
  		--print("to offensive")
  		hero:RemoveModifierByName("modifier_holystance")
  		hero:RemoveModifierByName("modifier_selffx")
  		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_shadowstance", nil)
  		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_selffxshadow", nil)
  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:AddAbility("shadow11")
  		hero:FindAbilityByName("shadow11"):SetLevel(hero.abil1)

  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:AddAbility("shadow1")
  		hero:FindAbilityByName("shadow1"):SetLevel(hero.abil2)
  		hero:RemoveAbility(abil3:GetAbilityName())
  		hero:AddAbility("shadow3")
  		hero:FindAbilityByName("shadow3"):SetLevel(hero.abil3)
  		local c = 50
  		--hero:SetRenderColor(c, c, c)
  		EmitSoundOn("dark_seer_dkseer_attack_05", hero)		

  	end
end

function SunForm(event)

	local hero = event.caster
	local abil1 = hero:GetAbilityByIndex(0)
	local abil2 = hero:GetAbilityByIndex(1)
	local abil3 = hero:GetAbilityByIndex(2)
	local abil4 = hero:GetAbilityByIndex(3)
	local abil5 = hero:GetAbilityByIndex(4)

	if abil3:GetAbilityName() == "moon2" then
		--print("to holy")
		hero:RemoveModifierByName("modifier_moonstance")
		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_sunstance", nil)
		hero.abil1=abil1:GetLevel()
		hero.abil2=abil2:GetLevel()
		hero.abil3=abil3:GetLevel()
		hero.abil4=abil4:GetLevel()
		hero.abil5=abil5:GetLevel()

  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:RemoveAbility(abil3:GetAbilityName())
  		hero:RemoveAbility(abil4:GetAbilityName())
  		hero:RemoveAbility(abil5:GetAbilityName())

  		hero:AddAbility("moon1")
  		hero:FindAbilityByName("moon1"):SetLevel(hero.abil1)
  		hero:AddAbility("RootsDruidMoon")
  		hero:FindAbilityByName("RootsDruidMoon"):SetLevel(hero.abil2)
  		hero:AddAbility("moon12")
  		hero:FindAbilityByName("moon12"):SetLevel(hero.abil3)
  		hero:AddAbility("moon9")
  		hero:FindAbilityByName("moon9"):SetLevel(hero.abil4)
  		hero:AddAbility("moon10")
  		hero:FindAbilityByName("moon10"):SetLevel(hero.abil5)
  		hero:SetRenderColor(255, 255, 255)
  		
  		--EmitSoundOn("vengefulspirit_vng_levelup_03", hero)		
  	else
  		--print("to moon")
  		hero:RemoveModifierByName("modifier_sunstance")
		event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_moonstance", nil)

		hero.abil1=abil1:GetLevel()
		hero.abil2=abil2:GetLevel()
		hero.abil3=abil3:GetLevel()
		hero.abil4=abil4:GetLevel()
		hero.abil5=abil5:GetLevel()

  		hero:RemoveAbility(abil1:GetAbilityName())
  		hero:RemoveAbility(abil2:GetAbilityName())
  		hero:RemoveAbility(abil3:GetAbilityName())
  		hero:RemoveAbility(abil4:GetAbilityName())
  		hero:RemoveAbility(abil5:GetAbilityName())

  		hero:AddAbility("moon11")
  		hero:FindAbilityByName("moon11"):SetLevel(hero.abil1)
  		hero:AddAbility("moon3")
  		hero:FindAbilityByName("moon3"):SetLevel(hero.abil2)
  		hero:AddAbility("moon2")
  		hero:FindAbilityByName("moon2"):SetLevel(hero.abil3)
  		hero:AddAbility("moon4")
  		hero:FindAbilityByName("moon4"):SetLevel(hero.abil4)
  		hero:AddAbility("moon5")
  		hero:FindAbilityByName("moon5"):SetLevel(hero.abil5)
  		
  		--EmitSoundOn("vengefulspirit_vng_levelup_03", hero)	
  		local c = 200
  		hero:SetRenderColor(c, c, c)
  		--EmitSoundOn("vengefulspirit_vng_attack_12", hero)		

  	end
end

function holynova(event)
	local caster = event.caster
	local ability = event.ability
	local range = event.range

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if enemy:GetUnitLabel()=="hero" then
                    if ability:GetLevel() >= 4 then
                        ability:ApplyDataDrivenModifier(caster, enemy, "modifier_judgement_armor", {Duration = 8})
                    end
					local table = {}
					table.caster = caster
					table.target = enemy
					table.ability = ability
					table.attributefactor = event.attributefactor
					table.spelldamagefactor = event.spelldamagefactor
					table.heal = 0
					table.critmanareg = event.critmanareg
                    table.isaoeheal = event.isaoeheal
					HealUnit(table)
					local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_omniknight/omniknight_purification_light_b.vpcf", PATTACH_POINT_FOLLOW, enemy)
                    ParticleManager:ReleaseParticleIndex(particle)
				end
			end
		end
	end

	--event.breakcc = 1
	event.aoe = range
	event.attributefactor = event.attributefactor * event.dmgfactor / 100
	event.spelldamagefactor = event.spelldamagefactor * event.dmgfactor / 100
	event.targeteffect = "holy"
	DamageAOE(event)
end

function HeadArmor( event )
	local caster = event.caster
	--print(event.ability:GetName())
	if caster:GetHealth()/caster:GetMaxHealth() < 0.5 then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_headarmor1proc", nil)
	else
		caster:RemoveModifierByName("modifier_item_headarmor1proc")
	end
end

function LastLight( event )
	local caster = event.caster
	--print(event.ability:GetName())
	if caster:GetHealth()/caster:GetMaxHealth() <= 0.5 then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_lastlightproc", nil)
	else
		caster:RemoveModifierByName("modifier_item_lastlightproc")
	end
end

function ReduceStealthCooldown( event )
	local caster = event.caster
	--print("called")
	local boo = caster:HasModifier("modifier_item_nightblade") or caster:HasModifier("modifier_item_rogueblades")
	--local boo2 = caster:HasModifier("modifier_item_allstats2up")
	if boo then
		--print("called")
		local ability = event.ability
		--print(ability:GetCooldownTimeRemaining())
		--Timers:CreateTimer(0.01, function()
			local t = ability:GetCooldownTimeRemaining()-5.0
			if event.percent ~= nil then
				t = ability:GetCooldownTimeRemaining()*event.percent
			end
			ability:EndCooldown()
			ability:StartCooldown(t)
		--end)
	end
end

function Polymorph( event )
	local caster = event.caster
	local target = event.target
	local power = GetCCPower(event)
	local tab = {}
	tab.Duration = event.dur*power
	--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_voodoo_datadriven", tab)
	if target:GetUnitLabel() == "tower" then
 		return
	end

	local myevent = {}
	myevent.caster = caster
	myevent.target = target
	myevent.buff = "modifier_voodoo_datadriven"
	myevent.ability = event.ability
	myevent.dur = event.dur*power
	ApplyBuff(myevent)
end

function SilenceTarget( event )
	local caster = event.caster
	local target = event.target
	local power = 1.0
	if event.curseblade then
		power = GetCCPower(event)
	end
	event.dur = event.dur*power
	--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_silence", tab)
	event.buff = "modifier_silence"
	ApplyBuff(event)
end

function CCTarget( event )
	local caster = event.caster
	local target = event.target
	local power = 1.0
    if event.innercd_shadow11 then
        if caster.innercd_shadow11 then
            return
        else
            Timers:CreateTimer(0.05, function()
                caster.innercd_shadow11 = true
                Timers:CreateTimer(event.innercd_shadow11 * GetInnerCooldownFactor(caster), function()
                    caster.innercd_shadow11 = false
                end)
            end)
        end
    end
	if event.curseblade then
		power = GetCCPower(event)
	end
	event.dur = event.dur*power
	ApplyBuff(event)
end

function GetCCPower( event )
	local caster = event.caster
	--print("called")
	local power = 1.0
	if caster:HasModifier("modifier_item_curseblade") then
		power = power * 1.25
	end
	return power
end

function GlobalOnDamagingCritLanded(caster, target)
    if caster.talents then
        if caster.talents[103] and caster.talents[103] > 0 then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_heartbreaker", {Duration = 2 + caster.talents[103]})
        end
        if not caster.critsPerSecond then
            caster.critsPerSecond = 0
        end
        caster.critsPerSecond = caster.critsPerSecond + 1
        if caster.critsPerSecond >= 3 and caster.talents[122] > 0 and not caster:HasModifier("modifier_critmass") then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_critmass", {Duration = 5})
        end
        Timers:CreateTimer(1,function()
            caster.critsPerSecond = caster.critsPerSecond - 1
        end)
    end
end

function GlobalOnTakeDamage(event)
    local caster = event.caster
    local target = event.attacker
    local ability = caster.combat_system_ability
    if GetWrathOfGodStat(caster) >= 1 then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_wog", {Duration = 8})
        caster:SetModifierStackCount("modifier_wog", caster.combat_system_ability, GetWrathOfGodStat(caster))
    end
end

function OnSummonDamage(caster, target, ability)
    if GetBeastWithinStat(caster) > 0 then
        RestoreResource({caster = caster, amount = GetBeastWithinStat(caster)})
    end
end

function GlobalOnAttackLanded( event )
    local caster = event.caster
    local target = event.target
    if caster.talents then
        if caster.talents[118] and caster.talents[118] > 0 and math.random(1,100) <= 10 and not caster.moltenCD then
            caster.moltenCD = true
            RestoreResource({caster = caster, amount = 3 * caster.talents[118]})
            local particle = ParticleManager:CreateParticle("particles/econ/items/axe/axe_ti9_immortal/axe_ti9_beserkers_call_owner_aoe_ground_glow.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            Timers:CreateTimer(2, function()
                caster.moltenCD = false
            end)
        end
        if caster.talents[92] and caster.talents[92] > 0 then
            local healThreshold = 50
            if not caster.frostmourne_aa_counter then
                caster.frostmourne_aa_counter = 0
            end
            caster.frostmourne_aa_counter = caster.frostmourne_aa_counter + 1
            if caster.frostmourne_aa_counter >= healThreshold then
                caster:RemoveModifierByName("modifier_frostmourne")
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_lichking", {Duration = 3 * caster.talents[92]})
                caster.frostmourne_aa_counter = 0
                HealUnit({caster = caster, target = caster, ability = caster.combat_system_ability, heal = 0, percenthp = 5*caster.talents[92] })
                EmitSoundOn("DOTA_Item.HealingSalve.Activate", target)
                local particle = ParticleManager:CreateParticle("particles/items2_fx/soul_ring.vpcf", PATTACH_POINT_FOLLOW, caster)
                --ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
                ParticleManager:ReleaseParticleIndex(particle)
            else
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_frostmourne", {Duration = 25})
                caster:SetModifierStackCount("modifier_frostmourne", caster.combat_system_ability, caster.frostmourne_aa_counter)
            end
        end
        if caster.talents[98] and caster.talents[98] > 0 then
            ApplyBuffStack({ caster = caster, target = caster, buff = "modifier_unholyfrenzy", ability = caster.combat_system_ability, max = 100, dur = 5})
        end
        if GetLevelOfAbility(caster, "Feral1") >= 4 and GetStrengthCustom(caster) > GetAgilityCustom(caster) and math.random(1,100) <= 20 then
            Timers:CreateTimer(0.1, function()
                PerformAutoAttack({caster = caster, target = target})
            end)
        end
    end
    if math.random(1,100) <= GetMultistrikeStat(caster) then
        MultistrikeProc(caster, target)
    end
end

function DivineShieldProc(caster, target, originalHealing)
    local percent = GetDivineShieldStat(caster) * 0.01
    local shield = originalHealing * percent
    local reApplyBuff = false
    if (not target.divine_shield) or target.divine_shield <= 0 then
        target.divine_shield = shield
        reApplyBuff = true
    else
        if shield > target.divine_shield then
            target.divine_shield = shield
            reApplyBuff = true
        end
    end
    if reApplyBuff then
        if target.divine_shield > target:GetMaxHealth() then
            target.divine_shield = target:GetMaxHealth()
        end
        ApplyBuffStack({caster = caster, target = target, buff = "modifier_divine_shield", ability = caster.combat_system_ability, dur = -1, addstacks = target.divine_shield, setstackcount = true})
    end
end

function MultistrikeProc(caster, originalTarget)
    local aoe = 250
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), originalTarget:GetAbsOrigin(), caster, aoe, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    if #enemies > 0 then
        EmitSoundOn("DOTA_Item.Butterfly", originalTarget)
        for _,enemy in pairs(enemies) do
            if enemy and enemy ~= originalTarget and not HasDamageReflect(enemy) then
                PerformAutoAttack({caster = caster, target = enemy})
            end
        end
    end
end

function GlobalOnAbilityExecuted( event )
    local caster = event.caster
    local target = event.target
    local ability = event.event_ability
    if GetLevelOfAbility(caster, "bear2") >= 2 and ability and ability:GetName() == "bear2" then
        local myevent = {caster = caster, amount = 100, ability = ability, chooseability = 2 }
        ReduceCooldown(myevent)
    end
    if ability and ability:GetName() == "WarriorCharge" then
        caster.mortalSwingCrit = 3
    end
    if GetLevelOfAbility(caster, "Mortal_Swing") >= 2 then
        if ability and ability:GetName() == "Mortal_Swing" and caster.mortalSwingCrit then
            caster.mortalSwingCrit = caster.mortalSwingCrit - 1
        end          
    end
    if GetLevelOfAbility(caster, "pala1") >= 4 then
        if not caster.bopCasts then
            caster.bopCasts = 0
        end
        caster.bopCasts = caster.bopCasts + 1
        if caster.bopCasts >= 10 then
            caster.bopCasts = 0
            caster:GetAbilityByIndex(0):ApplyDataDrivenModifier(caster, caster, "modifier_bop", {Duration = 3})
        end
    end
    if GetLevelOfAbility(caster, "frostdk3") >= 4 and ability and ability:GetName() == "frostdk3" then
        local myevent = {caster = caster, amount = 10, ability = ability, chooseability = 5 }
        ReduceCooldown(myevent)
    end
    if ability == caster:GetAbilityByIndex(0) then
        caster.firstabilitytarget = target
        if caster.Pet and (not caster.Pet:IsNull()) and caster.Pet:IsAlive() and not caster.Pet.IsCasting then
            if caster.Pet.isWaterEle and caster.Pet:GetAbilityByIndex(0):GetCooldownTimeRemaining() <= 0 then
                local order = 
                {
                     UnitIndex = caster.Pet:entindex(),
                     OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
                     AbilityIndex = caster.Pet:GetAbilityByIndex(0):GetEntityIndex(), 
                     Queue = false,
                    TargetIndex = target:entindex()
                }
                ExecuteOrderFromTable(order)
            else
                local order = 
                {
                    UnitIndex = caster.Pet:entindex(),
                    OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                    TargetIndex = target:entindex()
                }
                ExecuteOrderFromTable(order)
            end
        end
    end
    if GetManaRefundAmount(caster) >= 1 and ability and ability:GetManaCost(ability:GetLevel()) >= 1 then
        Timers:CreateTimer(0.05, function()
            RestoreResource({caster = caster, amount = GetManaRefundAmount(caster), flat = true})
        end)
    end
    if GetBerserkerStat(caster) > 0 then -- and ability and ability == caster:GetAbilityByIndex(0) then
        local abi = caster.combat_system_ability
        if abi then
            local myevent = { caster = caster, target = caster, dur = 60, buff = "modifier_berserker_c", ability = abi, addstacks = 1}
            local stacks = ApplyBuffStack(myevent)
            if stacks >= 25 then
                caster:RemoveModifierByName("modifier_berserker_c")
                ApplyBuff({caster = caster, target = caster, ability = abi, buff = "modifier_berserker", dur = 5})
            end
        end
    end
    if GetLevelOfAbility(caster, "Arcane7") >= 4 and ability:GetName() == "Arcane7" then
        ReduceCooldown({caster = caster, chooseability = 5, amount = 5, ability = event.ability})
    end
    if GetLevelOfAbility(caster, "RootsDruid") >= 2 and ability and (ability:GetName() == "RootsDruid" or ability:GetName() == "Shapeshift") then
        local dur = 10
        if caster:GetAbilityByIndex(0):GetLevel() >= 3 then
            dur = 15
        end
        Lifebloom({caster = caster, ability = caster:GetAbilityByIndex(0), freecast = 1, dur = dur})
    end
    if GetLevelOfAbility(caster, "Dragon_Claw") >= 3 and ability and ability:GetName() == "Molten_Lava" then
        local myevent = {caster = caster, amount = 100, ability = ability, chooseability = 3 }
        ReduceCooldown(myevent)
    end
    if GetLevelOfAbility(caster, "Ghost4") >= 2 and caster:HasModifier("modifier_stormaurabuff1") and ability and target and (ability:GetName() == "Ghost1" or ability:GetName() == "Ghost2" or ability:GetName() == "Ghost3") then
        Timers:CreateTimer(0.25, function()
            CheckForAutoAttackCriticalStrikeProcs(caster, target)
            caster:PerformAttack(target, true, true, true, true, true, false, false)
        end)
    end
    if GetLevelOfAbility(caster, "Ghost1") >= 2 and ability and ability:GetName() == "Ghost1" then
        local myevent = {caster = caster, amount = 100, ability = ability, chooseability = 1 }
        ReduceCooldown(myevent)
        myevent = {caster = caster, amount = 100, ability = ability, chooseability = 2 }
        ReduceCooldown(myevent)
    end
    if GetLevelOfAbility(caster, "wind7") >= 4 and math.random(1,100) <= 30 then
        local enemies = FindNearbyEnemies(caster, caster:GetAbsOrigin(), 900)
        if #enemies > 0 then
            for _,enemy in pairs(enemies) do
                if enemy and not enemy:IsNull() and enemy:IsAlive() and not CheckForBreakableCC(enemy) then
                    CheckForAutoAttackCriticalStrikeProcs(caster, enemy)
                    caster:PerformAttack(enemy, true, true, true, true, true, false, false)
                end
            end
        end
    end
    if GetLevelOfAbility(caster, "Polymorph") >= 3 and ability and ability:GetName() == "Polymorph" then
        for i=2,5 do
            if i ~= 4 then
                local myevent = {caster = caster, amount = 5, ability = ability, chooseability = i }
                ReduceCooldown(myevent)
            end
        end
    end
    if caster and caster.talents and ability and (not ability:IsItem()) then
        if caster:HasModifier("modifier_affix_totemcast_heal") and COverthrowGameMode.totemCastUnit and not COverthrowGameMode.totemCastUnit:IsNull() and COverthrowGameMode.totemCastUnit:IsAlive() then
            DamageUnit({caster = COverthrowGameMode.totemCastUnit, target = caster, ability = COverthrowGameMode.totemCastUnit:GetAbilityByIndex(0), damage = 0, difficultyscale = 150})
            local particle = ParticleManager:CreateParticle("particles/econ/items/pugna/pugna_ward_ti5/pugna_ward_attack_light_ti_5.vpcf", PATTACH_POINT_FOLLOW, COverthrowGameMode.totemCastUnit)
            ParticleManager:SetParticleControlEnt(particle, 0, COverthrowGameMode.totemCastUnit, PATTACH_POINT_FOLLOW, "attach_hitloc", COverthrowGameMode.totemCastUnit:GetAbsOrigin(), true)
            ParticleManager:SetParticleControlEnt(particle, 1, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn("DOTA_Item.Mjollnir.Activate", caster)
        end
        if caster.talents[36] and caster.talents[36] > 0 and (not caster:HasModifier("modifier_path36cd")) then
            local abi = GetHighestCooldownAbility(caster)
            if abi and abi == ability then
                Timers:CreateTimer(0.1, function()
                    ReduceCooldown({caster = caster, amount = 1000, ability = ability })
                end)
                local dur = (130 - 10 * caster.talents[36]) * GetInnerCooldownFactor(caster)
                if dur < 60 then
                    dur = 60
                end
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_path36cd", {Duration = dur})
            end
        end
        if caster.talents[148] and caster.talents[148] > 0 and caster:GetPrimaryAttribute() == 0 and ability == caster:GetAbilityByIndex(2) then
            ApplyBuffStack({ caster = caster, target = caster, buff = "modifier_wms", ability = caster.combat_system_ability, max = 10, dur = 5})
        end
        local destro4 = caster:FindAbilityByName("destro4")
        if destro4 and destro4:GetLevel() >= 2 and (ability:GetName() == "destro4" or ability:GetName() == "Shadowfury") then
            destro4:ApplyDataDrivenModifier(caster, caster, "modifier_destro_def", {Duration = 3})
        end
        if caster.talents[117] and caster.talents[117] > 0 and math.random(1,100) <= 20 + 10 * caster.talents[117] and not caster.bullrushcd then
            local range = 300
            if caster:IsRangedAttacker() then
                range = 900
            end
            local enemy = FindClosestEnemy({caster = caster, radius = range})
            if enemy then
                PerformAutoAttackWithDelay(caster, enemy, 0.15)
                caster.bullrushcd = true
                Timers:CreateTimer(0.3 * GetInnerCooldownFactor(caster), function()
                    caster.bullrushcd = false
                end)
            end
        end
        if caster.talents[104] and caster.talents[104] > 0 and caster:GetIncreasedAttackSpeed(false) <= (8.5 + 0.5 * caster.talents[104]) then
            local bonus = 10 + 5 * caster.talents[104]
            local duration = 5
            local cap = 450 + 50 * caster.talents[104]
            if not caster.frostwyrmFury then
                caster.frostwyrmFury = 0
            end
            if caster.frostwyrmFury < cap then
                AddSpellhaste(caster, bonus, duration)
                AddAttackSpeed(caster, bonus, duration)
                caster.frostwyrmFury = caster.frostwyrmFury + bonus
                Timers:CreateTimer(duration, function()
                    caster.frostwyrmFury = caster.frostwyrmFury - bonus
                end)
                --print(caster.frostwyrmFury)
            end
            --local particle = ParticleManager:CreateParticle("particles/econ/items/arc_warden/arc_warden_ti9_immortal/arc_warden_ti9_wraith_spawn_portal.vpcf", PATTACH_POINT_FOLLOW, caster)
            --ParticleManager:ReleaseParticleIndex(particle)
        end
        if caster.talents[129] > 0 then
            if caster:GetAbilityByIndex(0) == ability then
                caster.songIceFire1Cast = true
            end
            if caster:GetAbilityByIndex(1) == ability then
                caster.songIceFire2Cast = true
            end
        end
        if caster.talents[100] and caster.talents[100] > 0 then
            if ability == caster:GetAbilityByIndex(0) then
                caster.chaos_knight_combo_1 = true
                if caster.chaos_knight_combo_3 then
                    caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_chaosknight_combo", {Duration = 8})
                    caster.chaos_knight_combo_1 = false
                    caster.chaos_knight_combo_3 = false
                end
            end
            if ability == caster:GetAbilityByIndex(2) then
                caster.chaos_knight_combo_3 = true
                if caster.chaos_knight_combo_1 then
                    caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_chaosknight_combo", {Duration = 8})
                    caster.chaos_knight_combo_1 = false
                    caster.chaos_knight_combo_3 = false
                end
            end
        end
        if caster.snowl_item_ability and caster:HasModifier("modifier_snowl") and ability == caster:GetAbilityByIndex(5) then
            caster.snowl_item_ability:ApplyDataDrivenModifier(caster, caster, "modifier_snowl_proc", {Duration = 10})
        end
        if caster.snowl_item_ability2 and caster:HasModifier("modifier_snowl2") and ability == caster:GetAbilityByIndex(5) then
            caster.snowl_item_ability2:ApplyDataDrivenModifier(caster, caster, "modifier_snowl_proc2", {Duration = 10})
        end
        local chance = 10
        if event.event_ability and event.event_ability.is_casttime_ability then
            chance = 20
        end
        if caster.talents[29] and caster.talents[29] > 0 and target and caster ~= target and target:GetTeamNumber() ~= caster:GetTeamNumber() and math.random(1,100) <= chance then
            local baseDuration = 0.4
            local duration = baseDuration
            if caster:HasModifier("modifier_pathbuff_029") and math.random(1,100) <= 25 then
                duration = duration * 3
            end
            if caster:HasModifier("modifier_item_frostfire") and math.random(1,100) <= 10 then
                duration = duration + baseDuration * 2
            end
            if caster:HasModifier("modifier_item_frostfire2") and math.random(1,100) <= 15 then
                duration = duration + baseDuration * 3
            end
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, target, "modifier_cast_firenova", {Duration = duration})
        end
        if HeroHasNeutralItem(caster, "item_neutral_27") and ability == caster:GetAbilityByIndex(4) then
            ApplyBuff({ caster = caster, target = caster, dur = 5, buff = "modifier_stormbringer", ability = caster.combat_system_ability})
            local particle = ParticleManager:CreateParticle("particles/econ/items/arc_warden/arc_warden_ti9_immortal/arc_warden_ti9_wraith_cast_lightning.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn("Ability.GushCast", caster)
        end
        if caster.talents[93] and caster.talents[93] > 0 and ability == caster:GetAbilityByIndex(4) then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_boneshield", {Duration = 1 + 2 * caster.talents[93]})
        end
        if caster.talents[97] and caster.talents[97] > 0 and ability == caster:GetAbilityByIndex(3) and not caster:HasModifier("modifier_bloodflow_cd") then
            local dur = 2.5 + 0.5 * caster.talents[97]
            if dur > 8 then
                dur = 8
            end
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_bloodflow", {Duration = dur})
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_bloodflow_cd", {Duration = 25 * GetInnerCooldownFactor(caster)})
        end
        if caster.talents[101] and caster.talents[101] > 0 and ability == caster:GetAbilityByIndex(5) then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_path_unholyaura", {Duration = 3 + caster.talents[101]})
        end
        if caster.talents and caster.talents[7] and caster.talents[7] > 0 and target and target:GetTeamNumber() == caster:GetTeamNumber() then
            local buff = "modifier_talent_maul"
            local dot_dur = 5
            if caster:HasModifier("modifier_item_ancient_grizzly") then
                dot_dur = dot_dur * 2
            end
            local myevent = { caster = caster, target = caster, dur = dot_dur, buff = buff, ability = caster.combat_system_ability, addstacks = 1, max = caster.talents[7] * 33}
            ApplyBuffStack(myevent)
        end
        if caster.talents[90] and caster.talents[90] > 0 then
            local ab_cd = GetHighestRemainingCooldownAbility(caster)
            if ab_cd then
                local redu = 0.1 * caster.talents[90]
                if redu > 0.75 then
                    redu = 0.75
                end
                local myevent = {caster = caster, amount = redu, ability = ab_cd }
                ReduceCooldown(myevent)
            end
        end
        if (caster.talents[56] and caster.talents[56] > 0 and not event.is_end_of_channel and caster.combat_system_ability) then
            --if ability and ability.is_casttime_ability then
                local max = 8
                ApplyBuffStack({ caster = caster, target = caster, buff = "modifier_lizard_wizard", ability = caster.combat_system_ability, max = max, dur = -1})
                if caster:GetModifierStackCount("modifier_lizard_wizard", nil) >= max then
                    caster:RemoveModifierByName("modifier_lizard_wizard")
                    if not target then
                        --fire aoe
                        local damage_bonus = 1
                        if caster.book_of_runes_instants and caster.book_of_runes_instants <= 0 and caster:HasModifier("modifier_pathbuff_026") then
                            damage_bonus = 3
                        end
                        for i=1,3 do
                            Timers:CreateTimer(0.3*i, function()
                                local dmgevent = {caster = caster, ability = caster.combat_system_ability, damage = 0, attributechangeint = 1, firedmg = 1, stun = 1.5, attributefactor = 75*caster.talents[56] * damage_bonus, spelldamagefactor = 75*caster.talents[56] * damage_bonus, aoe = 900, targeteffect = "fire", isaoe = 1, dontbreakcc = 1 }
                                EmitSoundOn("Ability.LightStrikeArray", caster)
                                local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_lina/lina_spell_light_strike_array.vpcf", PATTACH_POINT_FOLLOW, caster)
                                ParticleManager:SetParticleControl(particle, 1, Vector(900,1,1))
                                ParticleManager:ReleaseParticleIndex(particle)
                                DamageAOE(dmgevent)
                            end)
                        end
                    end
                    if target then
                        if target:GetTeamNumber() == caster:GetTeamNumber() then
                            --heal
                            for i=1,5 do
                                Timers:CreateTimer(0.3*i, function()
                                    local dmgevent = {caster = caster, target = target, ability = caster.combat_system_ability, heal = 0, percenthp = 2*caster.talents[56] }
                                    EmitSoundOn("DOTA_Item.HealingSalve.Activate", target)
                                    HealUnit(dmgevent)
                                    local particle = ParticleManager:CreateParticle("particles/dazzle_shadow_wave_green.vpcf", PATTACH_POINT_FOLLOW, caster)
                                    ParticleManager:SetParticleControlEnt(particle, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
                                    ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
                                    ParticleManager:ReleaseParticleIndex(particle)
                                end)
                            end
                        else
                            --dmg
                            for i=1,5 do
                                Timers:CreateTimer(0.15*i, function()
                                    local dmgevent = {caster = caster, target = target, ability = caster.combat_system_ability, attributechangeint = 1, damage = 0, naturedmg = 1, attributefactor = 50*caster.talents[56], spelldamagefactor = 50*caster.talents[56] }
                                    EmitSoundOn("Item.Maelstrom.Chain_Lightning.Jump", target)
                                    DamageUnit(dmgevent)
                                    --local particle = ParticleManager:CreateParticle("particles/items_fx/chain_lightning.vpcf", PATTACH_POINT_FOLLOW, caster)
                                    --ParticleManager:SetParticleControlEnt(particle, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
                                    --ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
                                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_zeus/zeus_cloud_strike.vpcf", PATTACH_WORLDORIGIN, target)
                                    ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + Vector(0,0,75))
                                    ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin() + Vector(0,0,75))
                                    ParticleManager:SetParticleControl(particle, 6, Vector(1,1,1))
                                    ParticleManager:ReleaseParticleIndex(particle)
                                end)
                            end
                        end
                    end
                end
            --end
        end
        if caster.talents[150] and caster.talents[150] > 0 and target and target:GetTeamNumber() ~= caster:GetTeamNumber() then
            local chance = 1 + 2 * caster.talents[150]
            if math.random(1,100) <= chance then
                ApplyBuff({caster = caster, target = target, ability = caster.combat_system_ability, dur = 3, buff = "modifier_shieldShatter"})
            end
        end
        if caster.talents[162] and caster.talents[162] > 0 and ability == caster:GetAbilityByIndex(3) and not caster:HasModifier("modifier_phantomShadeCD") then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_phantomShadeCD", {Duration = 30 * GetInnerCooldownFactor(caster)})
            ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, buff = "modifier_phantomShade", dur = 1 + caster.talents[162]})
        end
    end
end

function GetCooldownReductionEffectiveness( caster, ability )
    local factor = 1
    local passive_cd_reduce_ability_passive = caster:FindAbilityByName("dh6")
    if passive_cd_reduce_ability_passive and passive_cd_reduce_ability_passive:GetLevel() >= 4 then
        factor = factor * 2
    end
    passive_cd_reduce_ability_passive = caster:FindAbilityByName("Holy_Shield")
    if passive_cd_reduce_ability_passive and passive_cd_reduce_ability_passive:GetLevel() >= 4 then
        factor = factor * 1.5
    end
    passive_cd_reduce_ability_passive = caster:FindAbilityByName("Shapeshift")
    if passive_cd_reduce_ability_passive and passive_cd_reduce_ability_passive:GetLevel() >= 4 then
        factor = factor * 1.5
    end
    return factor
end

function GetChargesBonusRefreshCooldown(caster, ability)
    local factor = 1
    if caster:HasModifier("modifier_shadow_form_ds") and ability:GetName() == "shadow11" and caster:HasModifier("modifier_class_ds2") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_mage_2") then
        factor = factor * 0.5
    end
    return factor
end

function GetCooldownReductionFactor( caster, ability )
    local factor = 1
    local hoodoftime = caster:HasModifier("modifier_item_cooldown")
    if hoodoftime then
        factor = 0.85
    end
    if caster:HasModifier("modifier_item_allstats2up") then
        factor = factor * 0.9
    end
    if HeroHasNeutralItem(caster, "item_neutral_38") then
        factor = factor * 0.9
    end
    if caster:HasModifier("modifier_special_bonus_cooldown_reduction") then
        factor = factor * 0.95
    end
    if caster:HasModifier("modifier_item_cdr") then
        factor = factor * 0.95
    end
    if caster:HasModifier("modifier_item_set_int_cdgloves") then
        factor = factor * 0.95
    end
    if caster:HasModifier("modifier_pathbuff_115") and ability:IsItem() then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_item_set_int_full") then
        factor = factor * 0.95
    end
    --if caster:HasModifier("modifier_bloodflow_cd") and caster:HasModifier("modifier_pathbuff_097") then
    --    factor = factor * 0.9
    --end
    if caster:HasModifier("modifier_resaura") then
        factor = factor * 0.95
    end
    if caster:HasModifier("modifier_resaura2") then
        factor = factor * 0.9
    end
    if caster:HasModifier("modifier_npc_dota_hero_pugna") and (ability:GetName() == "destro2" or ability:GetName() == "destro6") then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_npc_dota_hero_dragon_knight") and ability:GetName() == "Shield_Reflect" then
        factor = factor * 0.7
    end
    if caster:HasModifier("modifier_npc_dota_hero_legion_commander") and ability:GetName() == "Retri2" then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_npc_dota_hero_ursa") and ability:GetName() == "bear2" then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_item_winterbreeze2") then
        factor = factor * 0.9
    end
    if caster:HasModifier("modifier_item_night_shoulders") and ability == caster:GetAbilityByIndex(5) then
        factor = factor * 0.75
    end
    if GetLevelOfAbility(caster, "special_bonus_unique_nether_wizard_4") >= 1 then
        factor = factor * 0.9
    end
    if caster.talents and caster.talents[110] and caster.talents[110] >= 1 then
        factor = factor * (1 + 0.1 * caster.talents[110])
    end
    if caster.talents and caster.talents[28] > 0 then
        factor = factor * (1 - 0.025 - 0.025 * caster.talents[28])
    end
    if caster.talents and caster.talents[41] > 0 and ability == caster:GetAbilityByIndex(4) then
        factor = factor * (1 - 0.07 * caster.talents[41])
    end
    if caster.talents and caster.talents[83] > 0 and ability == caster:GetAbilityByIndex(3) then
        factor = factor * (1 - 0.07 * caster.talents[83])
    end
    if caster.talents and caster.talents[17] > 0 and ability == caster:GetAbilityByIndex(2) then
        factor = factor * (1 - 0.05 - 0.05 * caster.talents[17])
    end
    --if caster.runeword and caster.runeword[22] > 0 and ability == caster:GetAbilityByIndex(3) then
    --    factor = factor * (1 - 0.01 * caster.runeword[22])
    --end
    --if caster.runeword and caster.runeword[23] > 0 and ability == caster:GetAbilityByIndex(5) then
    --    factor = factor * (1 - 0.01 * caster.runeword[23])
    --end
    if caster.talents and caster.talents[154] and caster.talents[154] >= 1 and ability:IsItem() then
        factor = factor * (1 - 0.15 * caster.talents[154])
        --trickster proc
        caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_trickster", {duration = 5})
    end
    if caster:HasModifier("modifier_mythic_cd") then
        factor = factor * (100 - caster:GetModifierStackCount("modifier_mythic_cd", nil)) / 100
    end
    local divine = caster:HasModifier("modifier_cd_reduce_50")
    if divine and ability:GetName() == "Holy_Judgement" then
        factor = factor * 0.5
    end
    -- str aghanim item
    local agha = caster:HasModifier("modifier_item_straxe2")
    if agha and ability:GetName() == "Sword_Storm" then
        factor = factor * 0.8
    end
    local agha2 = caster:HasModifier("modifier_item_straxe3")
    if agha2 and ability:GetName() == "Sword_Storm" then
        factor = factor * 0.7
    end
    --effectiveness
    local effectiveness = GetCooldownReductionEffectiveness( caster, ability )
    factor = 1 - (1 - factor) * effectiveness
    --cap
    local cap = 0.34
    if caster.temple_class then
        cap = 0.5
    end
    if caster.talents then
        if caster.talents[151] > 0 and ability:GetCooldown(ability:GetLevel()-1) <= 30 then
            cap = cap - 0.03 * caster.talents[151]
        end
    end

    if factor < cap then
        factor = cap
    end
    return factor
end

function CooldownReductionPet( event )
    local owner = event.caster
    if owner and owner:IsHero() then
        event.isPetAbility = true
        CooldownReduction(event)
    end
end

function CooldownReduction( event ) --also instant ability resets
	local caster = event.caster
	local ability = event.event_ability
	if not ability then
		return
	end
    local factor = GetCooldownReductionFactor( caster, ability )
	local cd = ability:GetCooldown(ability:GetLevel()-1)
	local newcd = cd
    local isPetAbility = event.isPetAbility
    --big cooldown procs
    if not isPetAbility then
        if cd >= 20 then
            if caster.talents then
                if caster.talents[81] and caster.talents[81] > 0 and caster.combat_system_ability then
                    caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_skyfall", {duration = 7})
                    caster:SetModifierStackCount("modifier_skyfall", caster.combat_system_ability, caster.talents[81] * 50)
                end
            end
        end
        if cd >= 30 and caster.talents and caster.talents[55] and caster.talents[55] > 0 and (not ability:IsItem()) and (not caster.ice_storm_cd) then
            IceStormProc(caster, false)
        end
        if cd >= 45 and caster.talents and caster.talents[59] and caster.talents[59] > 0 and not ability:IsItem() and not caster:HasModifier("modifier_talent_invul_cd") then
            local dur = 4.5 + 0.5 * caster.talents[59]
            if dur > 12 then
                dur = 12
            end
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_talent_invul", {duration = dur})
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_talent_invul_cd", {duration = 30 * GetInnerCooldownFactor(caster)})
        end
        if cd >= 60 and caster.talents and caster.talents[73] and caster.talents[73] > 0 and not ability:IsItem() then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_path_shadowform", {duration = 9 + 1 * caster.talents[73]})
            Timers:CreateTimer(0.25, function()
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_invisible", {duration = 5.1})
            end)
        end
        if cd >= 45 and caster.talents and caster.talents[159] and caster.talents[159] > 0 and not ability:IsItem() then
            Timers:CreateTimer(0.25, function()
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_invisible", {duration = 1 + caster.talents[159]})
            end)
        end

        --riki talent
        if ability:GetLevel() >= 4 and ability:GetName() == "hawk6" then
            for i=0, 5 do
                local item = caster:GetItemInSlot(i)
                if item then
                    if item:GetName() ~= "item_activedk" and item:GetName() ~= "item_activedk2" then
                        item:EndCooldown()
                    end
                end
            end
        end
        --local astral_talent_shock = caster:FindAbilityByName("moon6")
        --if astral_talent_shock and astral_talent_shock:GetLevel() >= 4 and math.random(1,100) <= 30 and ability:GetAbilityIndex() <= 2 then
        --	AstralShock(caster)
        --end
    	--cooldown item
        --ability procs
        if caster:HasModifier("modifier_npc_dota_hero_legion_commander") and ability:GetName() == "Retri2" then
            HealUnit({caster = caster, target = caster, heal = 0, percenthp = 25, ability = ability})
			
            local sphereAbility = caster:FindAbilityByName("Retri6")
			
            if(sphereAbility) then
                local sphereCooldown = sphereAbility:GetCooldown(sphereAbility:GetLevel() - 1)
                local sphereCurrentCooldown = sphereAbility:GetCooldownTimeRemaining()
                local minSphereCooldownReduction = sphereCooldown * 0.5
                if(sphereCurrentCooldown > minSphereCooldownReduction) then
                    local flatCdr = math.min(2, sphereCurrentCooldown - minSphereCooldownReduction)
                    local myevent = {caster = caster, amount = flatCdr, ability = ability, chooseabilityname = "Retri6" }
                    ReduceCooldown(myevent)
                end
            end
        end
        if caster:HasModifier("modifier_npc_dota_hero_ursa") and ability:GetName() == "bear2" then
            HealUnit({caster = caster, target = caster, heal = 0, percenthp = 15, ability = ability})
        end
        if caster:HasModifier("modifier_npc_dota_hero_invoker") and ability:GetName() == "Arcane7" then
            RestoreMana({caster = caster, percent = 1, amount = 25})
        end
        if caster.talents and caster.talents[83] > 0 and ability == caster:GetAbilityByIndex(3) then
            if caster.combat_system_ability then
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_windbreaker", {Duration = 10})
                caster:SetModifierStackCount("modifier_windbreaker", caster.combat_system_ability, caster.talents[83])
            end
        end
        if caster.talents and caster.talents[84] > 0 and caster.combat_system_ability and ability == caster:GetAbilityByIndex(5) then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_dominance", {Duration = 15})
        end
        if ability == caster:GetAbilityByIndex(3) and caster:HasModifier("modifier_summon2") then
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti8/mekanism_ti8_beam.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            if not caster.summon2_bonus then
                caster.summon2_bonus = 0
            end
            caster.summon2_bonus = caster.summon2_bonus + 1
            Timers:CreateTimer(5, function()
                caster.summon2_bonus = caster.summon2_bonus - 1
            end)
        end
        if ability == caster:GetAbilityByIndex(3) and caster:HasModifier("modifier_summon") then
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti8/mekanism_ti8_beam.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            if not caster.summon_bonus then
                caster.summon_bonus = 0
            end
            caster.summon_bonus = caster.summon_bonus + 1
            Timers:CreateTimer(5, function()
                caster.summon_bonus = caster.summon_bonus - 1
            end)
        end
    	local priestcharge = caster:GetModifierStackCount("modifier_light_charge", caster)
    	if priestcharge >= 4 and event.event_ability:GetName() == "Light_of_Heaven" and ability.wasinstant then
    		caster:RemoveModifierByName("modifier_light_charge")
    	end

        --ignoring cap here
        --druid moonburn
        local moonburn = caster:HasModifier("modifier_moonburn_cd")
        if moonburn and ability:GetName() == "moon2" then
            factor = factor * 0.25
        end
        local reload = caster:GetModifierStackCount("modifier_lockreload", nil)
        if reload >= 10 and ability:GetName() == "wind2" then
            factor = 0.01
            if reload >= 11 then
                caster:SetModifierStackCount("modifier_lockreload", caster:GetAbilityByIndex(1), reload-10)
            else
                caster:RemoveModifierByName("modifier_lockreload")
            end
        end
    end
	newcd = newcd * factor
    --minimum cooldowns
    if ability and ability:GetName() == "Holy_Shield" and newcd < 30 then
        newcd = 30
    end
    if cd >= 30 and math.random(1,100) <= GetEchoStat(caster) and not caster.echoCooldown then
        newcd = 1
        local particle = ParticleManager:CreateParticle("particles/econ/events/ti8/mekanism_ti8_beam.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        caster.echoCooldown = true
        local echocd = 180 * GetInnerCooldownFactor(caster)
        caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_echoCD", {Duration = echocd})
        Timers:CreateTimer(echocd, function()
            caster.echoCooldown = false
        end)
    end

    local minimumCooldown = 1000000
    if caster.talents then
        if caster.talents[160] > 0 and not ability:IsItem() then
            minimumCooldown = 55 - 5 * caster.talents[160]
        end
    end
    if newcd > minimumCooldown then
        newcd = minimumCooldown
        --prepration procced
        if caster.talents[160] > 0 and not ability:IsItem() then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_prep", {duration = 7})
        end
    end

	if newcd ~= cd and cd > 0 then
		Timers:CreateTimer(0.02, function()
            if ability and not ability:IsNull() then --  and ability:GetCooldownTimeRemaining() > newcd then
    			ability:EndCooldown()
    			if newcd > 0.0 then
    				ability:StartCooldown(newcd)
    			end
                --[[
    			if hunterproc then
    				caster:RemoveModifierByName("modifier_lockreload")
    				local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_windrunner/windrunner_loadout_magic.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
                    ParticleManager:ReleaseParticleIndex(particle)
    				EmitSoundOn("windrunner_wind_respawn_08", caster)
    			end]]
            end
		end)
	end
    --save values for statistics
    caster.cooldown_reduction = 1 - factor
    if not isPetAbility then
        CooldownProcs(caster, ability, cd)
        AbilityComboProcs(caster, ability)
    end
end

function PathCrowFall( event )
    local caster = event.target
    local stacks = caster:GetModifierStackCount(event.buff, nil)
    caster:SetModifierStackCount(event.buff, caster.combat_system_ability, stacks + caster.talents[89])
end

function AbilityComboProcs(caster, ability)
    --all 6 proc
    local titanarmor_proc = caster:HasModifier("modifier_item_titanarmor") or caster:HasModifier("modifier_item_titanarmor_2")
    local crowfall_proc = (caster.talents and caster.talents[89] and caster.talents[89] > 0)
    if titanarmor_proc or crowfall_proc then
        if not caster.ability_combo_6 then
            caster.ability_combo_6 = {}
        end
        local index = ability:GetAbilityIndex()
        caster.ability_combo_6[index] = true
        if caster.ability_combo_6[1] and caster.ability_combo_6[2] and caster.ability_combo_6[3] and caster.ability_combo_6[4] and caster.ability_combo_6[5] and caster.ability_combo_6[0] then
            for i=0,5 do
                caster.ability_combo_6[i] = nil
            end
            --proc
            if not caster.ability_combo_6_bonus then
                caster.ability_combo_6_bonus = 1
            else
                caster.ability_combo_6_bonus = caster.ability_combo_6_bonus + 1
            end
            if caster.ability_combo_6_bonus == 1 and titanarmor_proc then
                local particle = ParticleManager:CreateParticle("particles/econ/items/lifestealer/lifestealer_immortal_backbone_gold/lifestealer_immortal_backbone_gold_rage.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
                caster.ability_combo_6_fx = particle
            end
            if crowfall_proc and caster.combat_system_ability then
                caster:RemoveModifierByName("modifier_crowfall")
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_crowfall", {Duration = 20})
                caster:SetModifierStackCount("modifier_crowfall", caster.combat_system_ability, caster.talents[89])
            end
            Timers:CreateTimer(20,function()
                caster.ability_combo_6_bonus = caster.ability_combo_6_bonus - 1
                if caster.ability_combo_6_bonus == 0 then
                    if caster.ability_combo_6_fx then
                        ParticleManager:DestroyParticle(caster.ability_combo_6_fx,true)
                        ParticleManager:ReleaseParticleIndex(caster.ability_combo_6_fx)
                    end
                    caster.ability_combo_6_bonus = nil
                end
            end)
            if titanarmor_proc then
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_titanarmor", {Duration = 20})
            end
        end
    end
    --first 4 proc
    local blooodlust_item = caster:HasModifier("modifier_item_bloodlust") or caster:HasModifier("modifier_item_bloodlust_2")
    local armor_knowledge_item = caster:HasModifier("modifier_pathbuff_034")
    if blooodlust_item or armor_knowledge_item then
        if not caster.ability_combo_4 then
            caster.ability_combo_4 = {}
        end
        local index = ability:GetAbilityIndex()
        caster.ability_combo_4[index] = true
        if caster.ability_combo_4[1] and caster.ability_combo_4[2] and caster.ability_combo_4[3] and caster.ability_combo_4[0] then
            for i=0,3 do
                caster.ability_combo_4[i] = nil
            end
            --proc
            if blooodlust_item and caster.item_bloodlust_ability then
                local buff = "modifier_item_bloodlust_proc"
                if caster:HasModifier("modifier_item_bloodlust_2") then
                    buff = "modifier_item_bloodlust_proc_2"
                end
                caster.item_bloodlust_ability:ApplyDataDrivenModifier(caster, caster, buff, {Duration = 12})
            end
            if armor_knowledge_item and caster.item_armor_knowledge_ability then
                local buff = "modifier_item_spellpower_knowledge"
                caster.item_armor_knowledge_ability:ApplyDataDrivenModifier(caster, caster, buff, {Duration = 10})
            end
        end
    end
    local horror_item = caster:HasModifier("modifier_ancient_def")
    if horror_item then
        if not caster.ability_combo_4_5_6 then
            caster.ability_combo_4_5_6 = {}
        end
        local index = ability:GetAbilityIndex()
        caster.ability_combo_4_5_6[index] = true
        if caster.ability_combo_4_5_6[3] and caster.ability_combo_4_5_6[4] and caster.ability_combo_4_5_6[5] then
            for i=3,5 do
                caster.ability_combo_4_5_6[i] = nil
            end
            --proc
            if caster.item_horror_ability then
                local buff = "modifier_horror_proc"
                caster.item_horror_ability:ApplyDataDrivenModifier(caster, caster, buff, {Duration = caster.item_horror_ability:GetSpecialValueFor("bonus_stat12")})
            end
        end
    end
    if caster.talents then
        if caster.talents[147] and caster.talents[147] > 0 and caster:GetAbilityByIndex(0) == ability and not caster.darkInitiation then
            caster.darkInitiation = true
            AddSpellhaste(caster, 75 * caster.talents[147], 5)
            AddAttackSpeed(caster, 75 * caster.talents[147], 5)
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_darkInit", {Duration = 5})
            Timers:CreateTimer(30 * GetInnerCooldownFactor(caster), function()
                caster.darkInitiation = false
            end)
        end
    end
end

function CooldownProcs( caster, ability, cd )
    if ability and ability:GetName() == "Fear_of_Dark" then
        return
    end
    if ability and ability:GetName() == "Holy_Shield" then
        return
    end
    if caster:HasModifier("modifier_class_ele2") and ability and (ability:GetName() == "Spirit_Shock" or ability:GetName() == "serpent_twins") then
        local abil_4 = caster:GetAbilityByIndex(3)
        abil_4:EndCooldown()
    end
    if caster:HasModifier("modifier_class_bm2") and ability and (ability:GetName() == "WarriorCharge" or ability:GetName() == "Shield_Reflect" or ability:GetName() == "Terror_ShoutFury") then
        caster:FindAbilityByName("fury6"):ApplyDataDrivenModifier(caster, caster, "modifier_bm2", {Duration = 7})
    end
    if ability and cd and cd >= 45 and caster and caster.talents and caster.talents[158] > 0 then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_invisible", {Duration = 1 + caster.talents[158]})
    end
    if GetInnerFireStat(caster) >= 1 and cd and cd >= 30 then
        ApplyBuffStack({caster = caster, target = caster, buff = "modifier_innerfire", ability = caster.combat_system_ability, dur = 10, addstacks = 1, max = 5})
    end
    Timers:CreateTimer(0.05, function()
        if cd and cd >= 30 and ability and ability:GetAbilityIndex() == 5 and (caster:HasModifier("modifier_item_cd_65") or caster:HasModifier("modifier_item_cd_65_2")) and not caster.temple_class then
            local abil_5 = caster:GetAbilityByIndex(4)
            if abil_5 then
                local particle = ParticleManager:CreateParticle("particles/econ/events/ti7/blink_dagger_start_ti7_lvl2.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
                ParticleManager:ReleaseParticleIndex(particle)
                local remainingCd = abil_5:GetCooldownTimeRemaining()
                if remainingCd > 0 then
                    ReduceCooldown({caster = caster, amount = remainingCd / 2, ability = ability, chooseability = 4 })
                end
            end
        end
        if cd and cd >= 30 and ability and ability:GetAbilityIndex() == 4 and (caster:HasModifier("modifier_item_cd_54") or caster:HasModifier("modifier_item_cd_54_2")) and not caster.temple_class then
            local abil_4 = caster:GetAbilityByIndex(3)
            if abil_4 then
                local particle = ParticleManager:CreateParticle("particles/econ/events/ti7/blink_dagger_start_ti7_lvl2.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
                ParticleManager:ReleaseParticleIndex(particle)
                local remainingCd = abil_4:GetCooldownTimeRemaining()
                if remainingCd > 0 then
                    ReduceCooldown({caster = caster, amount = remainingCd / 2, ability = ability, chooseability = 3 })
                end
            end
        end
        if cd and cd >= 30 and ability and ability:GetAbilityIndex() == 3 and (caster:HasModifier("modifier_item_cd_43") or caster:HasModifier("modifier_item_cd_43_2")) and not caster.temple_class then
            local abil_3 = caster:GetAbilityByIndex(2)
            if abil_3 then
                local particle = ParticleManager:CreateParticle("particles/econ/events/ti7/blink_dagger_start_ti7_lvl2.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
                ParticleManager:ReleaseParticleIndex(particle)
                local remainingCd = abil_3:GetCooldownTimeRemaining()
                if remainingCd > 0 then
                    ReduceCooldown({caster = caster, amount = remainingCd / 2, ability = ability, chooseability = 2 })
                end
            end
        end
    end)
end

function PathIceStorm( event )
    local caster = event.caster
    if caster.talents and caster.talents[55] then
        EmitSoundOn("Ability.GushCast", event.target)
        if caster:HasModifier("modifier_pathbuff_036") then
            event.firedmg = 1
            event.iceflame_bolt = true
        end
        local damage = 1
        if caster:HasModifier("modifier_pathbuff_104") then
            damage = damage * 2
        end
        event.attributefactor = damage * event.attributefactor * caster.talents[55]
        --event.includeauto = event.includeauto * caster.talents[55]
        event.spelldamagefactor = damage * event.spelldamagefactor * caster.talents[55]
        DamageUnit(event)
    end
end

function PetEnrageItem (event)
	caster = event.caster
	
	--[[if caster.Pet ~= nil and not caster.Pet:IsNull() then
		event.ability:ApplyDataDrivenModifier(caster, caster.Pet, "modifier_active99", nil)
		particle = ParticleManager:CreateParticle("particles/items2_fx/orchid_pop.vpcf", PATTACH_POINT_FOLLOW, caster.Pet)
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
	end
	if caster.Pet1 ~= nil and not caster.Pet1:IsNull() then
		event.ability:ApplyDataDrivenModifier(caster, caster.Pet1, "modifier_active99", nil)
		particle = ParticleManager:CreateParticle("particles/items2_fx/orchid_pop.vpcf", PATTACH_POINT_FOLLOW, caster.Pet1)
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
	end
	if caster.Pet2 ~= nil and not caster.Pet2:IsNull() then
		event.ability:ApplyDataDrivenModifier(caster, caster.Pet2, "modifier_active99", nil)
		particle = ParticleManager:CreateParticle("particles/items2_fx/orchid_pop.vpcf", PATTACH_POINT_FOLLOW, caster.Pet2)
		ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
		ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
	end]]--
    local heal = 0
	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, 99999, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy:GetPlayerOwnerID() == caster:GetPlayerOwnerID()  then
				--print("yo3")
			end
			if enemy ~= nil and (enemy:GetPlayerOwnerID() == caster:GetPlayerOwnerID() or enemy == caster.Pet or enemy == caster.Pet1 or enemy == caster.Pet2) and enemy:GetUnitLabel() == "pet" and not enemy:IsNull() then
				event.ability:ApplyDataDrivenModifier(caster, enemy, "modifier_active99", nil)
				local particle = ParticleManager:CreateParticle("particles/items2_fx/orchid_pop.vpcf", PATTACH_POINT_FOLLOW, enemy)
				ParticleManager:SetParticleControl(particle, 1, Vector(1,0,0))
				ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
                ParticleManager:ReleaseParticleIndex(particle)
                heal = heal + 1
			end
		end
	end
    if event.healpertarget then
        local myevent = {}
        myevent.caster = caster
        myevent.percenthp = event.healpertarget*heal
        myevent.heal = 0.0
        HealUnit(myevent)
    end
end

function BowCrit( event )
	local caster = event.caster
	local oldpos = caster.bowcritpos
	if oldpos ~= nil then
		local distance = (oldpos-caster:GetAbsOrigin()):Length()
		if distance < 25.0 then
			if caster.bowcritcounter ~= nil then
				caster.bowcritcounter = caster.bowcritcounter + 1
			else
				caster.bowcritcounter = 1
			end
			if caster.bowcritcounter > 10 then
				event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_bowupgradeproc", nil)
			end
		else
			caster:RemoveModifierByName("modifier_item_bowupgradeproc")
			caster.bowcritcounter = 0
		end
	end
	caster.bowcritpos = caster:GetAbsOrigin()
end

function BowCritSell( event )
	local caster = event.caster
	if caster:HasModifier("modifier_item_bowupgrade") then

	else
  		caster:RemoveModifierByName("modifier_item_bowupgradeproc")
	end
end

function WarriorCharge( event )
	local caster = event.caster
	local target = event.target
	local order = 
		{
			UnitIndex = caster:entindex(),
			OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			TargetIndex = target:entindex()
		}

	ExecuteOrderFromTable(order)
end

function AttackOrder( event )
	local caster = event.attacker
	local target = event.target
	local order = 
		{
			UnitIndex = caster:entindex(),
			OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			TargetIndex = target:entindex()
		}
	ExecuteOrderFromTable(order)
end

function StunTarget( event )
	local caster = event.caster
	local target = event.target
	local ability = caster:GetAbilityByIndex(5)
	if ability == nil then
		ability = caster:GetAbilityByIndex(0)
	end
	local dur = event.dur
	if caster:HasModifier("modifier_item_stunitem") then
 		--dur = dur + 1.5
	else
		if caster.owner ~= nil and caster.owner:HasModifier("modifier_item_stunitem") then
 			--dur = dur + 1.5
 		end
	end
    if caster:HasModifier("modifier_item_stunitem2") then
        --dur = event.dur + 2
        local myevent = {}
        myevent.caster = caster
        myevent.percenthp = 15
        myevent.heal = 0.0
        HealUnit(myevent)
        particle = ParticleManager:CreateParticle("particles/econ/items/omniknight/hammer_ti6_immortal/omniknight_purification_immortal_cast.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
    else
        if caster.owner ~= nil and caster.owner:HasModifier("modifier_item_stunitem2") then
            --dur = event.dur + 2
            local myevent = {}
            myevent.caster = caster
            myevent.percenthp = 45
            myevent.heal = 0.0
            HealUnit(myevent)
            particle = ParticleManager:CreateParticle("particles/econ/items/omniknight/hammer_ti6_immortal/omniknight_purification_immortal_cast.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
	local tab = {}
	tab.ability = ability
	tab.dur = dur
	tab.caster = caster
	tab.target = target
	tab.buff = "modifier_stunned"
	ApplyBuff(tab)
	--ability:ApplyDataDrivenModifier(caster, target, "modifier_stunned", tab)
end

function DeadlyPoisonProc(event)
	local caster = event.caster
	local chance = event.chance
	if caster:HasModifier("modifier_bladerush") then
  		chance = chance * 2
	end
	--print(chance)
	if math.random(1,100) <= chance then
		ApplyBuffStack(event)
	end
end

function FatalPoisonSpread(event)
    local caster = event.caster
    local ability = event.ability
    local point = event.target_points[1]

    if ability:GetLevel() < 5 then
        return
    end

    local highestStack = 0
    local highestStackEnemy = nil
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), point, caster, 300, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy then
                local stacks = enemy:GetModifierStackCount("modifier_deadlypoison", nil)
                if stacks > highestStack then
                    highestStack = stack
                    highestStackEnemy = enemy
                end
            end
        end
    end

    if highestStackEnemy then
        for _,enemy in pairs(enemies) do
            if enemy and enemy ~= highestStackEnemy then
                local myevent = { caster = caster, target = enemy, buff = "modifier_deadlypoison", ability = caster:FindAbilityByName("combat2"), max = 50, dur = 10}
                ApplyBuffStack(myevent)
            end
        end
    end
end

function GetPrimalFearProcDuration( caster, target )
    local factor = 1
    if target and caster and caster:IsHero() then
        if not target.primal_fear then
            target.primal_fear = {}
        end
        local playerid = caster:GetPlayerID()
        if playerid then
            if not target.primal_fear[playerid] then
                target.primal_fear[playerid] = true
                factor = 1 + 0.01 * GetPrimalFearStat(caster)
            end
        end
    end
    return factor
end

function ApplyBuff(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local duration = event.dur
	local buff = event.buff
	local isBuff = true
    if caster == nil then
        return
    end
	if ability == nil then
		ability = caster:GetAbilityByIndex(0)
	end
	if ability == nil then
		return
	end
    if not caster:IsAlive() then
    	if not event.whiledead then
        	return
        end
        if caster:IsNull() then
        	return
        end
    end
    if event.selfcast then
        target = caster
    end
	if event.attacker then
		caster = event.attacker
	end
	if event.casterchangeattacked then
		caster = event.unit
		target = event.attacker
	end
	if event.casterchangeattackedaura then
		caster = event.target
		target = event.attacker
	end
	if event.ondealdamagetarget then
		target = event.unit
	end
    if event.ontakedamagetarget then
        target = event.attacker
    end
    if event.onattacked then
        caster = event.caster
        target = event.attacker
    end
	if target == nil then
		target = caster
	end
    if caster and caster.owner then
        caster = caster.owner
    end
    if event.stunOnFirstHit and ability and target then
        local code = "stun" .. ability:GetName() .. tostring(caster:GetPlayerID())
        if target.code then
            return
        end
        target.code = true
    end
    if event.requires_and_starts_cooldown then
        if ability:GetCooldownTimeRemaining() > 0 then
            return
        else
            ability:StartCooldown(event.requires_and_starts_cooldown)
        end
    end

    if event.buffstackthresholdbased then
        local max = event.buffstackthresholdbased
        local bonusfactor = target:GetModifierStackCount(event.stackbasedbuff, nil) / max
        if bonusfactor < 1.0 then
            return
        else
            target:RemoveModifierByName("modifier_moon_curse")
        end
    end
	
	
    if event.ignore_bosses and target.isboss then
        return
    end
	--smokebomb
	if (target:HasModifier("modifier_smokebomb") and not caster:HasModifier("modifier_smokebomb")) or (target:HasModifier("modifier_smokebomb") and not caster:HasModifier("modifier_smokebomb")) then
		--maybe silence briefly
		--return disabled!
	end

	if target:GetTeamNumber() == caster:GetTeamNumber() then --buff

	else --debuff
		isBuff = false
	end

    if not isBuff and not event.is_already_aoe_buff and (buff == "modifier_cyclone_self" or buff == "modifier_rootsdruid") and caster:HasModifier("modifier_npc_dota_hero_furion") then
        event.dur = event.dur * 1.1
        event.aoe = 300
        event.targetpos = 1
        ApplyBuffAOE(event)
        return
    end
    if caster.talents and caster.talents[141] and caster.talents[141] > 0 and duration and not isBuff then
        duration = duration + 0.5 * caster.talents[141]
    end
    if GetLevelOfAbility(caster, "ench2") >= 4 and not isBuff then
        duration = duration + 1
    end
    if caster.talents and caster.talents[133] and caster.talents[133] > 0 and duration and buff == "modifier_silence" and not isBuff and not HasDamageReflect(target) and not caster.mimesisCD then
        caster.mimesisCD = true
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_stunned", dur = caster.talents[133]})
        DamageUnit({caster = caster, target = target, ability = ability, damage = 0, spelldamagefactor = 500 * caster.talents[133], includeauto = 500 * caster.talents[133], shadowdmg = 1, chaosdmg = 1})
        HealUnit({caster = caster, target = caster, heal = caster:GetMaxHealth() * 0.05 * caster.talents[133], ability = ability})
        Timers:CreateTimer(5, function()
            caster.mimesisCD = false
        end)
    end
	--adjust time of buff
	if duration and event.cursebladespecial and caster:HasModifier("modifier_item_curseblade") and not isBuff then
    	duration = duration * GetCCPower(event)
	end
	if duration and target:HasModifier("modifier_item_bootshp2") and not isBuff then
    	duration = duration * 0.75
	end
    --debuff durations
    if duration and not isBuff then
        duration = duration * GetPrimalFearProcDuration(caster, target)
        if caster:HasModifier("modifier_item_bootscurse") or caster:HasModifier("modifier_item_bootscurse_2") then
            duration = duration * 1.15
        end
        if caster:HasModifier("modifier_item_ancient_dot") then
            duration = duration * 1.25
        end
        if target:HasModifier("modifier_fanatic_rage") then
            duration = duration * 2
        end
    end
    if duration and not isBuff and caster.talents and caster.talents[5] then
        duration = duration * (1 + caster.talents[5]*0.1)
    end
    if caster.talents and caster.talents[71] and caster.talents[71] > 0 and duration and not isBuff then
        duration = duration * (1 + 0.05 * caster.talents[71])
    end
    if duration and caster:HasModifier("modifier_pathbuff_111") then
        duration = duration * 1.05
    end
    --extra buff dur talent
    if duration and isBuff and caster.talents and caster.talents[5] and ((buff == "modifier_resto" or buff == "modifier_regrowth2" or buff == "modifier_prayerprotection" or buff == "modifier_pain_supression" or buff == "modifier_hot3" or buff == "modifier_eternallife" or buff == "modifier_regrowth" or buff == "modifier_bloodlust_ele") or (buff == "modifier_taunt123" and GetLevelOfAbility(caster, "holy55") >= 4 )) then
        local extra_dur = 0
        if caster:HasModifier("modifier_ancient_allstats") then
            extra_dur = extra_dur + 2
        end
        duration = duration * (1 + (extra_dur + caster.talents[5])*0.05)

    end

    --shield reflect swap targets
    if (not isBuff) and (target:HasModifier("modifier_shieldreflect") or target:HasModifier("modifier_shieldreflect_charges") or target:HasModifier("modifier_buffreflect") or caster:HasModifier("modifier_dark_mirror")) then
        local reflectcharges = target:GetModifierStackCount("modifier_shieldreflect_charges", nil)
        if reflectcharges > 1 then
            target:SetModifierStackCount("modifier_shieldreflect_charges", ability, reflectcharges-1)
        else
            target:RemoveModifierByName("modifier_shieldreflect_charges")
        end
        --local particle = ParticleManager:CreateParticle("particles/items3_fx/lotus_orb_reflect.vpcf", PATTACH_POINT_FOLLOW, target)
        EmitSoundOn("Item.CrimsonGuard.Cast", target)
        EmitSoundOn("terrorblade_terr_reflection_02", target)
        --particle = ParticleManager:CreateParticle("particles/econ/events/ti5/dagon_ti5.vpcf", PATTACH_POINT_FOLLOW, target)
        --ParticleManager:SetParticleControl(particle, 1, caster:GetAbsOrigin()+Vector(0,0,80))
        --ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
        if target:HasModifier("modifier_buffreflect") and duration and duration > 0.1 then
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.buff = "modifier_buffreflect"
            myevent.ability = ability
            DecreaseBuffStack(myevent)
        end
        --return
        target = caster
    end

    --cycloned targets are imune new buffs
    if target:HasModifier("modifier_cyclone_self") or (not isBuff and target:HasModifier("modifier_invul")) then
        return
    end

    --silence and interrupt imunity
    if target:HasModifier("modifier_activemage") and buff == "modifier_silence" then
        return
    end

    --silence and stun imunity
    if target:HasModifier("modifier_interruptimune") and (buff == "modifier_silence" or buff == "modifier_stunned") then
        return
    end

    --bladestorm makes cyclone imune
    if target:HasModifier("modifier_axestorm") and buff == "modifier_cyclone_self" then
        return
    end

	--debuff imunity
	if not isBuff and target:HasModifier("modifier_buff_imune") then
		EmitSoundOn("Item.CrimsonGuard.Cast", target)
		local particle = ParticleManager:CreateParticle("particles/items3_fx/lotus_orb_reflect.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
		if target.groundingtotemsource and not target.groundingtotemsource:IsNull() then
			particle = ParticleManager:CreateParticle("particles/econ/events/ti5/dagon_ti5.vpcf", PATTACH_POINT_FOLLOW, target)
			ParticleManager:SetParticleControl(particle, 1, target.groundingtotemsource:GetAbsOrigin()+Vector(0,0,80))
			ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
		end
 		return
	end

    if target:GetUnitName() == "temple_water_boss_4" and (buff == "modifier_worm_skinpoison1" or buff == "modifier_worm_skinpoison2" or buff == "modifier_worm_skinpoison3") then
        return
    end

	if (buff == "modifier_stunned" or buff == "modifier_deepfreeze" or buff == "modifier_frostarmorbuff" or buff == "modifier_rootedfx") and duration and duration > 0 and not isBuff then
        --stun bonus durations
        if duration then
            if caster:HasModifier("modifier_item_stunitem") then
                duration = duration * 1.2
            end
            if caster:HasModifier("modifier_item_stunitem2") then
                duration = duration * 1.2
            end
        end
		--ParticleManager:CreateParticleForPlayer("particles/screen_blood_3.vpcf", PATTACH_POINT_FOLLOW, target, target:GetOwner())
		--ParticleManager:CreateParticleForPlayer("particles/econ/events/killbanners/screen_killbanner_compendium14_firstblood_drips.vpcf", PATTACH_POINT_FOLLOW, caster, caster:GetOwner())
		--ParticleManager:CreateParticleForPlayer("particles/econ/events/killbanners/screen_killbanner_compendium14_firstblood_drips.vpcf", PATTACH_POINT_FOLLOW, target, target:GetOwner())

		--prot talent
		local stuntalent = caster:FindAbilityByName("Switch_Battle_Stance_Prot")
        if not stuntalent then
            stuntalent = caster:FindAbilityByName("temple_brawler_defstance")
        end
	    if stuntalent and stuntalent:GetLevel() >= 4 then
	    	if duration then
				duration = duration * 1.25
                local myevent = {}
                myevent.caster = caster
                myevent.percenthp = 5
                myevent.heal = 0.0
                myevent.ability = ability
                HealUnit(myevent)
                myevent = {}
                myevent.caster = caster
                myevent.target = target
                myevent.ability = ability
                myevent.counterblow = 25
                --myevent.cannotcrit = true
                DamageUnit(myevent)
			end
	    end
        if caster:HasModifier("modifier_npc_dota_hero_dazz2") then
            ReduceCooldown({caster = caster, amount = 3, ability = ability, chooseabilityname = "Feral5" })
            ReduceCooldown({caster = caster, amount = 2, ability = ability, chooseabilityname = "Feral1" })
        end
        if caster.talents and caster.talents[71] and caster.talents[71] > 0 then
            local buff = "modifier_path_overwhelm"
            local ow_ability = caster.combat_system_ability
            if ow_ability then
                ow_ability:ApplyDataDrivenModifier(caster, caster, buff, {Duration = 12})
            end
        end
        if GetLevelOfAbility(caster, "mars2") >= 3 then
            HealUnit({caster = caster, target = caster, heal = caster:GetMaxHealth() * 0.05, ability = event.ability})
        end
        if caster.talents and caster.talents[58] and caster.talents[58] > 0 and caster:HasModifier("modifier_pathbuff_058") then
            if not caster.true_blood_from_stun then
                caster.true_blood_from_stun = 0
            end
            caster.true_blood_from_stun = caster.true_blood_from_stun + 1
            if caster.true_blood_from_stun == 1 then
                caster.true_blood_particle_2 = ParticleManager:CreateParticle("particles/items4_fx/spirit_vessel_damage_ring_detail.vpcf", PATTACH_POINT_FOLLOW, caster)
            end
            Timers:CreateTimer(15, function()
                caster.true_blood_from_stun = caster.true_blood_from_stun - 1
                if caster.true_blood_from_stun == 0 then
                    ParticleManager:DestroyParticle(caster.true_blood_particle_2,false)
                    ParticleManager:ReleaseParticleIndex(caster.true_blood_particle_2)
                end
            end)
        end
	end
	--pve debuff downscaling on bosses for hard CC, non breakable (stun, silence, fear)
    if duration and not isBuff and IsHardCC(buff) and target:HasModifier("modifier_pvebosssystem") and not target:HasModifier("modifier_fanatic_rage3") then
        if (not target.isboss) and target.is_champion then
            --champ
            duration = duration * 0.5
        elseif target.isboss then
            duration = 0.05 --duration * 0.3 --0.5
            --bosses
            --if not isBuff then
            --    OnApplyDebuff(event)
            --end
            --return
    	end
    end

    if event.bearpvedontroot then
        buff = "modifier_bear_slow_pve"
    end

	--if buff == "modifier_sap2" then
	--	ParticleManager:CreateParticleForPlayer("particles/screen_blind_1.vpcf", PATTACH_POINT_FOLLOW, target, target:GetOwner())
	--end

	--print(duration)
	if duration and duration == 0 then
		return
	end
    if event.maxdur and duration > event.maxdur then
        duration = event.maxdur
    end
	local tab = {}
	tab.Duration = duration
	--print("buff duration " .. duration)
    if (not target:IsNull()) and (not caster:IsNull()) and not ability:IsNull() then
        local buffHandle = ability:ApplyDataDrivenModifier(caster, target, buff, tab)
        if event.settickrate and buffHandle then
            --print("set tick rate")
            --print("my haste " .. GetDoTSpellhaste(caster, event))
            local tickrate = event.settickrate / GetDoTSpellhaste(caster, event)
            buffHandle:StartIntervalThink(tickrate)
        end
        --[[
        if event.applydotsystem then
            local damagedata = {
                dur = event.applydotsystem_dur
                damagedata = {

                }
            }
            target:AddNewModifier(caster, ability, "modifier_dotsystem", damagedata)
        end]]
    end
    if not isBuff then
        OnApplyDebuff(event)
    end
end

function KillUnit( event )
	local caster = event.caster
	caster:Kill(event.ability, event.target)
end

function KillSummon(event)	
	local caster = event.target
	Timers:CreateTimer(2.5, function()
	    if caster ~= nil and not caster:IsNull() then
			UTIL_Remove(caster)
		end
	end)
end

function ShadowTentacleHealth(event)
    local caster = event.caster
    local target = event.target
    local health = caster:GetHealth() * 0.2
    target:SetBaseMaxHealth(health)
    target:SetMaxHealth(health)                           
    target:SetHealth(health)
end

function FrostwyrmAttack( event )
    local caster = event.caster
    local frostwyrm = caster.frostwyrm
    if frostwyrm and not frostwyrm:IsNull() and frostwyrm:IsAlive() and math.random(1,100) <= 50 and caster.armydeadtarget and not caster.armydeadtarget:IsNull() and caster:HasModifier("modifier_npc_dota_hero_sven") then
        CheckForAutoAttackCriticalStrikeProcs(caster, caster.armydeadtarget)
        frostwyrm:PerformAttack(caster.armydeadtarget, true, true, true, true, true, false, false)
    end
end

function ArmyDead(event)
	local caster = event.caster
	local target = event.target
    caster.frostwyrm = target
	target.owner = caster
	caster.armydeadskeleton = 0
	--local unit = event.victim
	local dista = math.random(200,350)
	local vec = caster:GetAbsOrigin() + caster:GetForwardVector():Normalized()*dista
	target:SetAbsOrigin(vec)

	target:SetRenderColor(190, 190, 255)

	--unit:CreatureLevelUp(event.ability:GetLevel()-1)
	--print(caster:GetName())
	--print(target:GetName())
	--local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_jakiro/jakiro_base_attack_frost_explosion_c.vpcf", PATTACH_POINT_FOLLOW, target)
	local dmg = caster:GetAttackDamage() * event.basedamage / 100
    if event.strength then
        dmg = 0
    end
	local health = caster:GetMaxHealth() * 0.05

	--target:SetBaseDamageMin(dmg)
	--target:SetBaseDamageMax(dmg)
	target:SetBaseMaxHealth(health)
	target:SetMaxHealth(health)                           
	target:SetHealth(health)
	
	Timers:CreateTimer(0.1, function()
	    local order = 
		{
			UnitIndex = target:entindex(),
			OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			TargetIndex = caster.armydeadtarget:entindex()
		}
		ExecuteOrderFromTable(order)
	end)
end

function ArmyDeadAttackOrder(event)
    local caster = event.caster
    local target = event.target
    if caster and target and caster.armydeadtarget and not caster.armydeadtarget:IsNull() and caster.armydeadtarget:IsAlive() then
        local order = 
        {
            UnitIndex = target:entindex(),
            OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
            TargetIndex = caster.armydeadtarget:entindex()
        }
        ExecuteOrderFromTable(order)
    end
end

function IronTalon(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability

	local armor = math.floor(target:GetPhysicalArmorValue(false)*0.5)
    if event.armor then
        armor = event.armor
    end
	--ability:ApplyDataDrivenModifier(caster, target, "modifier_armoriron", nil)
    if armor < 1 then
        return
    end
	local myevent = {}
	myevent.caster = caster
	myevent.target = target
	myevent.buff = "modifier_armoriron"
	myevent.ability = ability
	myevent.dur = event.dur
	ApplyBuff(myevent)
	target:SetModifierStackCount("modifier_armoriron", ability, armor)
end

function MythicMinusArmor(event)
    local caster = event.attacker
    local target = event.target
    local ability = event.ability
    local armor = caster:GetModifierStackCount("modifier_mythic_minusarmor", nil)
    if caster.talents and caster.talents[43] > 0 then
        armor = armor + (0.5 + caster.talents[43] * 0.5)
    end
    if armor <= 0 then
        return
    end
    local myevent = {}
    local playerid = caster:GetPlayerID()
    myevent.caster = event.caster
    myevent.target = target
    myevent.buff = "modifier_piercearmor_m_"..playerid
    myevent.ability = ability
    myevent.dur = 8
    ApplyBuff(myevent)
    target:SetModifierStackCount(myevent.buff, ability, armor)
end

function MythicMinusSpellres(event)
    local caster = event.attacker
    local target = event.unit
    local ability = event.ability
    local armor = caster:GetModifierStackCount("modifier_mythic_minusspellres", nil)
    local myevent = {}
    local playerid = caster:GetPlayerID()
    myevent.caster = caster
    myevent.target = target
    myevent.buff = "modifier_mythic_minusres_"..playerid
    myevent.ability = ability
    myevent.dur = 8
    ApplyBuff(myevent)
    target:SetModifierStackCount(myevent.buff, ability, armor)
    print("deal damage")
    print(target)
end

function ArmyDeadTarget(event)
	local caster = event.attacker
	caster.armydeadtarget = event.target
	local target = caster.frostwyrm

	if caster.armydeadskeleton == 0 and target and not target:IsNull() and target:IsAlive() then
		local ability = event.ability
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_drow/drow_frost_arrow_explosion.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
		ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
		ParticleManager:SetParticleControlEnt(particle, 2, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
		ParticleManager:SetParticleControlEnt(particle, 3, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        ParticleManager:ReleaseParticleIndex(particle)
	end
end

function IceSkeleton(event)
	local caster = event.caster
	caster.armydeadskeleton = 1
end

function ShadowCreeperTargetSet(event)
	local caster = event.caster
	caster.creepertarget = event.target
end

function BloodWormTargetSet(event)
	local caster = event.caster
	caster.wormtarget = event.target
end

function BloodWormTargetSet2(event)
	event.target.wormtarget = event.caster.wormtarget
    OnSummonedUnit(event.target, event.caster)
end

function WormTargetAttack(event)
	local caster = event.caster
	local target = event.target

    if target.wormtarget and target.wormtarget:IsNull() then
        return
    end
	
	local order = 
	{
		UnitIndex = target:entindex(),
		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
		TargetIndex = target.wormtarget:entindex()
	}
	ExecuteOrderFromTable(order)
end

function DancingRune(event)
	local caster = event.caster
	local target = event.target

	if not event.justorder then
		caster.DancingRune = target
		target.owner = caster
	end

    if caster.creepertarget and caster.creepertarget:IsNull() then
        return
    end
	
	local order = 
	{
		UnitIndex = target:entindex(),
		OrderType = DOTA_UNIT_ORDER_MOVE_TO_TARGET,
		TargetIndex = caster.creepertarget:entindex()
	}
    Timers:CreateTimer(0.1, function()
	   ExecuteOrderFromTable(order)
    end)
end

function AddCrowTornadoParticle( event)
    local dummy = event.target
    local dummyModifier = dummy:FindModifierByName("modifier_poolfx")

    if(dummyModifier == nil) then
        return
    end

    local particle = ParticleManager:CreateParticle("particles/econ/items/invoker/invoker_ti6/invoker_tornado_ti6_funnel.vpcf", PATTACH_ABSORIGIN_FOLLOW, dummy)
    ParticleManager:SetParticleControlEnt(particle, 3, dummy, PATTACH_ABSORIGIN_FOLLOW , "attach_hitloc", dummy:GetAbsOrigin(), true)
    dummyModifier:AddParticle(particle, false, false, 1, false, false)
end

function AddPathOfFlamesRingParticle( event)
    local dummy = event.target
    local dummyModifier = dummy:FindModifierByName("modifier_poolfx")

    if(dummyModifier == nil) then
        return
    end

    local particle = ParticleManager:CreateParticle("particles/econ/items/legion/legion_weapon_voth_domosh/legion_duel_start_ring_rope_arcana.vpcf", PATTACH_ABSORIGIN, dummy)
    ParticleManager:SetParticleControlEnt(particle, 7, dummy, PATTACH_ABSORIGIN , "attach_hitloc", dummy:GetAbsOrigin(), true)
    dummyModifier:AddParticle(particle, false, false, 1, false, false)
end

function DancingRuneAADamage( event )
    local caster = event.caster
    local target = event.target
    local damage_table = {}
    damage_table.victim = target
    damage_table.attacker = caster
    damage_table.ability = event.ability
    damage_table.damage_type = 1
    damage_table.damage = event.dmg * 0.5
    damage_table.fromsummon = 1
    Timers:CreateTimer(0.25, function()
        ApplyDamage(damage_table)
        DancingRuneDamageFX(caster, target)
    end)
end

function DancingRuneDamageFX(caster, target)	
	if caster and caster.DancingRune and target and not target:IsNull() then
		caster = caster.DancingRune
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ogre_magi/ogre_magi_bloodlust_buff_circle.vpcf", PATTACH_POINT_FOLLOW, caster)
        particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 4, target:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:SetParticleControl(particle, 5, caster:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:ReleaseParticleIndex(particle)
	end
end

function HitFX( caster, target )
    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, caster)
    ParticleManager:SetParticleControl(particle, 4, target:GetAbsOrigin()+Vector(0,0,75))
    ParticleManager:SetParticleControl(particle, 5, caster:GetAbsOrigin()+Vector(0,0,75))
    ParticleManager:ReleaseParticleIndex(particle)
end

function BloodHitFX(event)
	local caster = event.caster
	local target = event.unit
    if not target then
        target = event.target
    end
    if not caster or caster:IsNull() then
        return
    end
    if not target or target:IsNull() then
        return
    end
	local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_bloodspray_src.vpcf", PATTACH_POINT_FOLLOW, caster)
	ParticleManager:SetParticleControl(particle, 4, target:GetAbsOrigin()+Vector(0,0,75))
	ParticleManager:SetParticleControl(particle, 5, caster:GetAbsOrigin()+Vector(0,0,75))
    ParticleManager:ReleaseParticleIndex(particle)
end

function TrapGrizzlyBear(event)
	local caster = event.caster
	local ability = event.ability
	if caster:HasModifier("modifier_item_beastmaster") or caster:HasModifier("modifier_item_beastmaster2") then
		ability:ApplyDataDrivenModifier(caster, event.target, "grizzly_summon_trap", nil)
	end
end

function BeastmasterWolfSummon(event)
	local caster = event.attacker
	local ability = event.ability
	local heroName = caster:GetUnitName()
	if heroName == "npc_dota_hero_drow_ranger" then
		ability:ApplyDataDrivenModifier(caster, event.target, "wolf_summon_proc", nil)
	end
end

function GhostWolfSummon(event)
	local caster = event.caster
	if not (caster:HasModifier("modifier_item_beastmaster") or caster:HasModifier("modifier_item_beastmaster2")) then
 		return
	end
	local ability = event.ability
	ability:ApplyDataDrivenModifier(caster, caster, "ghostwolf_summon", nil)
end

function AshbringerProc(event)
	local caster = event.caster
    if caster.ashbringerCD then
        return
    end
    caster.ashbringerCD = true
	local target = event.unit
    local dist = (caster:GetAbsOrigin() - target:GetAbsOrigin()):Length()
    local buff = "modifier_innercd_ashbringer"
    local count = 1
    if event.version then
        buff = buff..tostring(event.version)
        if event.version == 4 then
            count = 3
        end
    end
	if caster:HasModifier(buff) or dist >= 2500 or caster:HasModifier("modifier_invisible") then
 		return
	end
	local ability = event.ability
    for i=1, count do
        Timers:CreateTimer(0.05+i*0.3, function()
	       ability:ApplyDataDrivenModifier(caster, target, "modifier_item_fireball_proc", nil)
        end)
    end
    if caster:HasModifier("modifier_active6_self") and math.random(1,100) <= 20 then
        Timers:CreateTimer(0.25, function()
            ability:ApplyDataDrivenModifier(caster, target, "modifier_item_fireball_proc", nil)
        end)
    end
	Timers:CreateTimer(0.05, function()
	    ability:ApplyDataDrivenModifier(caster, caster, buff, nil)
	end)
    local innerCDFactor = 1
    if event.innerCooldown then
        innerCDFactor = event.innerCooldown
    end
    Timers:CreateTimer(innerCDFactor * GetInnerCooldownFactor(caster), function()
        caster.ashbringerCD = false
    end)
end

function ItemBuffApply(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if event.ondealdamage then
        target = event.unit
    end
    local dist = (caster:GetAbsOrigin() - target:GetAbsOrigin()):Length()
    if dist >= 2500 then
        return
    end
    if event.blastercd then
        if caster:HasModifier("modifier_blaster_cd") or caster:HasModifier("modifier_invisible") then
            return
        else
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_blaster_cd", {Duration = event.blastercd * GetInnerCooldownFactor(caster)})
        end
    end
    if event.daggercd then
        if caster:HasModifier("modifier_dagger_cd") or caster:HasModifier("modifier_invisible") then
            return
        else
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_dagger_cd", {Duration = 0.1 * GetInnerCooldownFactor(caster)})
        end
    end
    ability:ApplyDataDrivenModifier(caster, target, event.buff, nil)
end

function FaceTarget(event)
	local vec = event.caster:GetAbsOrigin()-event.target:GetAbsOrigin()
	--event.target:SetForwardVector(vec:Normalized())
	--event.target:
	local target = event.target
	local caster = event.caster

	particle = ParticleManager:CreateParticle("particles/frost_breath.vpcf", PATTACH_POINT_FOLLOW, target)
	ParticleManager:SetParticleControl(particle, 1, vec)
    ParticleManager:ReleaseParticleIndex(particle)
	--[[
	local order = 
	{
		UnitIndex = target:entindex(),
		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
		TargetIndex = caster:entindex()
	}
	ExecuteOrderFromTable(order)
	
	Timers:CreateTimer(0.11, function()
	    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_queenofpain/queen_sonic_wave_streak.vpcf", PATTACH_POINT_FOLLOW, target)
	    particle = ParticleManager:CreateParticle("particles/econ/courier/courier_wyvern_hatchling/courier_wyvern_anim_icebreath.vpcf", PATTACH_POINT_FOLLOW, target)
	    ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	    target:Stop()
	end)
	
	--ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	--ParticleManager:SetParticleControlEnt(particle, 1, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
	--ParticleManager:SetParticleControl(particle, 2, Vector(800,0,0))
	]]
end

function LookAtTarget(event)
    local caster = event.caster
    caster:SetForwardVector(event.target:GetAbsOrigin() - caster:GetAbsOrigin())
end

function FindNearbyEnemies( caster, pos, radius )
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, radius, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    return enemies
end

function FindNearbyAllies( caster, pos, radius )
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, radius, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
    return enemies
end

function FindClosestEnemy( event )
    local caster = event.caster
    local pos = caster:GetAbsOrigin()
    local radius = event.radius
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, radius, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    local distance = radius
    local closesttarget = nil
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy and not enemy:IsNull() and enemy:IsAlive() and (enemy:HasModifier("modifier_pvebosssystem") or enemy:HasModifier("dummy_unit_tutorial")) then
                local tempdistance = (enemy:GetAbsOrigin()-pos):Length()
                if tempdistance < distance then
                    closesttarget = enemy
                    distance = tempdistance
                end
            end
        end
    end
    return closesttarget
end

function FindClosestAlly( caster, pos, radius, includeSelf )
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, radius, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
    local distance = radius
    local closesttarget = nil
    if #enemies > 0 then
        for _,enemy in pairs(enemies) do
            if enemy and not enemy:IsNull() and enemy:IsAlive() and (includeSelf or enemy ~= caster) then
                local tempdistance = (enemy:GetAbsOrigin()-pos):Length()
                if tempdistance < distance then
                    closesttarget = enemy
                    distance = tempdistance
                end
            end
        end
    end
    return closesttarget
end

function ChainsIce(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability

	caster.icechains1 = target

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), target:GetAbsOrigin(), caster, 400, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	--print("chainlight enemies")
	--print(#enemies)
	local distance = 10000.0
	local closesttarget = nil
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil and enemy ~= target and enemy:GetUnitLabel()=="hero" then

				local tempdistance = (enemy:GetAbsOrigin()-target:GetAbsOrigin()):Length()
				if tempdistance < distance then
					closesttarget = enemy
					distance = tempdistance
				end
			end
		end
	end

	if closesttarget ~= nil then
		caster.icechains2 = closesttarget
		--ability:ApplyDataDrivenModifier(caster, closesttarget, "modifier_frostchains", nil)

		local myevent = {}
		myevent.caster = caster
		myevent.target = closesttarget
		myevent.buff = "modifier_frostchains"
		myevent.ability = ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

        myevent.buff = "modifier_frost_bonus_arctic"
        ApplyBuff(myevent)

		local particle = ParticleManager:CreateParticle("particles/rattletrap_hookshot_self.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
		ParticleManager:SetParticleControlEnt(particle, 1, closesttarget, PATTACH_POINT_FOLLOW, "attach_hitloc", closesttarget:GetAbsOrigin(), true)
		ParticleManager:SetParticleControl(particle, 2, Vector(500,0,0))
		ParticleManager:SetParticleControl(particle, 3, Vector(event.dur,0,0))
        ParticleManager:ReleaseParticleIndex(particle)

		local particle2 = ParticleManager:CreateParticle("particles/rattletrap_hookshot_self.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControlEnt(particle2, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin()+Vector(0,0,50), true)
		ParticleManager:SetParticleControlEnt(particle2, 1, closesttarget, PATTACH_POINT_FOLLOW, "attach_hitloc", closesttarget:GetAbsOrigin()+Vector(0,0,50), true)
		ParticleManager:SetParticleControl(particle2, 2, Vector(500,0,0))
		ParticleManager:SetParticleControl(particle2, 3, Vector(event.dur,0,0))
        ParticleManager:ReleaseParticleIndex(particle2)

		caster.chainsiceparticle = particle
		caster.chainsiceparticle2 = particle2

		EmitSoundOn("Hero_Rattletrap.Hookshot.Fire", target)
	else
		caster.icechains2 = nil
		caster.icechains1 = nil
	end
end

function ChainsIceDistance(event)
	local caster = event.caster
	local target1 = caster.icechains1
	local target2 = caster.icechains2

	if target1 ~= nil and not target1:IsNull() and target2 ~= nil and not target2:IsNull() then
		local distance = (target1:GetAbsOrigin()-target2:GetAbsOrigin()):Length()
		if distance > 600.0 then
			local tab = {}
			tab.Duration = event.dur
			--event.ability:ApplyDataDrivenModifier(caster, target1, "modifier_stunned", tab)
			--event.ability:ApplyDataDrivenModifier(caster, target2, "modifier_stunned", tab)

			local myevent = {}
			myevent.caster = caster
			myevent.target = target1
			myevent.buff = "modifier_stunned"
			myevent.ability = event.ability
			myevent.dur = event.dur
			ApplyBuff(myevent)

			local myevent = {}
			myevent.caster = caster
			myevent.target = target2
			myevent.buff = "modifier_stunned"
			myevent.ability = event.ability
			myevent.dur = event.dur
			ApplyBuff(myevent)

			target1:RemoveModifierByName("modifier_frostchains")
			target2:RemoveModifierByName("modifier_frostchains")
			ParticleManager:DestroyParticle(caster.chainsiceparticle,true)
			ParticleManager:DestroyParticle(caster.chainsiceparticle2,true)

			local particle = ParticleManager:CreateParticle("particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_i_cowlofice.vpcf", PATTACH_POINT_FOLLOW, target1)
			ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target1:GetAbsOrigin(), true)
            ParticleManager:ReleaseParticleIndex(particle)
			particle = ParticleManager:CreateParticle("particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_i_cowlofice.vpcf", PATTACH_POINT_FOLLOW, target2)
			ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target2:GetAbsOrigin(), true)
            ParticleManager:ReleaseParticleIndex(particle)

			EmitSoundOn("Hero_Lich.ChainFrostImpact.Hero", target1)
		end
	end
end

function VoodooHex( event )
	local heroName = event.caster:GetUnitName()
	if heroName == "npc_dota_hero_bloodseeker" or heroName == "npc_dota_hero_shadow_shaman" or heroName == "npc_dota_hero_witch_doctor" or heroName == "npc_dota_hero_disruptor" or COverthrowGameMode.junglemode then
		--local tab = {}
		--tab.Duration = event.dur
		--event.ability:ApplyDataDrivenModifier(event.caster, event.target, "modifier_voodoo_datadriven", nil)

		if event.target:GetUnitLabel() == "tower" then
	 		return
		end

		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.target
		myevent.buff = "modifier_voodoo_datadriven"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)
	end
end

function PaladinWrath( event )
	local heroName = event.caster:GetUnitName()
	if heroName == "npc_dota_hero_omniknight" or heroName == "npc_dota_hero_legion_commander" or heroName == "npc_dota_hero_phantom_lancer" or heroName == "npc_dota_hero_chen" or COverthrowGameMode.junglemode then
		--local tab = {}
		--tab.Duration = event.dur
		--event.ability:ApplyDataDrivenModifier(event.caster, event.target, "modifier_activepaladin", nil)

		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.target
		myevent.buff = "modifier_activepaladin"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		local particle = ParticleManager:CreateParticle("particles/chen_holy_persuasion_sparks_holy.vpcf", PATTACH_POINT_FOLLOW, event.target)
		ParticleManager:ReleaseParticleIndex(particle)
	else
		event.ability:EndCooldown()
	end
end

function DruidGloves( event )
	local heroName = event.caster:GetUnitName()
	if heroName == "npc_dota_hero_furion" or heroName == "npc_dota_hero_dazzle" or heroName == "npc_dota_hero_vengefulspirit" or COverthrowGameMode.junglemode then
		--local tab = {}
		--tab.Duration = event.dur
		--event.ability:ApplyDataDrivenModifier(event.caster, event.target, "modifier_activedruid", nil)

		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.target
		myevent.buff = "modifier_activedruid"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)
	end
end

function DHGloves( event )
    local heroName = event.caster:GetUnitName()
    if heroName == "npc_dota_hero_antimage" or COverthrowGameMode.junglemode then
        ApplyBuff(event)
    end
end

function RogueGloves( event )
	local heroName = event.caster:GetUnitName()
	local target = event.target
	if heroName == "npc_dota_hero_riki" or heroName == "npc_dota_hero_phantom_assassin" or heroName == "npc_dota_hero_bounty_hunter" or COverthrowGameMode.junglemode then
		--local tab = {}
		--tab.Duration = event.dur
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_viper/viper_poison_attack_explosion.vpcf", PATTACH_POINT_FOLLOW, event.target)
		--ParticleManager:SetParticleControl(particle, 0, event.target:GetAbsOrigin())
		--ParticleManager:SetParticleControl(particle, 1, event.target:GetAbsOrigin())
		ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
		ParticleManager:SetParticleControlEnt(particle, 3, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        ParticleManager:ReleaseParticleIndex(particle)
		--event.ability:ApplyDataDrivenModifier(event.caster, event.target, "modifier_healdebuff", nil)

		local myevent = {}
		myevent.caster = event.caster
		myevent.target = event.target
		myevent.buff = "modifier_healdebuff"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		event.spelldamagefactor = 0.0
		DamageUnit(event)
	end
end

function HunterGloves( event )
	local heroName = event.caster:GetUnitName()
	if heroName == "npc_dota_hero_drow_ranger" or heroName == "npc_dota_hero_sniper" or heroName == "npc_dota_hero_windrunner" or heroName == "npc_dota_hero_mirana" or COverthrowGameMode.junglemode then
		--local tab = {}
		--tab.Duration = event.dur
		event.ability:ApplyDataDrivenModifier(event.caster, event.caster, "modifier_activehunter", nil)

	end
end

function RemoveAllPolymorphs( event )
	local target = event.target
	target:RemoveModifierByName("modifier_voodoo_datadriven")
end

function PriestGloves( event )
	local heroName = event.caster:GetUnitName()
	if heroName == "npc_dota_hero_silencer" or heroName == "npc_dota_hero_dark_seer" or heroName == "npc_dota_hero_oracle" or COverthrowGameMode.junglemode then
		--local tab = {}
		--tab.Duration = event.dur
		event.ability:ApplyDataDrivenModifier(event.caster, event.caster, "modifier_activepriest", nil)
	end
end

function WarriorGloves( event )
	local caster = event.caster
	local pos = caster:GetAbsOrigin()
	local heroName = event.caster:GetUnitName()
	if heroName == "npc_dota_hero_axe" or heroName == "npc_dota_hero_beastmaster" or heroName == "npc_dota_hero_dragon_knight" or COverthrowGameMode.junglemode then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_activewarriorrage", nil)
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_axe/axe_beserkers_call_owner_b.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
		local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, 900, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
		if #enemies > 0 then
			for _,enemy in pairs(enemies) do
				if enemy ~= nil and (enemy:GetUnitLabel()=="hero") then
					--event.ability:ApplyDataDrivenModifier(caster, enemy, "modifier_activewarrior", nil)

					local myevent = {}
					myevent.caster = caster
					myevent.target = enemy
					myevent.buff = "modifier_activewarrior"
					myevent.ability = event.ability
					myevent.dur = event.dur
					ApplyBuff(myevent)
				end
			end
		end
	end
end

function DKGloves( event )
	if not event.caster.temple_class then
		local ability = event.caster:GetAbilityByIndex(5)
		if ability ~= nil then
			ReduceCooldown({caster = event.caster, amount = event.cd, ability = ability })
		end
	end
end

function DKGlovesApplyBuff( event )
    local heroName = event.caster:GetUnitName()
    if heroName == "npc_dota_hero_skeleton_king" or heroName == "npc_dota_hero_sven" or heroName == "npc_dota_hero_pudge" or heroName == "npc_dota_hero_abaddon" or COverthrowGameMode.junglemode then
        ApplyBuff(event)
    end
end

function DKGlovesDamageUnit( event )
    local heroName = event.caster:GetUnitName()
    if heroName == "npc_dota_hero_skeleton_king" or heroName == "npc_dota_hero_sven" or heroName == "npc_dota_hero_pudge" or heroName == "npc_dota_hero_abaddon" or COverthrowGameMode.junglemode then
        DamageUnit(event)
    end
end

function MageGloves( event )
	local caster = event.caster
	local heroName = event.caster:GetUnitName()
	if true or heroName == "npc_dota_hero_lina" or heroName == "npc_dota_hero_crystal_maiden" or heroName == "npc_dota_hero_invoker" or COverthrowGameMode.junglemode then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_activemage", nil)
		local particle = ParticleManager:CreateParticle("particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_i_cowlofice.vpcf", PATTACH_POINT_FOLLOW, caster)
		ParticleManager:SetParticleControlEnt(particle, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
        ParticleManager:ReleaseParticleIndex(particle)
	end
end

function MageGloves2( event )
	local caster = event.caster
	local heroName = event.caster:GetUnitName()
	if heroName == "npc_dota_hero_lina" or heroName == "npc_dota_hero_crystal_maiden" or heroName == "npc_dota_hero_invoker" or COverthrowGameMode.junglemode then
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_evocation", nil)
		local particle = ParticleManager:CreateParticle("particles/econ/items/abaddon/abaddon_alliance/abaddon_death_coil_explosion_alliance_sparks.vpcf", PATTACH_POINT_FOLLOW, caster)
		ParticleManager:SetParticleControl(particle, 3, caster:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
		EmitSoundOn("Item.MoonShard.Consume", caster)
	end
end

function ReduceCooldown( event )
	local caster = event.caster
	if event.amount <= 0 then
		return
	end
    local reduction = event.amount
	if event.onauto then
		caster = event.attacker
	end
    if event.abilitynamecondition then
        if GetLevelOfAbility(caster, event.abilitynamecondition) < event.abilitylevelcondition then
            return
        end
    end
    if event.buffcondition and not caster:HasModifier(event.buffcondition) then
        return
    end
    if event.setcastmoon4 and caster:HasModifier("modifier_class_venge") then
         caster.resetaftermoon4 = true
    end
    if event.setcastmoon9 and caster:HasModifier("modifier_class_venge") then
         caster.resetaftermoon9 = true
         return
    end
    if event.resetaftermoon4 then
        if caster.resetaftermoon4 then
            caster.resetaftermoon4 = false
        else
            return
        end
    end
    if event.resetaftermoon9 then
        if caster.resetaftermoon9 then
            caster.resetaftermoon9 = false
        else
            return
        end
    end
    local roll = math.random(1,100)
    if event.chance_to_reduce_cd and roll <= (100 - event.chance_to_reduce_cd) then
        return
    end
	if caster ~= nil then
		local ability = event.ability
        if event.ability_index_condition and caster:GetAbilityByIndex(event.ability_index_condition) ~= ability then
            return
        end
        if event.chooseability then
            ability = caster:GetAbilityByIndex(event.chooseability)
        end
        if event.chooseabilityname then
            ability = caster:FindAbilityByName(event.chooseabilityname)
        end
        if ability and event.exclude_ability and ability:GetName() == event.exclude_ability then
            return
        end
		if ability ~= nil then
            if event.onself and event.caster ~= event.target then
                return
            end
 			local cd = ability:GetCooldownTimeRemaining()
            if event.cdreduceminthreshold and (cd - reduction) < event.cdreduceminthreshold then --we are below the min threshold
                reduction = cd - event.cdreduceminthreshold
            end
 			if cd > 0.1 then
                if event.conditionRemainingCD and cd < event.conditionRemainingCD then
                    return
                end
                if not event.delaycdreduce then
                    Timers:CreateTimer(0.1, function()
                        cd = ability:GetCooldownTimeRemaining()
                        if cd > cd - reduction and cd > 0.1 then
 			                ability:EndCooldown()
                            ability:StartCooldown(cd - reduction)
                        end
                    end)
                else
                    Timers:CreateTimer(event.delaycdreduce, function()
                        cd = ability:GetCooldownTimeRemaining()
                        if cd > cd - reduction and cd > 0.1 then
                            ability:EndCooldown()
                            ability:StartCooldown(cd - reduction)
                        end
                    end)
                end
 			end
		end
	end
end

function StartCooldownPVE( event )
	event.ability:EndCooldown()
	event.ability:StartCooldown(event.ability:GetCooldown(1))
end

function WarlockGloves( event )
	local caster = event.caster
	local heroName = caster:GetUnitName()

	if heroName == "npc_dota_hero_warlock" or COverthrowGameMode.junglemode then
		--caster.originalcastpoint = 2.0
		--caster.originalcastpointabil = 4
		--caster:GetAbilityByIndex(4):SetOverrideCastPoint(0.2)
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_activewarlock", nil)
	end

	if heroName == "npc_dota_hero_pugna" then
		--caster.originalcastpoint = 2.0
		--caster.originalcastpointabil = 0
		--caster:GetAbilityByIndex(0):SetOverrideCastPoint(0.2)
		event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_activewarlock", nil)
	end
end

--[[function ResetCastpoint( event )
	local caster = event.caster
	caster:GetAbilityByIndex(caster.originalcastpointabil):SetOverrideCastPoint(caster.originalcastpoint)
end]]

function DemonWall( event )
	local target = event.caster
	local ability = event.ability
	if target:HasModifier("modifier_item_shield3up_buff") then
		local stackcount = target:GetModifierStackCount("modifier_item_shield3up_buff", target)+1
		if stackcount > 25 then
			stackcount = 25
		end
		--target:RemoveModifierByName("modifier_item_shield3up_buff")
		ability:ApplyDataDrivenModifier(target, target, "modifier_item_shield3up_buff", nil)
		target:SetModifierStackCount("modifier_item_shield3up_buff", ability, stackcount)
		--target:Duration
	else
		ability:ApplyDataDrivenModifier(target, target, "modifier_item_shield3up_buff", nil)
		target:SetModifierStackCount("modifier_item_shield3up_buff", ability, 1)
	end
end

function FlameFury( event )
	local target = event.caster
	local ability = target.combat_system_ability
	if not ability then
		return
	end
	if target:HasModifier("modifier_item_flamefury_buff") then
		local stackcount = target:GetModifierStackCount("modifier_item_flamefury_buff", target)+1
		if stackcount > 10 then
			stackcount = 10
		end
		--target:RemoveModifierByName("modifier_item_shield3up_buff")
		ability:ApplyDataDrivenModifier(target, target, "modifier_item_flamefury_buff", nil)
		target:SetModifierStackCount("modifier_item_flamefury_buff", ability, stackcount)
		--target:Duration
	else
		ability:ApplyDataDrivenModifier(target, target, "modifier_item_flamefury_buff", nil)
		target:SetModifierStackCount("modifier_item_flamefury_buff", ability, 1)
	end
end

function MythicAACrit( event )
    local target = event.attacker
    local ability = event.ability
    local stackcount = target:GetModifierStackCount("modifier_mythic_aacrit", nil)
    if math.random(1,100) <= stackcount then
        ability:ApplyDataDrivenModifier(target, target, "crit6", nil)
    end
end

function TalentAACrit( event )
    local target = event.attacker
    local ability = event.ability
    local stackcount = target:GetModifierStackCount("modifier_talent_crit", nil) * 2
    if math.random(1,100) <= stackcount then
        ability:ApplyDataDrivenModifier(target, target, "crit7", nil)
    end
end

function Sharpeye( event )
	local target = event.attacker
	local ability = event.ability
	if target:HasModifier("modifier_item_sharpeye_buff") then
		local stackcount = target:GetModifierStackCount("modifier_item_sharpeye_buff", target)+1
		if stackcount > 50 then
			stackcount = 50
		end
		--target:RemoveModifierByName("modifier_item_shield3up_buff")
		ability:ApplyDataDrivenModifier(target, target, "modifier_item_sharpeye_buff", nil)
		target:SetModifierStackCount("modifier_item_sharpeye_buff", ability, stackcount)
		--target:Duration
	else
		ability:ApplyDataDrivenModifier(target, target, "modifier_item_sharpeye_buff", nil)
		target:SetModifierStackCount("modifier_item_sharpeye_buff", ability, 1)
	end
end

function Disarm( event )
	local target = event.target
	local caster = event.caster
	local name = target:GetName()
	if not target:IsRangedAttacker() or name == "npc_dota_hero_drow_ranger" or name == "npc_dota_hero_sniper" or name == "npc_dota_hero_windrunner" or name == "npc_dota_hero_mirana" then
		--stop on dazzle
		if name == "npc_dota_hero_dazzle" and not target:HasModifier("modifier_catform") then
			return
		end
		local tab = {}
		tab.Duration = event.dur
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_heavens_halberd_debuff", tab)
		--event.ability:ApplyDataDrivenModifier(caster, target, "modifier_silence", tab)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_heavens_halberd_debuff"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_silence"
		myevent.ability = event.ability
		myevent.dur = event.dur
		ApplyBuff(myevent)
	end
end

function SetBuffStack( event )
    local caster = event.caster
    local amount = 1
    local buff = event.buff
    local ability = event.ability
    if event.addstacks then
        amount = event.addstacks
    end
    local stackcount = caster:GetModifierStackCount(buff, nil)+amount
    caster:SetModifierStackCount(buff, ability, stackcount)
end

function ApplyBuffStack( event )
	local target = event.attacker
	local amount = 1
    local isBuff = true
	if event.notself then
		target = event.target
	end
    if event.ondealdamagetarget then
        target = event.unit
    end
	if event.self then
		target = event.caster
	end
	local caster = event.caster
	if target == nil then
		target = event.target
		--print("1")
		--print(target:GetUnitName())
	end
	if target == nil then
		target = event.caster
		--print("2")
	end
    if event.changecastertotarget then
        caster = target
    end
	if target == nil then
		return 0
	end
	if caster == nil then
		return 0
	end
	if not caster:IsAlive() then
    	if not event.whiledead then
        	return
        end
        if caster:IsNull() then
        	return
        end
    end
    if caster and target and caster:GetTeamNumber() ~= target:GetTeamNumber() then
        isBuff = false
    end
	if event.addstacks then
		amount = event.addstacks
	end
    if event.classitemaddstackfactor and caster:HasModifier(event.classitemstackfactorbuff) then
        amount = amount * event.classitemaddstackfactor
    end
	if event.resetplague then
		target:RemoveModifierByName("modifier_slowstack10")
	end
    if event.only_when_damaged and target:GetHealth() / target:GetMaxHealth() >= 1.0 then
        return 0
    end
	local buff = event.buff
    if caster:HasModifier("modifier_class_venge2") and (buff == "modifier_mooncharge" or buff == "modifier_suncharge") then
        amount = 5
    end
	local max = event.max
    if event.classitemmaxstackfactor and caster:HasModifier(event.classitemstackfactorbuff) then
        max = max * event.classitemmaxstackfactor
    end
    local extraStacks = GetMaxDebuffStackBonus(caster)
    if max and extraStacks >= 1 and not isBuff then
        max = max + extraStacks
    end
    extraStacks = GetMaxBuffStackBonus(caster)
    if max and extraStacks >= 1 and isBuff then
        max = max + extraStacks
    end
    if max and GetAlchemistStat(caster) >= 1 and not isBuff then
        max = math.floor(max * (1 + 0.01 * GetAlchemistStat(caster)))
    end
	local ability = event.ability
	if event.threshold and target:GetModifierStackCount(buff, nil) >= event.threshold then
		return
	end
	if target:HasModifier(buff) then
		local stackcount = target:GetModifierStackCount(buff, nil)+amount
        if event.setstackcount then
            stackcount = amount
        end
        if event.setstacks then
            stackcount = event.setstacks
        end
		if max and stackcount > max then
			stackcount = max
		end
        if stackcount < 0 then
            stackcount = 0
        end

        --pve tank stacks
        if event.pveonstacklimit and stackcount == max then
            event.ability:ApplyDataDrivenModifier(caster, target, "modifier_piercearmor", {Duration = 8})
        end
		--target:RemoveModifierByName("modifier_item_shield3up_buff")
		--ability:ApplyDataDrivenModifier(caster, target, buff, nil)
		event.caster = caster
		event.target = target
		event.buff = buff
        if event.alwaysapply then
            event.ability:ApplyDataDrivenModifier(event.caster, event.target, event.buff, {Duration = event.dur})
        else
		    ApplyBuff(event)
        end
		target:SetModifierStackCount(buff, ability, stackcount)
		--target:Duration
        amount = stackcount
	else
		--print("run")
		--ability:ApplyDataDrivenModifier(caster, target, buff, nil)
		event.caster = caster
		event.target = target
		event.buff = buff
		if event.alwaysapply then
            event.ability:ApplyDataDrivenModifier(event.caster, event.target, event.buff, {Duration = event.dur})
        else
            ApplyBuff(event)
        end
		target:SetModifierStackCount(buff, ability, amount)
	end
    if event.grow_based_on_stacks then
        if not caster.baseModelScale then
            caster.baseModelScale = caster:GetModelScale()
        end
        local base_scale = caster.baseModelScale --1 --caster:GetModelScale() / ((amount-1) * event.grow_based_on_stacks + 1)
        local factor = 1 + amount * event.grow_based_on_stacks
        if factor > 1.9 then
            factor = 1.9
        end
        caster:SetModelScale(base_scale * factor)
    end
    return amount
end

function StrikeOfVengeance( event )
    local caster = event.caster
    local dmg = event.dmg
    if dmg > 0 and event.on and event.on == 1 then
        if caster.lastdamagetaken and caster.lastdamagetaken > dmg then
            return
        end
        local buff = "modifier_strikeofvengeance"
        local ability = event.ability
        caster:RemoveModifierByName(buff)
        ability:ApplyDataDrivenModifier(caster, caster, buff, {Duration = -1})
        caster:SetModifierStackCount(buff, ability, dmg)
        caster.lastdamagetaken = dmg
    end
end

function StrikeOfVengeance2( event )
    local caster = event.caster
    --local dmg = event.dmg
    if event.on and event.on == 1 then
        event.buff = "modifier_strikeofvengeance2"
        event.dur = 20
        event.target = caster
        event.max = 10
        event.self = true
        ApplyBuffStack(event)

        --ability:ApplyDataDrivenModifier(caster, caster, buff, {Duration = -1})
        --caster:SetModifierStackCount(buff, ability, dmg)
        --caster.lastdamagetaken = dmg
    end
end

function SanctifiedCrusaderRetaliation( event )
    event.target:AddNewModifier(event.caster, event.ability, "modifier_godschosen_2", {duration = event.Duration})
end

function StrikeOfVengeance3( event )
    local caster = event.caster
    --local dmg = event.dmg
    if event.on and event.on == 1 then
        event.buff = "modifier_strikeofvengeance3"
        event.dur = 8
        event.target = caster
        event.max = 25
        event.self = true
        ApplyBuffStack(event)
    end
end

function RotApplyBuff( event )
	if not event.target:HasModifier("modifier_rotdk") then
		ApplyBuff(event)
	end
end

function ExorApplyBuff( event )
	if not event.target:HasModifier("modifier_sap") then
		ApplyBuff(event)
	end
end

function DecreaseBuffStack( event )
	local target = event.target
	local amount = 1
	if event.notself then
		target = event.target
	end
	if event.self then
		target = event.caster
	end
	local caster = event.caster
	if target == nil then
		target = event.attacker
	end
	if target == nil then
		target = event.caster
	end
	if target == nil then
		return
	end
	if caster == nil then
		return
	end
	if event.amount then
		amount = event.amount
	end
    if event.only_when_damaged and target:GetHealth() / target:GetMaxHealth() >= 1.0 then
        return
    end
	local buff = event.buff
	local ability = event.ability
    local stackcount = target:GetModifierStackCount(buff, nil)
    local new_stackcount = stackcount-amount
	if target:HasModifier(buff) then
		if stackcount > 1 then
			target:SetModifierStackCount(buff, ability, new_stackcount)
		else
			target:RemoveModifierByName(buff)
		end
	end
    if event.grow_based_on_stacks then
        local base_scale = 1 --caster:GetModelScale() / ((amount-1) * event.grow_based_on_stacks + 1)
        local factor = 1 + stackcount * event.grow_based_on_stacks
        if factor > 1.9 then
            factor = 1.9
        end
        caster:SetModelScale(base_scale * factor)
    end
end

function WingsOfHell( event )
	local caster = event.attacker
	local target = event.unit
	local ability = event.ability

	local myevent = {}
	myevent.caster = caster
	myevent.target = target
	myevent.buff = "modifier_active6"
	myevent.ability = ability
	myevent.dur = event.dur
	ApplyBuff(myevent)

	if caster:HasModifier("modifier_active6_self") then
		--print(ability:GetName())
		--ability:ApplyDataDrivenModifier(caster, target, "modifier_active6_2", nil)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_active6_2"
		myevent.ability = ability
		myevent.dur = event.dur
		ApplyBuff(myevent)
	end
end

function KnockbackAOE(event)
	local caster = event.caster
	local ability = event.ability
	local range = event.range
	local amount = event.amount
	local pos
	if event.target_points ~= nil then
		pos = event.target_points[1]
	else
		return
	end

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	--print(#enemies)
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) then

					event.target = enemy
					event.fixedforce = 400
					KnockBack(event)

					Timers:CreateTimer(5.0, function()
						local table = {}
						table.Duration = 0.02
					   	event.ability:ApplyDataDrivenModifier(enemy, enemy, "modifier_phased", table)
					end)
				end
			end
		end
	end
end

function DPSCounter( event )
	local caster = event.attacker
    local target = event.unit
	--print(event.damage)
	if event.hero ~= nil then
		if caster.damagedone then
			caster.damagedone = caster.damagedone + event.damage
		else
			caster.damagedone = event.damage
		end
	end
	if event.pet ~= nil and caster.owner then
		if caster.owner.damagedone then
			caster.owner.damagedone = caster.owner.damagedone + event.damage
			--print(event.damage)
		else
			caster.owner.damagedone = event.damage
		end
	end
    --set current target for dps meter
    local thrash_too = true
    if thrash_too or target.isboss or (target.rewardchance and target.rewardchance >= 100) then
        caster.current_boss_target = event.unit
    end
end

function ArenaStats( event )
	local caster = event.caster.controlowner
	if COverthrowGameMode.GameState ~= 2 then
		if caster then

			if caster.hpsthisturn then
				CriticalStrikeFX(nil, caster, caster.hpsthisturn, 0, 0)
			end
			if caster.dpsthisturn then
				CriticalStrikeFX(nil, caster, caster.dpsthisturn, 1, 0)
			end
			Timers:CreateTimer(1.5, function()
				if caster.hpsthisturn then
				CriticalStrikeFX(nil, caster, caster.hpsthisturn, 0, 0)
				end
				if caster.dpsthisturn then
					CriticalStrikeFX(nil, caster, caster.dpsthisturn, 1, 0)
				end
			end)
			Timers:CreateTimer(3.0, function()
				if caster.hpsthisturn then
				CriticalStrikeFX(nil, caster, caster.hpsthisturn, 0, 0)
				end
				if caster.dpsthisturn then
					CriticalStrikeFX(nil, caster, caster.dpsthisturn, 1, 0)
				end
			end)
		end
	end
end

function ItemElemental( event )
	local caster = event.caster
	local ability = event.ability
	if caster then
		caster.itemelemental = ability
	end
end

function WardKillAttackCounter( event )
	local caster = event.unit
	local target = event.attacker
	if caster.attackstokill and target then
		caster.attackstokill = caster.attackstokill - 1
		if caster.attackstokill <= 0 then
			EndAnimation(caster)
			StartAnimation(caster, {activity=ACT_DOTA_DIE, duration=2.0, rate=0.3})
			caster:Kill(event.ability, target)
		else
			caster:SetHealth(caster:GetMaxHealth()/2)
		end
	end
end

function WardKillAttackCounterSet( event )
	local target = event.target
	target.attackstokill = event.amount
end

function Boss1Add( event )
	local caster = event.caster
	local pos = caster:GetAbsOrigin() + Vector(150,0,0)
	local boss = CreateUnitByName("npc_dota_creature_pveboss1_add1", pos, true, nil, nil, DOTA_TEAM_BADGUYS )

	caster.PVEAdd1 = boss
	local particle = ParticleManager:CreateParticle("particles/items2_fx/shadow_amulet_activate_end_flash.vpcf", PATTACH_ABSORIGIN_FOLLOW, boss)
    ParticleManager:ReleaseParticleIndex(particle)
end

function ChampionUnholy(event)
	local caster = event.attacker.owner
	if caster and caster.championunholy then
		--local ability = caster:GetAbilityByIndex(1)
		--ability:EndCooldown()
        local amount = 25
        if event.amount then
            amount = event.amount
        end
		local myevent = {}
        myevent.caster = caster
        myevent.energy = amount * caster.championunholy
        AddEnergy(myevent)
	end
end

function MasterEnergyRestore(event)
    local caster = event.attacker.owner
    if caster then
        local amount = event.amount
        local myevent = {}
        myevent.caster = caster
        myevent.energy = amount
        AddEnergy(myevent)
    end
end

function SetPetStuff(event)
	local caster = event.caster
	local unit = event.target
    if not event.dontsetaspet then
    	if event.nr and event.nr == 2 then
    		caster.Pet2 = unit
    	else
    		caster.Pet = unit
    	end
    end
	unit:SetHullRadius(35)
	unit.owner = caster

	--agha
    caster.championunholy = 0
	if caster:HasModifier("modifier_item_straxe2") then
		caster.championunholy = 1
	end
	if caster:HasModifier("modifier_item_straxe3") then
        caster.championunholy = caster.championunholy + 1
    end

	if event.levelup then
		unit:CreatureLevelUp(event.ability:GetLevel()-1)
	end

	if event.setaa then
        local bonus = 1.0
        if event.talentscale and caster.talents and caster.talents[event.talentscale] then
            bonus = caster.talents[event.talentscale]
        end
        if event.runewordscale and event.runewordscale == 11 and caster.runeword and caster.runeword[event.runewordscale] then
            bonus = bonus + caster.runeword[event.runewordscale]
        end
		unit:SetBaseDamageMin(math.floor(bonus*event.caster:GetAttackDamage()*event.setaa/100.0))
		unit:SetBaseDamageMax(math.floor(bonus*event.caster:GetAttackDamage()*event.setaa/100.0))
	end
    if event.immortaldmg then
        unit:SetBaseDamageMin(event.immortaldmg)
        unit:SetBaseDamageMax(event.immortaldmg)
        unit:SetModelScale(0.7)
    end
    if event.immortalbear and caster:HasModifier("modifier_item_beastmaster2") then
        unit:SetBaseDamageMin(5000)
        unit:SetBaseDamageMax(5000)
        unit:SetModelScale(0.9)
    end
    if event.currenthp then
        local health = caster:GetHealth() * event.currenthp / 100
        unit:SetBaseMaxHealth(health)
        unit:SetMaxHealth(health)                           
        unit:SetHealth(health)
    end
	local dmg2
	if event.setaa_int then
		dmg2 = math.floor((GetIntellectCustom(event.caster)*event.setaa_int/100))
		unit:SetBaseDamageMin(dmg2)
		unit:SetBaseDamageMax(dmg2)
	end
	if event.setaa_sp then
		local sp = GetSpellpower(event)
		unit:SetBaseDamageMin(dmg2+math.floor(sp*event.setaa_sp/100))
		unit:SetBaseDamageMax(dmg2+math.floor(sp*event.setaa_sp/100))
	end
	if event.phased then
		local tab = {}
		tab.Duration = 20
		event.ability:ApplyDataDrivenModifier(caster, unit, "modifier_phased", tab)
	end

    if event.beastmasterghostwolf then
        local dmg = caster:GetAttackDamage() * event.setghostdmg / 100
        if caster:HasModifier("modifier_item_beastmaster") then
            dmg = dmg + GetStrengthCustom(event.caster) * 0.1
        end
        if caster:HasModifier("modifier_item_beastmaster2") then
            dmg = dmg + GetStrengthCustom(event.caster) * 10
            unit:SetModelScale(0.45)
        end
        unit:SetBaseDamageMin(math.floor(dmg))
        unit:SetBaseDamageMax(math.floor(dmg))
        local tab = {}
        tab.Duration = 60.0
        event.ability:ApplyDataDrivenModifier(caster, unit, "modifier_phased", tab)
    end
    if not unit.on_summoned_procced then
        OnSummonedUnit(unit, caster)
        unit.on_summoned_procced = true
    end
    if caster and caster.talents and caster.talents[69] and caster.talents[69] > 0 and not unit.path_heal_on_summon_done then
        CruelTaskmasterHeal(caster, event.ability, unit)
        --local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_vengeful/vengeful_wave_of_terror_recipient.vpcf", PATTACH_POINT_FOLLOW, caster)
        --ParticleManager:ReleaseParticleIndex(particle)
        if caster.path_demonic_pact then
            caster.path_demonic_pact = caster.path_demonic_pact + 1
        else
            caster.path_demonic_pact = 1
        end
        Timers:CreateTimer(15,function()
            caster.path_demonic_pact = caster.path_demonic_pact - 1
        end)
    end

    if event.gargoyle and caster.cosmeti_pudge_pet then
        unit:SetOriginalModel("models/items/visage/bound_of_the_soul_keeper_familiar/bound_of_the_soul_keeper_familiar.vmdl")
    end

	if caster.creepertarget and not caster.creepertarget:IsNull() and unit and not unit:IsNull() then
        --print(caster.creepertarget:GetName())
		Timers:CreateTimer(0.1, function()
            --print(caster.creepertarget:GetName())
			local order = 
			{
				UnitIndex = unit:entindex(),
				OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
				TargetIndex = caster.creepertarget:entindex()
			}
			ExecuteOrderFromTable(order)
		end)
	end
end

function CruelTaskmasterHeal(caster, ability, summon)
    local myevent = {caster = caster, target = caster, heal = caster:GetMaxHealth() * 0.03 * caster.talents[69], ability = ability}
    HealUnit(myevent)
    summon.path_heal_on_summon_done = true
end

function PetTargetSet(event)
    local caster = event.attacker
    caster.pettarget = event.target
end

function PetTargetOrder(event)
    local caster = event.caster
    local target = event.target
    if caster and target and caster.pettarget and not caster.pettarget:IsNull() and caster.pettarget:IsAlive() then
        local attackTarget = caster.pettarget
        if event.abilityset and caster.firstabilitytarget then
            attackTarget = caster.firstabilitytarget
        end
        local order = 
        {
            UnitIndex = target:entindex(),
            OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
            TargetIndex = attackTarget:entindex()
        }
        ExecuteOrderFromTable(order)
    end
end

function PetFollowOrder(event)
    local caster = event.caster
    local target = event.target
    if caster and target then
        local order = 
        {
            UnitIndex = target:entindex(),
            OrderType = DOTA_UNIT_ORDER_MOVE_TO_POSITION,
            Position = caster:GetAbsOrigin() + RandomVector(100)
        }
        ExecuteOrderFromTable(order)
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_phased", {Duration = 6})
        if (caster:GetAbsOrigin() - target:GetAbsOrigin()):Length() > 1200 then
            target:SetAbsOrigin(caster:GetAbsOrigin())
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_chen/chen_teleport.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
end

function UnholyInsectFX(event)
	local target = event.target
	local particle = ParticleManager:CreateParticle("particles/econ/items/death_prophet/death_prophet_acherontia/death_prophet_acher_swarm_pnt.vpcf", PATTACH_POINT_FOLLOW, target)
	--ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	ParticleManager:SetParticleControl(particle, 1, Vector(1,1,1))
	--ParticleManager:SetParticleControlEnt(particle, 2, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	ParticleManager:SetParticleControlEnt(particle, 3, target, PATTACH_POINT_FOLLOW, "attach_origin", target:GetAbsOrigin(), true)
    ParticleManager:ReleaseParticleIndex(particle)
end

function GhoulJump(event)
	if event.jump > 0 then
		event.caster:SetAbsOrigin(event.target:GetAbsOrigin() - event.target:GetForwardVector()*100)
        local tab = {}
        tab.Duration = 0.05
        event.ability:ApplyDataDrivenModifier(event.caster, event.caster, "modifier_phased", tab)
	end
end

function GhoulTransform(event)
	local caster = event.caster
	local target = caster.GhoulPet
	if target == nil then
		return
	end
	if target:IsNull() then
		return
	end
	if event.transform > 0 then
		local stack = target:GetModifierStackCount("modifier_ghoul_transform", nil)
		if stack >= 4 then
			target:RemoveModifierByName("modifier_ghoul_transform")
            --target:SetOriginalModel("models/heroes/undying/undying_flesh_golem.vmdl")
            local ghoulAbility = caster:FindAbilityByName("unholy_5")
            if ghoulAbility then
                ghoulAbility:ApplyDataDrivenModifier(target, target, "modifier_ghoul_transform_active", nil)
            end
		elseif not target:HasModifier("modifier_ghoul_transform_active") then
			event.caster = caster
			event.target = target
			event.buff = "modifier_ghoul_transform"
			event.max = 5
			ApplyBuffStack(event)
		end
	end
end

function GhoulTransformEnd(event)
    local target = event.target
    --target:SetModel("models/heroes/life_stealer/life_stealer.vmdl")
    --target:SetOriginalModel("models/heroes/life_stealer/life_stealer.vmdl")
end

function RootedProcInnerCD(event)
	local caster = event.caster
	local target = event.target
	if not caster:HasModifier("rooted_proc_innercd") then
		event.ability:ApplyDataDrivenModifier(caster, caster, "rooted_proc_innercd", {Duration = 15 * GetInnerCooldownFactor(caster)})
		ApplyBuff(event)
	end
end

function SilenceShadow(event)
	local caster = event.caster
	local target = event.target

	local myevent = {}
	myevent.caster = caster
	myevent.target = target
	myevent.buff = "modifier_silence"
	myevent.ability = event.ability
	local b = 0
	if target:HasModifier("modifier_fearsp_bonus") then
  		b = event.silence1
	end
	myevent.dur = (event.silence + b)*GetCCPower(event)
	ApplyBuff(myevent)

	if event.ring and event.ring > 0 then
		myevent.buff = "modifier_silence_ring"
		ApplyBuff(myevent)
	end
end

function DamageUnitRange( event )
	local caster = event.caster
	local target = event.target
	local range = event.rangedepend
	local vec = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length()
	if vec < 100.0 then
		vec = 100.0
	end
	if vec > range then
		vec = range
	end
	vec = vec - 100
	local power = vec/(range - 100)
	--local power = 0.25 + 0.75*vec/(range - 100)
	if power > 1.0 then
		power = 1.0
	end
	if power < event.mindmg/100 then
		power = event.mindmg/100
	end

    --print(power)

	event.attributefactor = event.attributefactor*power
	event.spelldamagefactor = event.spelldamagefactor*power
    event.includeauto = event.includeauto*power

	DamageUnit(event)
end

function CDResetChance( event )
	local caster = event.caster
	local ability = event.ability

	if event.chance >= math.random(1,100) then
		ability:EndCooldown()
		local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_windrunner/windrunner_loadout_magic.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
		EmitSoundOn("windrunner_wind_respawn_08", caster)
	end
end

function StunAggroChange(event)
	local caster = event.attacker
	local target = event.target
	local damage_table = {}

	if not target:HasModifier("modifier_hasaggro") then
		damage_table.Duration = 2
		event.ability:ApplyDataDrivenModifier(caster, target, "modifier_stunned", damage_table)
	end
end

function GetKillDanceExtraHits( hero )
    local hits = 0
    if GetLevelOfAbility(hero, "deadly6") >= 4 then
        hits = math.floor(GetStrengthCustom(hero) / 50)
    end
    if GetLevelOfAbility(hero, "combat5") >= 3 then
        hits = math.floor(GetAgilityCustom(hero) / 100)
    end
    if hits > 20 then
        hits = 20
    end
    return hits
end

function KillDance (event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local distance = event.range
    local hits = 12
    local sound = "Hero_BountyHunter.Jinada"
    if event.sound then
        sound = event.sound
    end
    if event.killdancehits then
        hits = event.killdancehits
    end
    local speedFactor = hits / (hits + GetKillDanceExtraHits( caster ))
    hits = hits + GetKillDanceExtraHits( caster )
    event.killdance_hits_done = 1
	local vec1 = RandomVector(75.0)
	local vec = target:GetAbsOrigin() + Vector(vec1[1],vec1[2],0)
	
	caster:SetAbsOrigin(vec)
	caster:SetForwardVector(target:GetAbsOrigin()-caster:GetAbsOrigin())
	EmitSoundOn(sound, target)
	StartAnimation(caster, {activity=ACT_DOTA_ATTACK, duration=0.25, rate=2})
	KillDanceFX(event)
	
    if event.addroguepoison then
    	local myevent = {}
    	myevent.caster = caster
    	myevent.target = target
    	myevent.buff = "modifier_deadlypoison"
    	myevent.max = 25
        if caster:GetAbilityByIndex(2):GetLevel() >= 4 then
            myevent.max = 50
        end
    	myevent.ability = caster:GetAbilityByIndex(2)
    	myevent.dur = 10
    	myevent.notself = 1
    	ApplyBuffStack(myevent)
    end

    local ev = {caster = caster, target = target, ability = event.ability, targetpos = 1, damage = 0, attributefactor = event.attributefactor, includeauto = event.includeauto, aoe = 250, targeteffect = "blood", isaoe = 1 }
    if event.aoedmg and event.aoedmg == 1 then
        DamageAOE(ev)
    else
        DamageUnit(event)
    end

    if event.killdance_crit_extra_hit and event.killdance_crit_extra_hit > 0 then
        if caster.killdance_last_hit_was_crit and math.random(1,100) <= 50 then
            hits = hits + 1
            caster.killdance_last_hit_was_crit = nil
            local particle = ParticleManager:CreateParticle("particles/econ/items/juggernaut/jugg_arcana/juggernaut_arcana_v2_teleport_end_model.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            --EmitSoundOn("juggernaut_jug_attack_13", caster)
        end
    end

	--for i=1,hits do
	Timers:CreateTimer(0.33 * speedFactor,function() 
        KillDanceProc(event, caster, target, distance, hits-1, speedFactor)
    end)
	--end
end

function KillDanceProc (event, caster, target, distance, hits, speedFactor)
    event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_killdance_imunity", {Duration = 2})
	if (not caster:HasModifier("modifier_killdance")) or hits == 0 then
        caster:RemoveModifierByName("modifier_killdance")
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_killdance_imunity", {Duration = 2})
		return
	end
    caster:SetModifierStackCount("modifier_killdance", event.ability, hits)
    local sound = "Hero_BountyHunter.Jinada"
    if event.sound then
        sound = event.sound
    end
	local range = distance

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
	if #enemies > 0 then
		--print
	else
		enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
	end
	if #enemies > 0 then
		local unit = enemies[math.random(1,#enemies)]
		if unit ~= nil then
			event.caster = caster
			event.target = unit
			local vec1 = RandomVector(100.0)
			local vec = unit:GetAbsOrigin() + Vector(vec1[1],vec1[2],0)
			caster:SetAbsOrigin(vec)
			caster:SetForwardVector(unit:GetAbsOrigin()-caster:GetAbsOrigin())
			EmitSoundOn(sound, unit)
			StartAnimation(caster, {activity=ACT_DOTA_ATTACK, duration=0.25, rate=2})
			KillDanceFX(event)

            if event.addroguepoison then
    			local myevent = {}
    			myevent.caster = caster
    			myevent.target = unit
    			myevent.buff = "modifier_deadlypoison"
    			myevent.max = 25
                if caster:GetAbilityByIndex(2):GetLevel() >= 4 then
                    myevent.max = 50
                end
    			myevent.ability = caster:GetAbilityByIndex(2)
    			myevent.dur = 10
    			myevent.notself = 1
    			ApplyBuffStack(myevent)
            end
			
			local ev = {caster = caster, target = target, ability = event.ability, targetpos = 1, damage = 0, attributefactor = event.attributefactor, includeauto = event.includeauto, aoe = 250, targeteffect = "blood", isaoe = 1 }
            if event.aoedmg and event.aoedmg == 1 then
                DamageAOE(ev)
            else
                DamageUnit(event)
            end
            event.killdance_hits_done = event.killdance_hits_done + 1

            if event.killdance_crit_extra_hit and event.killdance_crit_extra_hit > 0 then
                if caster.killdance_last_hit_was_crit and math.random(1,100) <= 50 then
                    hits = hits + 1
                    caster.killdance_last_hit_was_crit = nil
                    local particle = ParticleManager:CreateParticle("particles/econ/items/juggernaut/jugg_arcana/juggernaut_arcana_v2_teleport_end_model.vpcf", PATTACH_POINT_FOLLOW, caster)
                    ParticleManager:ReleaseParticleIndex(particle)
                    --EmitSoundOn("juggernaut_jug_attack_13", caster)
                end
            end
            if event.stun_on_hit_count and event.stun_on_hit_count > 0 and event.killdance_hits_done > 10 then
                ApplyBuff({caster = caster, target = target, ability = event.ability, buff = "modifier_stunned", dur = 3})
            end

			local tab = {}
		 	tab.Duration = 0.05
		 	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", tab)
            Timers:CreateTimer(0.33 * speedFactor,function() 
                KillDanceProc (event, caster, target, distance, hits-1, speedFactor)
            end)
		else
            caster:RemoveModifierByName("modifier_killdance")
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_killdance_imunity", {Duration = 2})
        end
	else
		caster:RemoveModifierByName("modifier_killdance")
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_killdance_imunity", {Duration = 2})
	end
end

function KillDanceFX(event)
	local caster = event.caster
	local target = event.target
    if event.shaolin_fx then
        local particle = ParticleManager:CreateParticle("particles/econ/items/centaur/dc_centaur_double_edge/_dc_centaur_double_edge.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        ParticleManager:SetParticleControlEnt(particle, 4, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        ParticleManager:SetParticleControlEnt(particle, 5, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        ParticleManager:ReleaseParticleIndex(particle)
    else
    	local vec = (caster:GetAbsOrigin()-target:GetAbsOrigin()):Normalized()
    	local vec2 = target:GetAbsOrigin()
    	local particle = ParticleManager:CreateParticle("particles/econ/items/phantom_assassin/phantom_assassin_arcana_elder_smith/phantom_assassin_crit_arcana_swoop.vpcf", PATTACH_POINT_FOLLOW, target)
    	ParticleManager:SetParticleControl(particle, 0, vec2)
    	ParticleManager:SetParticleControl(particle, 1, vec2)
    	ParticleManager:SetParticleControlForward(particle, 1, vec)
    	ParticleManager:SetParticleControl(particle, 6, vec2)
    	ParticleManager:SetParticleControl(particle, 10, vec2)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function DeepFreeze (event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	if target:HasModifier("modifier_icenova") or target:HasModifier("modifier_icenova_slow") then
		--ability:ApplyDataDrivenModifier(caster, target, "modifier_rootedfx", nil)

		local myevent = {}
		myevent.caster = caster
		myevent.target = target
		myevent.buff = "modifier_deepfreeze"
		myevent.ability = ability
		myevent.dur = event.dur
		ApplyBuff(myevent)

		local particle = ParticleManager:CreateParticle("particles/econ/events/winter_major_2016/blink_dagger_start_sparkles_wm.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
		--ParticleManager:SetParticleControlEnt(particle, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
		EmitSoundOn("DOTA_Item.ShivasGuard.Activate", target)
	else
 		ability:EndCooldown()
	end
end

function VampiricEmbrace(event)
	local caster = event.caster
	local ability = event.ability
	local range = 900

	local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, range, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
	if #enemies > 0 then
		for _,enemy in pairs(enemies) do
			if enemy ~= nil then
				if ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet")) then
					local table = {}
					table.caster = caster
					table.target = enemy
					table.ability = ability
					table.attributefactor = 0.0
					table.spelldamagefactor = 0.0
					table.heal = event.heal
					if enemy == caster then
						--table.heal = event.heal * event.healfactor / 100
					else
						HealUnit(table)
					end
					
					local particle = ParticleManager:CreateParticle("particles/items3_fx/glimmer_cape_initial_flash_ember.vpcf", PATTACH_POINT_FOLLOW, enemy)
                    ParticleManager:ReleaseParticleIndex(particle)
					--ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,75))
					--ParticleManager:SetParticleControl(particle, 1, enemy:GetAbsOrigin()+Vector(0,0,75))
				end
			end
		end
	end
end

function SiegeDamageTower(event)
	local target = event.target
	if target:GetUnitLabel() == "tower" then
		if target:GetUnitName() == "npc_dota_creature_city_boss_1" or target:GetUnitName() == "npc_dota_creature_city_boss_2" then
			return
		end
		event.damage = event.damage*4
		local particle = ParticleManager:CreateParticle("particles/items_fx/dagon_tgt_sparks.vpcf", PATTACH_POINT_FOLLOW, target)
		ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
		EmitSoundOn("Hero_Lina.DragonSlave", target)
		DamageUnit(event)
	end
end

function MindControl(event)
	local caster = event.caster
	local target = event.target

	local owner = target:GetOwner()
	--print(PlayerResource:GetPlayerName(5))
	if owner == nil then
		--print("fixed owner")
		target:SetOwner(PlayerResource:GetPlayer(5))
		owner = target:GetOwner()
	end

	local id = caster:GetPlayerID()
	local id2 = owner:GetPlayerID()


	--target:SetControllableByPlayer(id, true)
	--target:SetControllableByPlayer(id2, false)
	PlayerResource:SetUnitShareMaskForPlayer(id, id2, 1, true)
end
function MindControlEnd(event)
	local caster = event.caster
	local target = event.target

	local owner = target:GetOwner()
	local id = caster:GetPlayerID()
	local id2 = owner:GetPlayerID()


	--target:SetControllableByPlayer(id, true)
	--target:SetControllableByPlayer(id2, false)
	PlayerResource:SetUnitShareMaskForPlayer(id, id2, 1, false)
end

function UpgradeSpell(event)
	local hero = event.caster
	local charges = event.charges
	hero:RemoveModifierByName("modifier_charges")
	hero:AddNewModifier(hero, event.ability, "modifier_charges",
	    {
	        max_count = charges,
	        start_count = charges-1,
	        replenish_time = 25
	    }
	)
end

function SoulBrotherRing(event)
	local caster = event.caster
	if caster:GetHealth() / caster:GetMaxHealth() <= caster:GetMana() / caster:GetMaxMana() then
		event.amount = nil
		event.percent = nil
		HealUnit(event)
	else
		event.heal = nil
		event.percenthp = nil
		RestoreMana(event)
	end
end

--[[
function SetCombine(event)
	local caster = event.caster
	if caster and caster:HasModifier("modifier_item_set_str_tank_3") and caster:HasModifier("modifier_item_set_str_tank_2") and caster:HasModifier("modifier_item_set_str_tank_1") then
     	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_set_str_tank_full", nil)
	end
	if caster and caster:HasModifier("modifier_item_set_str_dmg_3") and caster:HasModifier("modifier_item_set_str_dmg_2") and caster:HasModifier("modifier_item_set_str_dmg_1") then
     	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_set_str_dmg_full", nil)
	end
	if caster and caster:HasModifier("modifier_item_set_agi_dmg_3") and caster:HasModifier("modifier_item_set_agi_dmg_2") and caster:HasModifier("modifier_item_set_agi_dmg_1") then
     	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_set_agi_dmg_full", nil)
	end
	if caster and caster:HasModifier("modifier_item_set_int_dmg_3") and caster:HasModifier("modifier_item_set_int_dmg_2") and caster:HasModifier("modifier_item_set_int_dmg_1") then
     	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_set_int_dmg_full", nil)
	end
	if caster and caster:HasModifier("modifier_item_ring_arcane_2") and caster:HasModifier("modifier_item_ring_arcane") then
     	event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_item_ring_arcane_full", nil)
	end
end]]

function PVELifestealLow(event)
	local caster = event.caster
	if caster:GetHealth()/caster:GetMaxHealth() <= 0.5 then
        local particle = ParticleManager:CreateParticle("particles/neutral_fx/troll_heal.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
		HealUnit(event)
	end
end

function WispArmyLow(event)
    local caster = event.caster
    if (caster:GetHealth()/caster:GetMaxHealth() <= 0.8 and caster:GetHealth()/caster:GetMaxHealth() >= 0.7) or (caster:GetHealth()/caster:GetMaxHealth() <= 0.5 and caster:GetHealth()/caster:GetMaxHealth() >= 0.35) or (caster:GetHealth()/caster:GetMaxHealth() <= 0.2 and caster:GetHealth()/caster:GetMaxHealth() >= 0.0) then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_spawn_wips", nil)
    end
end

function PVEBashLow(event)
    local caster = event.caster
    if caster:GetHealth()/caster:GetMaxHealth() <= 0.15 then
        if not caster.stun_low_timer then
            caster.stun_low_timer = 1
            Timers:CreateTimer(15, function()
                caster.stun_low_timer = 2
            end)
        end
        if caster.stun_low_timer and caster.stun_low_timer == 1 then
            ApplyBuff(event)
        end
    end
end

function PVESprintLow(event)
    local caster = event.caster
    if caster:GetHealth()/caster:GetMaxHealth() <= 0.25 then
        ApplyBuff(event)
    end
end

function Damaged(unit)
    if unit:GetHealth() / unit:GetMaxHealth() < 1.0 then
        return true
    end
    return false
end

function SharedLife(event)
    --if COverthrowGameMode.jungledifficulty <= 1 then
    --    return
    --end
	local caster = event.caster
	local other = caster.sharedhealth
    local heal = event.heal
	if other and not other:IsNull() and other:IsAlive() then
        --[[ heal
        if Damaged(caster) then
            if COverthrowGameMode.jungledifficulty >= 0 and (caster:GetAbsOrigin() - other:GetAbsOrigin()):Length() < 600 then
                caster:SetHealth(caster:GetMaxHealth()*heal+caster:GetHealth())
                local particle = ParticleManager:CreateParticle("particles/items3_fx/fish_bones_active.vpcf", PATTACH_POINT_FOLLOW, caster)
                ParticleManager:ReleaseParticleIndex(particle)
            end
        end]]
		if other:GetHealth() > caster:GetHealth() then
 			caster:SetHealth(other:GetHealth())
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_warlock/warlock_fatal_bonds_pulse.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:SetParticleControlEnt(particle, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
            ParticleManager:SetParticleControlEnt(particle, 1, other, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
            ParticleManager:ReleaseParticleIndex(particle)
		end
	end
end

function IsEnemyInRangeWithAggro( unit, distance )
    local playerid = unit:GetPlayerOwnerID()
    if unit and not unit:IsNull() then
        local enemies = FindUnitsInRadius( unit:GetTeamNumber(), unit:GetAbsOrigin(), unit, distance, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_ALL, 0, 0, false )
        if #enemies > 0 then
            for _,enemy in pairs(enemies) do
                if enemy.aggrolist and enemy.aggrolist[playerid] and enemy.aggrolist[playerid] > 0 then
                    return true
                end
            end
        end
    end
    return false
end

function TempleTeleportFromMenu(event, args)
    local player = PlayerResource:GetPlayer(args['player_id'])
    local tp_id = args['tp']
    local tp = COverthrowGameMode.teleporters[tp_id]
    if tp and player then
        local caster = player:GetAssignedHero()
        if not caster then
            return
        end
        if IsEnemyInRangeWithAggro( caster, 2501 ) then
            Notifications:Top(caster:GetPlayerID(), {text="Can not teleport when Monsters are too close!", duration=4, style={color="red"}})
            return
        end
        if caster.combat_system_ability then
            caster:SetAbsOrigin(tp:GetAbsOrigin())
            if tp_id == 8 and COverthrowGameMode.unlock_improved_tp_act_11 then
                caster:SetAbsOrigin(Entities:FindByName( nil, "act11_creep_3" ):GetAbsOrigin())
            end
            local tab = {}
            tab.Duration = 0.5
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", tab)
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_chen/chen_teleport.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            EmitGlobalSound("DOTA_Item.ArcaneBoots.Activate")
            PlayerResource:SetCameraTarget(caster:GetPlayerOwnerID(), caster)
            CustomGameEventManager:Send_ServerToPlayer(player, "toggle_menu", { menu = 1 } )
            Timers:CreateTimer(0.25, function()
                PlayerResource:SetCameraTarget(caster:GetPlayerOwnerID(), nil)
            end)
        end
    end
end

function TempleTeleport( event )
    local caster = event.caster.controlowner
    local point = event.target_points[1]
    if caster and point then
        if not caster:IsAlive() then
            return
        end
        for i=0, 10 do
            local tp = COverthrowGameMode.teleporters[i]
            if tp and (tp.tp_active or (COverthrowGameMode.jungledifficulty >= 50.0 and i ~= 8)) then
                Timers:CreateTimer(i*0.7-0.65, function()
                    if IsEnemyInRangeWithAggro( caster, 2501 ) then
                        MinimapEvent(caster:GetTeamNumber(), caster, tp:GetAbsOrigin()[1], tp:GetAbsOrigin()[2], DOTA_MINIMAP_EVENT_BASE_UNDER_ATTACK, 1 )
                    else
                        MinimapEvent(caster:GetTeamNumber(), caster, tp:GetAbsOrigin()[1], tp:GetAbsOrigin()[2], DOTA_MINIMAP_EVENT_TEAMMATE_TELEPORTING, 1 )
                    end
                end)
            end
        end
        if IsEnemyInRangeWithAggro( caster, 2501 ) then
            event.ability:EndCooldown()
            event.ability:StartCooldown(0.5)
            Notifications:Top(caster:GetPlayerID(), {text="Can not teleport when enemies too close!", duration=4, style={color="red"}})
        else
            for i=0, 10 do
                local tp = COverthrowGameMode.teleporters[i]
                if i == 0 then
                    tp = event.caster
                    event.caster.tp_active = true
                end
                if tp and (tp.tp_active or (COverthrowGameMode.jungledifficulty >= 50.0 and i ~= 8)) and (point-tp:GetAbsOrigin()):Length() <= 3500 then
                    caster:SetAbsOrigin(tp:GetAbsOrigin())
                    local tab = {}
                    tab.Duration = 0.5
                    event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", tab)
                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_chen/chen_teleport.vpcf", PATTACH_POINT_FOLLOW, caster)
                    ParticleManager:ReleaseParticleIndex(particle)
                    EmitGlobalSound("DOTA_Item.ArcaneBoots.Activate")
                    return
                end
            end
            Notifications:Top(caster:GetPlayerID(), {text="No unlocked Teleporter selected!", duration=4, style={color="white"}})
            event.ability:EndCooldown()
        end
        EmitGlobalSound("DOTA_Item.Necronomicon.Bow")
    end
end

function TempleTeleportActivate( event )
    local caster = event.caster.controlowner
    if caster then
        local point = caster:GetAbsOrigin()
        for i=1, 9 do
            local tp = COverthrowGameMode.teleporters[i]
            if tp then
                --print(tp:GetName())
                --print(tp.tp_active)
                if not tp.tp_active and (point-tp:GetAbsOrigin()):Length() <= 1200 then
                    tp.tp_active = true
                    local particle = ParticleManager:CreateParticle("particles/items3_fx/glimmer_cape_initial.vpcf", PATTACH_POINT_FOLLOW, caster)
                    ParticleManager:ReleaseParticleIndex(particle)
                    EmitGlobalSound("DOTA_Item.LinkensSphere.Target")
                    Notifications:TopToAll({text="New Teleporter unlocked!", duration=5, style={color="lightblue"}})
                    CustomGameEventManager:Send_ServerToAllClients( "tp_unlocked", {value = id} )
                end
            end
        end
    end
end

function RandomPosition(event)
    local caster = event.caster
    local target = event.target
    local range = event.range
    local min = 200
    if event.min then
        min = event.min
    end
    local vec = RandomVector(1.0)
    local vec2 = Vector(vec[1],vec[2],0):Normalized()*math.random(min,range)

    if event.circledynamic and event.circledynamic > 0 and caster then
        local i = 1
        if event.clockwise and caster:GetHealth() / caster:GetMaxHealth() < 0.75 and caster:GetHealth() / caster:GetMaxHealth() > 0.25 then
            i = -1
        end
        if caster.circle_array then
            caster.circle_array = caster.circle_array + i
        else
            caster.circle_array = 1
        end
        if caster.circle_array > event.circledynamic then
            caster.circle_array = 1
        end
        if caster.circle_array < 1 then
            caster.circle_array = event.circledynamic
        end
        local vecs = {}
        local offset_degree = 360 / event.circledynamic
        local offset_start = 0
        if event.degreeoffset then
            offset_start = event.degreeoffset
        end
        --for i=1, event.circledynamic do
        --    print("degree " .. offset_start+offset_degree*i .. " rad " .. math.rad(offset_start+offset_degree*i))
        --    vecs[i] = Vector(range*math.cos(math.rad(offset_start+offset_degree*i),range*math.sin(math.rad(offset_start+offset_degree*i))))
        --end
        --vec2 = vecs[caster.circle_array]
        --print("offset degree " .. offset_degree .. "  casterarray " .. caster.circle_array)
        --print("degree " .. offset_start+offset_degree*caster.circle_array .. " rad " .. math.rad(offset_start+offset_degree*caster.circle_array))

        vec2 = Vector(range*math.cos(math.rad(offset_start+offset_degree*caster.circle_array)), range*math.sin(math.rad(offset_start+offset_degree*caster.circle_array)), 0)
        --print(vec2)
    end
    target:SetAbsOrigin(caster:GetAbsOrigin()+vec2)
end

function SetPositionPattern(event)
    local caster = event.caster
    local target = event.target
    local start_pos = caster:GetAbsOrigin()
    local distance_between_nodes = 600
    
    if event.reset then
        caster.position_pattern_index = 0
    end
    if event.maze and caster.position_pattern_index then
        if math.random(1,100) <= 55 then
            Timers:CreateTimer(0.5, function()
                target:RemoveModifierByName("modifier_poolfx")
            end)
        end
        local nodes_per_row = event.maze
        local x = 0.5 + (caster.position_pattern_index % 6) - nodes_per_row / 2
        local y = 0.5 + math.floor(caster.position_pattern_index / 6) - nodes_per_row / 2
        start_pos = start_pos + Vector(x*distance_between_nodes, y*distance_between_nodes, 0)
        caster.position_pattern_index = caster.position_pattern_index + 1
        target:SetAbsOrigin(start_pos)
        --print("set")
        --print(start_pos)
        --print(y)
    end
end

function OrderToCaster (event)
    local caster = event.caster
    local unit = event.target
    unit.sourcepriest = caster

    Timers:CreateTimer(0.1, function()
        if caster then
            local order = 
            {
                UnitIndex = unit:entindex(),
                OrderType = DOTA_UNIT_ORDER_MOVE_TO_TARGET,
                TargetIndex = caster:entindex()
            }

            ExecuteOrderFromTable(order)
        end
    end)
end

function HealCloseCaster (event)
    local caster = event.target
    local target = event.caster
    if target and caster and not caster.healdone then
        if (target:GetAbsOrigin()-caster:GetAbsOrigin()):Length() <= 200 then
            caster.healdone = 1
            caster:AddAbility("pveboss_system"):SetLevel(1)
            caster:RemoveModifierByName("modifier_heavens_halberd_debuff")
            event.caster = target
            event.target = target
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti6/blink_dagger_start_ti6_lvl2.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
            HealUnit(event)
        end
    end
end

function ReleaseCloseCaster (event)
    local caster = event.target
    local target = event.caster
    if target and caster and not caster.healdone then
        if (target:GetAbsOrigin()-caster:GetAbsOrigin()):Length() <= 200 then
            caster.healdone = 1
            caster:AddAbility("pveboss_system"):SetLevel(1)
            caster:RemoveModifierByName("modifier_heavens_halberd_debuff")
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti6/blink_dagger_start_ti6_lvl2.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
end

function MagmaSphere (event)
    local caster = event.caster
    local target = event.target
    if event.abil_exe then
        if caster and target and caster:GetTeamNumber() ~= target:GetTeamNumber() then
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ember_spirit/ember_spirit_hit_fire.vpcf", PATTACH_POINT_FOLLOW, target)
            particle = ParticleManager:CreateParticle("particles/econ/items/earthshaker/egteam_set/hero_earthshaker_egset/earthshaker_echoslam_start_magma_egset.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
            EmitSoundOn("DOTA_Item.Armlet.DeActivate", target)
            DamageAOE(event)
        end
    else
        caster = event.attacker
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ember_spirit/ember_spirit_hit_fire.vpcf", PATTACH_POINT_FOLLOW, target)
        particle = ParticleManager:CreateParticle("particles/econ/items/earthshaker/egteam_set/hero_earthshaker_egset/earthshaker_echoslam_start_magma_egset.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        EmitSoundOn("DOTA_Item.Armlet.DeActivate", target)
        DamageAOE(event)
    end
end

function ChainLightningItem(event)
    local caster = event.caster
    local target = event.target
    event.hit_targets = {}
    event.total_targets = event.jumps
    event.maxtargets = event.jumps
    if event.includeauto and event.includeauto > 0 then
        event.damage = event.damage + caster:GetAttackDamage() * event.includeauto / 100
    end
    if event.attributefactor and event.attributefactor > 0 then
        event.damage = event.damage + GetPrimaryStatValueCustom(caster) * event.attributefactor / 100
    end
    ZeusCloudProc(event)
end

function AffixChainLightning( event )
    local caster = event.caster
    event.target = COverthrowGameMode:AggroLowest(caster)
    event.hit_targets = {}
    event.total_targets = 10
    event.maxtargets = 10
    event.chain_hit_count = 0
    event.chainlight_only_hero = true
    event.damage_scale_per_target = 3
    event.difficultyscalelinear = 250
    event.jumprange = 300
    event.sky_lightning_fx = true
    event.lightning_delay = 0.5
    if event.target then
        ChainLightningProc(event)
    end
end

function PathChainLightning( event )
    local caster = event.caster
    event.hit_targets = {}
    event.total_targets = 3
    event.maxtargets = 3
    event.chain_hit_count = 0
    event.damage_scale_per_target = 0.5
    event.includeauto = 100 * caster.talents[87]
    event.jumprange = 300
    --event.sky_lightning_fx = true
    event.lightning_delay = 0.5
    event.naturedmg = 1
    event.holydmg = 1
    event.changedmgtypetophys = 1
    if event.target then
        ChainLightningProc(event)
    end
end

function ChainLightning(event)
    local caster = event.caster
    local target = event.target
    if caster and (not caster:IsNull()) and target and (not target:IsNull()) and caster:GetTeamNumber() ~= target:GetTeamNumber() then
        event.hit_targets = {}
        if caster:HasModifier("modifier_npc_dota_hero_shadow_shaman") then
            event.jumps = event.jumps + 3
        end
        event.total_targets = event.jumps
        event.maxtargets = event.jumps
        event.chain_hit_count = 0
        event.damage_scale_per_target = event.damage_scale
        event.damage_scale = nil
        ChainLightningProc(event)
    end
end

function ChainLightningProc(event)
    --print(event.total_targets)
    event.isaoe = 1
    local caster = event.caster
    local target = event.target
    if not (caster and not caster:IsNull()) then
        return
    end
    if not (target and not target:IsNull()) then
        return
    end
    local pos = target:GetAbsOrigin()
    local fxcaster = caster
    if event.hit_targets[event.total_targets+1] then
        fxcaster = event.hit_targets[event.total_targets+1]
    end
    --do dmg and fx
    event.chain_hit_count = event.chain_hit_count + 1
    local particle = ParticleManager:CreateParticle("particles/neutral_fx/harpy_chain_lightning.vpcf", PATTACH_POINT_FOLLOW, caster) --particles/items_fx/chain_lightning.vpcf
    ParticleManager:SetParticleControlEnt(particle, 0, fxcaster, PATTACH_POINT_FOLLOW, "attach_hitloc", fxcaster:GetAbsOrigin(), true)
    ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
    ParticleManager:ReleaseParticleIndex(particle)
    if event.sky_lightning_fx then
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_zeus/zeus_cloud_strike.vpcf", PATTACH_WORLDORIGIN, target)
        ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,250))
        ParticleManager:SetParticleControl(particle, 6, Vector(1,1,1))
        ParticleManager:ReleaseParticleIndex(particle)
        particle = ParticleManager:CreateParticle("particles/units/heroes/hero_zeus/zeus_cloud_strike.vpcf", PATTACH_WORLDORIGIN, target)
        ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + Vector(0,0,75))
        ParticleManager:SetParticleControl(particle, 1, fxcaster:GetAbsOrigin() + Vector(0,0,75))
        ParticleManager:SetParticleControl(particle, 6, Vector(1,1,1))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    EmitSoundOn("Item.Maelstrom.Chain_Lightning.Jump", target)
    --dont reduce dmg of first hit
    if not caster:HasModifier("modifier_npc_dota_hero_shadow_shaman") and event.chain_hit_count ~= 1 then
        event.damage_scale = math.pow(event.damage_scale_per_target, event.chain_hit_count - 1)
    end
    DamageUnit(event)
    if event.stunOnFirstHit then
        ApplyBuff({caster = caster, target = target, ability = event.ability, buff = "modifier_stunned", dur = 3, stunOnFirstHit = true})
    end

    --save target hit already
    event.hit_targets[event.total_targets] = event.target
    event.total_targets = event.total_targets - 1
    --find next target, if charges left
    if event.total_targets >= 1 then
        local valid_targets = {}
        local index = 1
        local enemies = FindUnitsInRadius( caster:GetTeamNumber(), pos, caster, event.jumprange, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
        for _,enemy in pairs(enemies) do
            if enemy ~= nil and (not enemy:IsNull()) and enemy:IsAlive() and ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()=="pet") or (enemy:GetUnitLabel()=="tower")) and not CheckForBreakableCC(target) and ((not event.chainlight_only_hero) or (event.chainlight_only_hero and enemy:IsRealHero())) then 
                local valid = true
                for i=1, event.maxtargets do
                    if event.hit_targets[i] and (enemy == event.hit_targets[i]) then
                        valid = false
                    end
                end
                if valid then
                    valid_targets[index] = enemy
                    index = index + 1
                end
            end
        end
        if index <= 1 then
            return
        end
        local final_target = valid_targets[math.random(1,index-1)]
        if final_target then
            local delay = 0.3
            if event.lightning_delay then 
                delay = event.lightning_delay
            end
            Timers:CreateTimer(delay, function()
                --[[
                local myevent = {}
                myevent.caster = caster
                myevent.target = final_target
                myevent.damage = event.damage / 2 --damage factor need set, also set item
                myevent.ability = event.ability
                myevent.hit_targets = event.hit_targets
                myevent.total_targets = event.total_targets
                myevent.maxtargets = event.maxtargets
                myevent.jumprange = event.jumprange]]
                event.target = final_target
                ChainLightningProc(event)
            end)
        end
    end
end

function CoilDamageUnit (event)
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() ~= target:GetTeamNumber() then
        DamageUnit(event)
    else
        if target:GetUnitName() == "npc_dota_creature_ghoul" or target:GetUnitName() == "npc_dota_creature_unholy_dragon" then
        --event.attributefactor = event.attributefactor * 3
        --HealUnit(event)
            event.ability:ApplyDataDrivenModifier(caster, target, "modifier_dk_coil_enrage", {Duration = 30})
        else
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.ability = event.ability
            myevent.heal = 0.0
            myevent.percenthp = event.healing
            HealUnit(myevent)
        end
    end
end

function CoilApplyBuffStack (event)
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() ~= target:GetTeamNumber() then
        ApplyBuffStack (event)
    end
end

function InnerCDSystem (event)
    local caster = event.caster
    if not caster:HasModifier(event.debuff) then
        if event.resistancebuff then
            local tab = {dur = event.resistancebuff}
            tab.caster = caster
            tab.target = event.target
            tab.buff = "modifier_polybonusdamage_enemy"
            tab.ability = event.ability
            --event.ability:ApplyDataDrivenModifier(caster, target, "modifier_polybonusdamage_enemy", tab)
            ApplyBuff(tab)
        end
        local tab = {Duration = event.innercd * GetInnerCooldownFactor(caster)}
        event.ability:ApplyDataDrivenModifier(caster, caster, event.debuff, tab)
        ApplyBuff(event)
    end
end

function InnerCDSystemTarget (event)
    local caster = event.caster
    local target = event.target
    if not target:HasModifier(event.debuff) then
        local tab = {Duration = event.innercd * GetInnerCooldownFactor(caster)}
        event.ability:ApplyDataDrivenModifier(caster, target, event.debuff, tab)
        ApplyBuff(event)
    end
end

function ApplyBuffNonDuplicate (event)
    local caster = event.caster
    local target = event.target
    if not target:HasModifier(event.buff) then
        if event.alwaysapply then
            local tab = {Duration = event.dur}
            event.ability:ApplyDataDrivenModifier(caster, target, event.buff, tab)
        else
            ApplyBuff(event)
        end
    end
end

function CompanionAI (event)
    local caster = event.caster
    local id = 1
    local position_angle = 100
    if event.companion_id then
        id = event.companion_id
        position_angle = 0
        if id == 2 then
            position_angle = 310
        end
        if id == 3 then
            position_angle = 50
        end
    end
    local companion
    if caster.companion then
        companion = caster.companion[id]
    end
    local tab = {Duration = -1}
    if companion and not companion:IsNull() and companion:IsAlive() then
        --blink if far away
        if (caster:GetAbsOrigin()-companion:GetAbsOrigin()):Length() > 1500 then --890 before
            companion:SetAbsOrigin(caster:GetAbsOrigin()+Vector(0,100,0))
            event.ability:ApplyDataDrivenModifier(caster, companion, "modifier_phased", tab)
        end
        --standard behavior
        local has_attack_order = false
        if event.fight then
            local target = caster.companiontarget
            if target and not target:IsNull() and target:IsAlive() and (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length() < 900 then
                has_attack_order = true
                local order = 
                {
                    UnitIndex = companion:entindex(),
                    OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                    TargetIndex = target:entindex()
                }
                ExecuteOrderFromTable(order)
            end
        end
        if event.follow or not has_attack_order then
            if caster:IsMoving() then
                local position = caster:GetAbsOrigin() + 350 * caster:GetForwardVector() + RotateVectorAroundAngle(caster:GetForwardVector(), position_angle) * 150
                local order = 
                {
                    UnitIndex = companion:entindex(),
                    OrderType = DOTA_UNIT_ORDER_MOVE_TO_POSITION,
                    Position = position
                }
                ExecuteOrderFromTable(order)
                --[[ old follow, didnt work cuz unselectable
                local follow_target = caster
                if event.companion_id == 3 and IsCompanionAlive(caster, 2) then
                    follow_target = caster.companion[2]
                end
                if event.companion_id == 4 and IsCompanionAlive(caster, 3) then
                    follow_target = caster.companion[3]
                end
                local order = 
                {
                    UnitIndex = companion:entindex(),
                    OrderType = DOTA_UNIT_ORDER_MOVE_TO_TARGET,
                    TargetIndex = follow_target:entindex()
                }
                ExecuteOrderFromTable(order)]]
            else
                local position = caster:GetAbsOrigin() + RotateVectorAroundAngle(caster:GetForwardVector(), position_angle) * 150
                local order = 
                {
                    UnitIndex = companion:entindex(),
                    OrderType = DOTA_UNIT_ORDER_MOVE_TO_POSITION,
                    Position = position
                }
                ExecuteOrderFromTable(order)
            end
        end
    else
        if event.dragon then
            local buffname = "dragon_summon_proc"
            if event.companion_id then
                buffname = "dragon_summon_proc_"..event.companion_id
            end
            event.ability:ApplyDataDrivenModifier(caster, caster, buffname, nil)
        end
    end
end

function CompanionTargetSet(event)
    local caster = event.attacker
    caster.companiontarget = event.unit
end

function CompanionRegister(event)
    local caster = event.caster
    if not caster.companion then
        caster.companion = {}
    end
    local id = 1
    if event.companion_id then
        id = event.companion_id
    end
    caster.companion[id] = event.target
    event.target.owner = caster
    event.target:SetControllableByPlayer(-1, true) --test denying comp behavior
end

function CompanionRemoval(event)
    local caster = event.caster
    local id = 1
    if event.companion_id then
        id = event.companion_id
    end
    if IsCompanionAlive(caster, id) then
        UTIL_Remove(caster.companion[id])
        caster.companion[id] = nil
    end
end

function IsCompanionAlive(caster, id)
    if not caster.companion then
        return false
    end
    local companion = caster.companion[id]
    if companion and not companion:IsNull() and companion:IsAlive() then
        return true
    else
        return false
    end
end

function RadianceProc(caster, ability )
    HealMostWoundedHero({caster = caster, target = caster, ability = ability, holy4FX = 1, fromCaster = 1, heal = 0, percenthp = 0.01 * GetRadianceStat(caster), range = 900})
end

function HealMostWoundedHero(event)
    local caster = event.caster
    local target = MostWoundedTarget(event)
    local fromUnit = caster
    if (not event.fromCaster) and caster.companion and caster.companion[1] then
        fromUnit = caster.companion[1]
    end
    local particleFX = "particles/dazzle_shadow_wave_green.vpcf"
    if event.holy4FX then
        particleFX = "particles/dazzle_holy_wave_b.vpcf"
    end
    if target and fromUnit then
        local particle = ParticleManager:CreateParticle(particleFX, PATTACH_POINT_FOLLOW, fromUnit)
        ParticleManager:SetParticleControlEnt(particle, 0, fromUnit, PATTACH_POINT_FOLLOW, "attach_hitloc", fromUnit:GetAbsOrigin(), true)
        ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
        ParticleManager:ReleaseParticleIndex(particle)
        event.target = target
        HealUnit(event)
    end
end

function IncreaseAgonyCounter(event)
    local caster = event.caster
    caster.AgonyCounter = caster.AgonyCounter + 0.1
end

function ShowDamageTaken(event)
    local caster = event.caster
    --print(event.attacker:GetUnitName())
    if event.attacker and (event.attacker:GetUnitName() == "dota_fountain" or event.attacker:GetUnitName() == "npc_dota_goodguys_tower1_bot") then
        event.attacker:SetAcquisitionRange(1.0)
        event.attacker:RemoveModifierByName("modifier_invulnerable")
        event.ability:ApplyDataDrivenModifier(event.attacker, event.attacker, "modifier_disarmed", {Duration = -1})
    end
    if event.attacker:HasModifier("modifier_pet_system") or event.attacker:HasModifier("modifier_pet_system_grizzly") or event.attacker:HasModifier("modifier_companion_behavior") then
        return
    end
    local damage = event.dmg
    CriticalStrikeFX(caster, caster, damage, 0, 0)
    --dps calc
    if caster.dummy_dps_taken then
        caster.dummy_dps_taken = caster.dummy_dps_taken + damage
    else
        caster.dummy_dps_taken = damage
    end
end

function TutorialCastOrder(event)
    local caster = event.caster
    --reset dps counter
    caster.dummy_dps_time = 0
    caster.dummy_dps_taken = 0

    local ability = caster:GetAbilityByIndex(1)
    local order = 
    {
        UnitIndex = caster:entindex(),
        OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
        AbilityIndex = ability:GetEntityIndex(), 
        Queue = false
        --TargetIndex = caster.creepertarget:entindex()
    }
    ExecuteOrderFromTable(order)
end

function TutorialDummyPosition(event)
    local caster = event.caster
    if caster.dummy_dps_time then
        caster.dummy_dps_time = caster.dummy_dps_time + 3
    else
        caster.dummy_dps_time = 3
    end
    --no damage, no time counting
    if not caster.dummy_dps_taken or caster.dummy_dps_taken <= 0 then
        caster.dummy_dps_time = 0
    end

    if caster.dummy_dps_taken and caster.dummy_dps_taken > 0 and caster.dummy_dps_time > 0 then
        local dps = caster.dummy_dps_taken / caster.dummy_dps_time
        CriticalStrikeFX(caster, caster, dps, 3, 0)
    end

    if caster.dummy_dps_time > 10 then
        if(caster.position == nil) then
            caster.position = caster:GetAbsOrigin()
        end

        caster:SetAbsOrigin(caster.position)
    end
end

function TempleEggCorrupted(event)
    local caster = event.caster
    local target = event.target
    target:SetRenderColor(100, 100, 175)
end

function SetUnitColor(event)
    local caster = event.caster
    local target = event.target
    if not target then
        target = caster
    end
    target:SetRenderColor(event.r, event.g, event.b)
end

function DeathEggPosition(event)
    local caster = event.caster
    local target = event.unit
    target:SetAbsOrigin(target:GetAbsOrigin()+Vector(0,5000,0))
end

function DragonEggHatch(event)
    local caster = event.target
    if not caster:HasModifier("modifier_hatch_dragon") and caster:GetUnitName() == "temple_dragon_egg" then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_hatch_dragon", nil)
    end
end

function KillCaster(event)
    local caster = event.caster
    UTIL_Remove(caster)
end

function RemoveUnit(event)
    local caster = event.caster
    local target = event.unit
    target:SetAbsOrigin(target:GetAbsOrigin()+Vector(0,5000,0))
end

function FaceTargetCondition(event)
    local caster = event.caster
    local target = event.target

    local len1 = (target:GetAbsOrigin() - caster:GetAbsOrigin()):Length()
    local len2 = (target:GetAbsOrigin()+(target:GetForwardVector():Normalized()*5) - caster:GetAbsOrigin()):Length()

    if len2 < len1 then
        local particle = ParticleManager:CreateParticle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        DamageUnit(event)
    end
end

function TempleHealCollector(event)
    local caster = event.caster
    COverthrowGameMode.heal_collector = caster
end

function DamageAOESplitHeroLow(event)
    local caster = event.caster
    if caster:GetHealth()/caster:GetMaxHealth() < event.lowconditional / 100 then
        if not caster:HasModifier("modifier_fx_frost") then
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_fx_frost", nil)
        end
        DamageAOESplitHero(event)
    end
end

function TempleDelayBuff(event)
    local caster = event.caster
    if caster:GetHealth()/caster:GetMaxHealth() < event.maxhp and event.ability then
        event.ability:ApplyDataDrivenModifier(caster, caster, event.buff, nil)
    end
end

function ApplyBuffStackBasedOnPercentHP(event)
    local caster = event.caster
    if caster then
        local percent = 100 - math.floor(100 * caster:GetHealth() / caster:GetMaxHealth())
        if percent < 100.0 and event.ability then
            event.setstacks = percent
            ApplyBuffStack(event)
        end
    end
end

function TempleRandomArrowLaunch(event)
    local caster = event.caster
    local ability = event.ability
    local time = 2.25
    --modes
    local cast_sound = "Ability.LightStrikeArray"
    local impact_sound = "Ability.TossImpact"
    local aoe = 250
    local targeteffect = "fire"
    local impact_fx_type = 1
    local missile_fx = "particles/meteor_arrow.vpcf"
    local launch_pattern = nil
    local missiles = 4
    local random_target = nil
    local damage = 400
    if event.damagefactor then
        damage = damage * event.damagefactor
    end
    if event.arrow then
        cast_sound = "Hero_PhantomAssassin.Dagger.Cast"
        impact_sound = "Hero_PhantomAssassin.Dagger.Target"
        aoe = 75
        targeteffect = "blood"
        is_fire_effect = false
        missile_fx = "particles/spear_arrow.vpcf"
        event.stun = 2.5
        impact_fx_type = 2
        time = 2.5
    end
    if event.rock then
        cast_sound = "Hero_Lina.preAttack"
        --impact_sound = "Hero_PhantomAssassin.Dagger.Target"
        aoe = 250
        targeteffect = "blood"
        is_fire_effect = false
        missile_fx = "particles/rock_arrow.vpcf"
        event.stun = 1.5
        impact_fx_type = 3
        time = 2.25
        missiles = 1
        if not caster.missile_launch_pattern_rock then
            caster.missile_launch_pattern_rock = 1
        end
    end
    if event.icerock then
        cast_sound = "Hero_Lina.preAttack"
        --impact_sound = "hero_Crystal.frostbite"
        aoe = 200
        targeteffect = "blood"
        is_fire_effect = false
        missile_fx = "particles/icerock_arrow.vpcf"
        --event.stun = 1
        impact_fx_type = 4
        time = 3
        missiles = 1
        local all = HeroList:GetAllHeroes()
        random_target = all[math.random(1,#all)]
        --if not caster.missile_launch_pattern_rock then
        --    caster.missile_launch_pattern_rock = 1
        --end
    end
    if event.rockcurve then
        cast_sound = "Hero_Lina.preAttack"
        --impact_sound = "Hero_PhantomAssassin.Dagger.Target"
        aoe = 250
        targeteffect = "blood"
        is_fire_effect = false
        missile_fx = "particles/rock_arrow.vpcf"
        event.stun = 2
        impact_fx_type = 3
        time = 1
        missiles = 1
        if caster.skip_next_rockcurve then
            caster.skip_next_rockcurve = false
            return
        end
        if event.init_rockcurve then
            caster.skip_next_rockcurve = true
            local current_target = COverthrowGameMode:AggroHighest(caster)
            if current_target then
                caster:SetForwardVector((current_target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized())
            end
            time = 2.0
            caster.missile_launch_pattern_rockcurve = 1
            if math.random(1,100) <= 50 then
                caster.missile_launch_pattern_rockcurve = -1
            end
            caster.last_rockcurve_throw_impact = caster:GetAbsOrigin()
            caster.last_rockcurve_forward = caster:GetForwardVector()
        end
    end

    local speed = 1.25 / time
    if event.missiles then
        missiles = event.missiles
    end

    if caster:GetHealth()/caster:GetMaxHealth() <= event.maxhp then
        EmitSoundOn(cast_sound, caster)
        for i=1, missiles do
            local particle
            event.range = math.random(400,925)
            if event.minrange then
                event.range = math.random(event.minrange,900)
            end
            local spot = RandomPointAroundUnit(event)
            if event.rock then
                if caster.missile_launch_pattern_rock == 1 then
                    caster.missile_launch_pattern_rock = 2
                    event.range = math.random(700,900)
                    spot = caster:GetAbsOrigin() + caster:GetForwardVector() * event.range
                    caster.last_rock_throw_impact = spot
                    particle = ParticleManager:CreateParticle(missile_fx, PATTACH_ABSORIGIN, caster)
                elseif caster.missile_launch_pattern_rock == 2 then
                    caster.missile_launch_pattern_rock = 1
                    event.range = math.random(700,900)
                    spot = caster:GetAbsOrigin()
                    particle = ParticleManager:CreateParticle(missile_fx, PATTACH_WORLDORIGIN, caster)
                    ParticleManager:SetParticleControl(particle, 0, caster.last_rock_throw_impact)
                end
            end
            if event.icerock then
                spot = random_target:GetAbsOrigin()
                event.range = (spot-caster:GetAbsOrigin()):Length()
            end
            if event.rockcurve then
                event.range = math.random(350,350)
                spot = caster.last_rockcurve_throw_impact + caster.last_rockcurve_forward * event.range
                particle = ParticleManager:CreateParticle(missile_fx, PATTACH_WORLDORIGIN, caster)
                ParticleManager:SetParticleControl(particle, 0, caster.last_rockcurve_throw_impact)
                caster.last_rockcurve_throw_impact = spot
                caster.last_rockcurve_forward = RotateVectorAroundAngle(caster.last_rockcurve_forward, 35*caster.missile_launch_pattern_rockcurve)
            end
            
            if not event.rock and not event.rockcurve then
                particle = ParticleManager:CreateParticle(missile_fx, PATTACH_ABSORIGIN, caster)
            end
            ParticleManager:SetParticleControl(particle, 1, spot)
            ParticleManager:SetParticleControl(particle, 2, Vector(event.range*speed,0,0))
            Timers:CreateTimer(time*1.0, function()
                EmitSoundOn(impact_sound, caster)
                if impact_fx_type == 1 then
                    local particle2 = ParticleManager:CreateParticle("particles/units/heroes/hero_ember_spirit/ember_spirit_hit_fire.vpcf", PATTACH_ABSORIGIN, caster)
                    ParticleManager:SetParticleControl(particle2, 0, spot)
                    ParticleManager:ReleaseParticleIndex(particle2)
                    particle2 = ParticleManager:CreateParticle("particles/econ/items/wraith_king/wraith_king_ti6_bracer/wraith_king_ti6_hellfireblast_explosion.vpcf", PATTACH_ABSORIGIN, caster)
                    ParticleManager:SetParticleControl(particle2, 3, spot)
                    ParticleManager:ReleaseParticleIndex(particle2)
                end
                if impact_fx_type == 2 then
                    local particle2 = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_WORLDORIGIN, caster)
                    ParticleManager:SetParticleControl(particle2, 0, spot)
                    ParticleManager:ReleaseParticleIndex(particle2)
                end
                if impact_fx_type == 3 then
                    local particle2 = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_warstomp.vpcf", PATTACH_WORLDORIGIN, caster)
                    ParticleManager:SetParticleControl(particle2, 0, spot)
                    ParticleManager:SetParticleControl(particle2, 1, Vector(aoe,aoe,aoe))
                    ParticleManager:ReleaseParticleIndex(particle2)
                end
                if impact_fx_type == 4 then
                    local particle2 = ParticleManager:CreateParticle("particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf", PATTACH_WORLDORIGIN, caster)
                    ParticleManager:SetParticleControl(particle2, 0, spot)
                    ParticleManager:SetParticleControl(particle2, 1, Vector(aoe,1,aoe))
                    ParticleManager:ReleaseParticleIndex(particle2)
                end
                if particle then
                    ParticleManager:DestroyParticle(particle, true)
                    ParticleManager:ReleaseParticleIndex(particle)
                end
                local tab = {}
                tab.stun = event.stun
                tab.caster = caster
                tab.target = caster
                tab.damage = 0.0
                tab.spelldamagefactor = 0.0
                tab.attributefactor = 0.0
                tab.difficultyscalelinear = damage
                tab.ability = ability
                tab.aoe = aoe
                tab.targeteffect = targeteffect
                tab.firedmg = 1
                tab.target_points = {}
                tab.target_points[1] = spot
                tab.onlyhero = 1
                DamageAOE(tab)
            end)
        end
    end
end

function RandomPointAroundUnit(event)
    local caster = event.caster
    local range = event.range
    local vec = RandomVector(1.0)
    return Vector(vec[1],vec[2],0):Normalized() * range + caster:GetAbsOrigin()
end

function GlobalLifesteal(event)
    local caster = event.caster
    event.target = caster
    local factor = 0
    --if caster:HasModifier("modifier_item_lifesteal_10") then
    --    factor = 0.10
    --end
    --if caster:HasModifier("modifier_item_shadowmourne") then
    --    factor = factor + 0.15
    --end
    if caster:HasModifier("modifier_lifesteal_100") then
        factor = factor + 1
    end
    if caster:HasModifier("modifier_item_shadowmourne_active") then
        factor = factor + 0.1
    end
    if caster:HasModifier("modifier_item_silverblood3_active") then
        factor = factor + 0.1
    end
    if caster:HasModifier("modifier_bloodflow") then
        factor = factor + 0.1
    end
    
    --if caster:HasModifier("modifier_item_crit_pure_2") then
    --    factor = factor + 0.15
    --end
    --if caster:HasModifier("modifier_item_crit_pure_4") then
    --    factor = factor + 0.15
    --end
    --if caster:HasModifier("modifier_item_crit_pure_3") then
    --    factor = factor + 0.15
    --end
    --if caster:HasModifier("modifier_item_crit_pure_5_lifesteal") then
    --    factor = factor + 0.05
    --end
    --if caster:HasModifier("modifier_deathwish") then
    --    factor = factor + 0.2
    --end
    --if caster.talents and caster.talents[40] and caster.talents[40] > 0 then
    --    factor = factor + 0.02 * caster.talents[40]
    --end
    --mythic
    --factor = factor + caster:GetModifierStackCount("modifier_mythic_lifesteal", nil) / 100

    --if caster:HasModifier("modifier_rogue_leech") and caster:GetAbilityByIndex(5) and caster:GetAbilityByIndex(5):GetLevel() >= 2 then
    --    factor = factor + 0.1
    --end
    --if caster:HasModifier("modifier_lifesteal_double") then
    --    factor = factor * 2
    --end
    if factor > 0 then
        if event.damage > 100000000 then
            event.damage = 100000000
        end
        event.heal = event.damage*factor
        event.damage = nil
        if event.heal > 0.5 then
            HealUnit(event)
        end
    end
end

function CheckBearEnrage(event)
    local caster = event.caster
    if not caster.bearform and caster:GetModifierStackCount("modifier_pvefrenzy_bear", nil) >= 25 then
        caster.bearform = true
        HideWearables(event)
        caster:SetModel("models/items/lone_druid/true_form/dark_wood_true_form/dark_wood_true_form.vmdl")
        caster:SetOriginalModel("models/items/lone_druid/true_form/dark_wood_true_form/dark_wood_true_form.vmdl")
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_lowest_aggro_hunt", nil)
    end
end

function DragonCouncilTP(event)
    local caster = event.caster
    local c1 = caster:GetAbsOrigin()
    if caster.dragoncouncil1 and caster and not caster:IsNull() and not caster.dragoncouncil1:IsNull() and (c1-caster.dragoncouncil1:GetAbsOrigin()):Length() > 2000 then
        caster.dragoncouncil1:SetAbsOrigin(c1+Vector(0,-50,0))
        local tab = {Duration = 0.1}
        event.ability:ApplyDataDrivenModifier(caster, caster.dragoncouncil1, "modifier_phased", tab)
        local particle = ParticleManager:CreateParticle("particles/econ/events/ti5/blink_dagger_start_smoke_ti5.vpcf", PATTACH_POINT_FOLLOW, caster.dragoncouncil1)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if caster.dragoncouncil2 and caster and not caster:IsNull() and not caster.dragoncouncil2:IsNull() and(c1-caster.dragoncouncil2:GetAbsOrigin()):Length() > 2000 then
        caster.dragoncouncil2:SetAbsOrigin(c1+Vector(0,-50,0))
        local tab = {Duration = 0.1}
        event.ability:ApplyDataDrivenModifier(caster, caster.dragoncouncil2, "modifier_phased", tab)
        local particle = ParticleManager:CreateParticle("particles/econ/events/ti5/blink_dagger_start_smoke_ti5.vpcf", PATTACH_POINT_FOLLOW, caster.dragoncouncil2)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function Autocast(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if ability:GetAutoCastState() and ability:GetCooldownTimeRemaining() <= 0.0 then
        ability:StartCooldown(ability:GetCooldown(0))
        ApplyBuff(event)
        EmitSoundOn("Hero_Ursa.Attack", target)
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ursa/ursa_fury_sweep_cross.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function WaveOfGlory(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if target:GetTeamNumber() == caster:GetTeamNumber() then
        if ability:GetLevel() >= 3 and caster ~= target then
            --heal allies hit
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti6/hero_levelup_ti6_flash_hit_magic.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
            local myevent = {}
            myevent.caster = caster
            myevent.target = target
            myevent.ability = ability
            myevent.heal = 0.0
            myevent.percenthp = event.healing
            HealUnit(myevent)
        end
    else
        local particle = ParticleManager:CreateParticle("particles/econ/items/magnataur/shock_of_the_anvil/magnataur_shockanvil_hit.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        local myevent = {}
        myevent.caster = caster
        myevent.target = target
        myevent.dur = 0.1
        myevent.ability = ability
        SpellInterrupt(myevent)
        DamageUnit(event)
        myevent = {}
        myevent.caster = caster
        myevent.target = caster
        myevent.ability = ability
        myevent.heal = 0.0
        myevent.percenthp = event.healing
        HealUnit(myevent)
    end
end

function SteedOfLight(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if target:GetTeamNumber() == caster:GetTeamNumber() then
        --heal allies hit
        local particle = ParticleManager:CreateParticle("particles/econ/events/ti6/hero_levelup_ti6_flash_hit_magic.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        local myevent = {}
        myevent.caster = caster
        myevent.target = target
        myevent.ability = ability
        myevent.heal = 0.0
        myevent.attributefactor = event.attributefactor
        myevent.spelldamagefactor = event.spelldamagefactor
        HealUnit(myevent)
    else
        local particle = ParticleManager:CreateParticle("particles/econ/items/magnataur/shock_of_the_anvil/magnataur_shockanvil_hit.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        if event.rootdur and event.rootdur > 0 then
            local myevent = { caster = caster, target = target, buff = "modifier_stunnedshackle", ability = ability, max = 5, dur = event.rootdur}
            ApplyBuff(myevent)
        end
        local myevent = {}
        myevent.caster = caster
        myevent.target = target
        myevent.dur = 0.1
        myevent.ability = ability
        SpellInterrupt(myevent)
        DamageUnit(event)
    end
    if event.spellhasteproc and event.spellhasteproc > 0 then
        local myevent = { caster = caster, target = caster, buff = "modifier_keeper_spellhaste", ability = ability, max = 5, dur = 10}
        ApplyBuffStack(myevent)
    end
end

function HolyBashMissile(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local pos = target:GetAbsOrigin()
    local info = {
        Target = target,
        Source = caster,
        Ability = ability,
        EffectName = "particles/econ/items/phantom_lancer/phantom_lancer_immortal_ti6/phantom_lancer_immortal_ti6_spiritlance.vpcf",
        bDodgeable = true,
        bProvidesVision = true,
        iMoveSpeed = 600,
        iVisionRadius = 300,
        iVisionTeamNumber = caster:GetTeamNumber(),
        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_HITLOCATION,
        vSpawnOrigin = pos
    }
    ProjectileManager:CreateTrackingProjectile( info )
end

function LinearMissileSetCustomSpawn(event)
    --DeepPrintTable(event)
    if event.caster then
        event.caster.customMissileSpawn = event.target
    end
end

function LinearMissileCustomSpawn(event)
    local caster = event.caster
    if caster and not caster:IsNull() and caster:IsAlive() and caster.customMissileSpawn and not caster.customMissileSpawn:IsNull() and caster.customMissileSpawn:IsAlive() and caster.customMissileSpawn ~= event.target then
        local origin = caster.customMissileSpawn:GetAbsOrigin()
        local targetpos = (event.target:GetAbsOrigin()-origin):Normalized()
        --A Liner Projectile must have a table with projectile info
        local info = 
        {
            Ability = event.ability,
            EffectName = event.EffectName,
            vSpawnOrigin = origin,--caster:GetAbsOrigin(),--origin,
            fDistance = 3000,
            fStartRadius = 100,
            fEndRadius = 100,
            Source = caster,
            bHasFrontalCone = false,
            bReplaceExisting = false,
            iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
            iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
            iUnitTargetType = DOTA_UNIT_TARGET_HERO,
            fExpireTime = GameRules:GetGameTime() + 60.0,
            bDeleteOnHit = false,
            vVelocity = targetpos * event.speed,
            bProvidesVision = true,
            iVisionRadius = 1000,
            iVisionTeamNumber = caster:GetTeamNumber()
        }
        local projectile = ProjectileManager:CreateLinearProjectile(info)
    end
end

function ForwardPosition(event)
    local caster = event.caster
    local target = event.target
    caster.eyebeamdummy = target
    local pos = caster:GetAbsOrigin() + caster:GetForwardVector()*event.range
    target:SetAbsOrigin(pos)
end

function EyeBeamPosUpdate(event)
    local caster = event.caster
    local target = caster.eyebeamdummy
    if target and not target:IsNull() then
        local pos = caster:GetAbsOrigin() + caster:GetForwardVector()*event.range
        target:SetAbsOrigin(pos)
        if caster.eyebeamdummyfx then
            local height = 137
            if caster:HasModifier("modifier_metamorph_dh") then
                height = 167
            end
            ParticleManager:SetParticleControl(caster.eyebeamdummyfx, 0, caster:GetAbsOrigin()+Vector(0,0,height))
            ParticleManager:SetParticleControl(caster.eyebeamdummyfx, 1, target:GetAbsOrigin()+Vector(0,0,100))
        end
    end
end

function EyeBeamFX(event)
    local caster = event.caster
    local target = caster.eyebeamdummy
    if target and not target:IsNull() then
        local particle = ParticleManager:CreateParticle("particles/eye_beam_2.vpcf", PATTACH_ABSORIGIN, target)
        caster.eyebeamdummyfx = particle
        --ParticleManager:SetParticleControlEnt(particle, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin()+Vector(0,0,100), true)
        --ParticleManager:SetParticleControlEnt(particle, 1, target, PATTACH_POINT_FOLLOW, "attach_origin", target:GetAbsOrigin()+Vector(0,0,200), true)
        ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,137))
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin()+Vector(0,0,100))
        --ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin()+Vector(0,0,200))
    end
end

function JumpToTarget(event)
    local caster = event.caster
    local target = event.target
    local condition = event.condition

    if condition and condition == 1 then
        local offset = target:GetForwardVector():Normalized()*95
        offset = Vector(offset[1], offset[2],0)
        caster:SetAbsOrigin(target:GetAbsOrigin()-offset)
        local tab = {}
        tab.Duration = 0.2
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_phased", tab)
        EmitSoundOn("Hero_PhantomAssassin.PreAttack", caster)
    end
end

function ShapeshiftDHEnd(event)
    local caster = event.caster
    -- to human
    --model change
    if COverthrowGameMode.EnableShapeshift == 1 then
        --local model = "models/heroes/antimage/antimage.vmdl"
        caster:SetOriginalModel(caster.old_model)
        caster:SetModelScale(1.0)
        ShowWearables(event)
        StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nevermore/nevermore_wings_dust_hit.vpcf", PATTACH_ABSORIGIN, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        COverthrowGameMode:EquipArtifactCosmeticRewardsGlobal(caster)
        caster.has_shapeshift_effect = nil
    end
end

function ShapeshiftDH(event)
    local caster = event.caster

    --to meta
    --model change, only when synced
    if COverthrowGameMode.EnableShapeshift == 1 and not caster.has_shapeshift_effect then
        COverthrowGameMode:RemoveAllCosmeticsGlobal(caster)
        local model = "models/items/terrorblade/marauders_demon/marauders_demon.vmdl"
        if caster.cosmetic_reward_head then
            model = "models/items/terrorblade/dotapit_s3_fallen_light_metamorphosis/dotapit_s3_fallen_light_metamorphosis.vmdl"
        end
        local scale = 0.8
        caster.old_model = caster:GetModelName()
        caster:SetOriginalModel(model)
        caster:SetModelScale(scale)
        HideWearables(event)
        StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
        caster.has_shapeshift_effect = true
    end
end

function ShapeshiftTerror(event)
    local caster = event.caster

    --to meta
    --model change, only when synced
    if COverthrowGameMode.EnableShapeshift == 1 and not caster.has_shapeshift_effect then
        COverthrowGameMode:RemoveAllCosmeticsGlobal(caster)
        local model = "models/items/terrorblade/knight_of_foulfell_demon/knight_of_foulfell_demon.vmdl"
        local scale = 1
        caster.old_model = caster:GetModelName()
        caster:SetOriginalModel(model)
        caster:SetModelScale(scale)
        HideWearables(event)
        StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
        caster.has_shapeshift_effect = true
    end
end

function ShapeshiftTerrorEnd(event)
    local caster = event.caster
    -- to human
    --model change
    if COverthrowGameMode.EnableShapeshift == 1 then
        --local model = "models/heroes/terrorblade/terrorblade.vmdl"
        caster:SetOriginalModel(caster.old_model)
        caster:SetModelScale(1.05)
        ShowWearables(event)
        StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nevermore/nevermore_wings_dust_hit.vpcf", PATTACH_ABSORIGIN, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        COverthrowGameMode:EquipArtifactCosmeticRewardsGlobal(caster)
        caster.has_shapeshift_effect = nil
    end
end

function StandStill(event)
    local caster = event.caster
    if caster:IsMoving() then
        caster.standsstill = 0
    else
        if caster.standsstill then
            caster.standsstill = caster.standsstill + 1
            if caster.standsstill == 5 then --and caster.standsstill % 3 == 1 then
                local particle = ParticleManager:CreateParticle("particles/moon_light.vpcf", PATTACH_ABSORIGIN, caster)
                ParticleManager:SetParticleControlEnt(particle, 2, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
                ParticleManager:ReleaseParticleIndex(particle)
            end
        else
            caster.standsstill = 1
        end
    end
    if caster.standsstill and caster.standsstill > 0 and caster.combat_system_ability then
        local standsstill = caster.standsstill
        if standsstill > 5 then
            standsstill = 5
        end
        caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_careful_aim", {Duration = -1})
        caster:SetModifierStackCount("modifier_careful_aim", caster.combat_system_ability, standsstill)
    else
        caster:RemoveModifierByName("modifier_careful_aim")
    end
end

function TalentArmorMinus(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    for i=1, caster.talents[43] do
        local myevent = { caster = caster, target = target, dur = 2.5, buff = "modifier_aa_minus_armordebuff", ability = ability}
        ApplyBuff(myevent)
    end
end

function GetRuneWordValue(rune1, rune2, rune3, weight)
    if rune1 < 1 or rune2 < 1 or rune3 < 1 then
        return 0
    end
    local number = (rune1 + rune2 + rune3) * weight

    if number <= 0 then
        return 0
    end
    if number < 1.0 then
        return 1
    end
    return math.floor(number + 0.5)
end

function GetStrengthPercentageBonus( hero, primary_stats_percent_bonus )
    local strPerLevel = 0.05
    if hero:HasModifier("modifier_crowndefender") or hero:HasModifier("modifier_crowndefender2") then
        strPerLevel = 0.075
    end
    local percent_bonus = strPerLevel * hero.talents[1] + 0.04 * hero.talents[38] + 0.03 * hero.talents[76]
    if hero:GetPrimaryAttribute() == 0 then
        percent_bonus = percent_bonus + primary_stats_percent_bonus
    end
    if hero:HasModifier("modifier_temple_battlestance") then
        percent_bonus = percent_bonus + 0.3
    end
    if hero:HasModifier("modifier_wild_swipe") then
        percent_bonus = percent_bonus + 0.25
    end
    if hero:HasModifier("modifier_brute_force") then
        percent_bonus = percent_bonus + 0.5
    end
    local froststr = hero:GetModifierStackCount("modifier_froststr", nil)
    if froststr > 0 then
        percent_bonus = percent_bonus + 0.05 * froststr
    end
    if hero.demonhunter then
        percent_bonus = percent_bonus + 0.1
    end
    local ghost3 = hero:FindAbilityByName("Ghost3")
    if ghost3 and ghost3:GetLevel() >= 4 then
        percent_bonus = percent_bonus + 0.25
    end
    ghost3 = hero:FindAbilityByName("Switch_Battle_Stance")
    if ghost3 and ghost3:GetLevel() >= 2 then
        percent_bonus = percent_bonus + 0.2
    end
    ghost3 = hero:FindAbilityByName("Shadowfury")
    if ghost3 and ghost3:GetLevel() >= 2 then
        percent_bonus = percent_bonus + 0.5
    end
    return percent_bonus
end

function GetAgilityPercentageBonus( hero, primary_stats_percent_bonus )
    local agiPerLevel = 0.05
    if hero:HasModifier("modifier_summon") or hero:HasModifier("modifier_summon2") then
        agiPerLevel = 0.075
    end
    local percent_bonus = agiPerLevel * hero.talents[13] + 0.04 * hero.talents[38] + 0.03 * hero.talents[76]
    if hero:GetPrimaryAttribute() == 1 then
        percent_bonus = percent_bonus + primary_stats_percent_bonus
    end
    local hawk5 = hero:FindAbilityByName("hawk7")
    if hawk5 and hawk5:GetLevel() >= 4 then
        percent_bonus = percent_bonus + 0.25
    end
    if hero:HasModifier("modifier_wild_swipe") then
        percent_bonus = percent_bonus + 0.25
    end
    local bear6 = hero:FindAbilityByName("bear6")
    if bear6 and bear6:GetLevel() >= 4 then
        percent_bonus = percent_bonus + 0.25
    end
    local feral1 = hero:GetModifierStackCount("modifier_furycat", nil)
    if feral1 > 0 and hero:HasModifier("modifier_npc_dota_hero_dazzle") then
        percent_bonus = percent_bonus + 0.2 * feral1
    end
    if hero.agility_bonus_100 and hero.agility_bonus_100 > 0 then
        percent_bonus = percent_bonus + 0.5
    end
    if hero:HasModifier("modifier_class_bounty2") and hero:GetName() == "npc_dota_hero_bounty_hunter" then
        local bonusfromms = hero:GetMoveSpeedModifier(hero:GetBaseMoveSpeed(), true) - 350
        if bonusfromms > 0 then
            percent_bonus = percent_bonus + 0.01 * bonusfromms
        end
    end
    return percent_bonus * GetAgilityPercentageBonusEffectiveness(hero)
end

function GetAgilityPercentageBonusEffectiveness(hero)
    return 1 + 0.01 * GetEyeOfTheTigerStat(hero)
end

function GetIntellectPercentageBonus( hero, primary_stats_percent_bonus )
    local intPerLevel = 0.05
    if hero:HasModifier("modifier_crown3") or hero:HasModifier("modifier_crown2") then
        intPerLevel = 0.075
    end
    local percent_bonus = intPerLevel * hero.talents[25] + 0.03 * hero.talents[76]
    if hero:GetPrimaryAttribute() == 2 then
        percent_bonus = percent_bonus + primary_stats_percent_bonus
    end
    local ghost2 = hero:FindAbilityByName("Ghost2")
    if ghost2 and ghost2:GetLevel() >= 3 then
        percent_bonus = percent_bonus + 0.25
    end
    if hero:HasModifier("modifier_wandwisdom") then
        percent_bonus = percent_bonus + 1
    end
    return percent_bonus 
end

function GetAttackDamageStaticBonus( hero, realAttackSpeed, realStrength, maxHealth )
    local static_bonus = hero.runeword[6]
    if hero.talents[2] and hero.talents[2] > 0 then
        static_bonus = static_bonus + hero.talents[2] * 25
    end
    if hero.talents[118] and hero.talents[118] > 0 then
        local factor = 0.005 + 0.005 * hero.talents[118]
        if hero:HasModifier("modifier_moltengiant") then
            factor = factor * 2
        end
        static_bonus = static_bonus + factor * maxHealth
    end
    --if hero.talents[7] and hero.talents[7] > 0 then
    --    static_bonus = static_bonus + (hero.talents[7] * 0.05 + 0.05) * realStrength
    --end
    local unholyFrenzy = hero:GetModifierStackCount("modifier_unholyfrenzy", nil)
    if unholyFrenzy >= 1 then
        static_bonus = static_bonus + unholyFrenzy * 5 * hero.talents[98]
    end
    if hero.talents[80] and hero.talents[80] > 0 then
        local bonusfromas = (realAttackSpeed - 500) * hero.talents[80] --50 * (hero:GetIncreasedAttackSpeed() - 5) * hero.talents[80]
        --print(realAttackSpeed)
        --print(bonusfromas)
        if bonusfromas > 0 then
            static_bonus = static_bonus + bonusfromas
        end
    end
    --if hero:HasModifier("modifier_companion") and hero:HasModifier("modifier_item_hunterbow2") then
    --    static_bonus = static_bonus + 150
    --end
    return static_bonus
end

function GetAttackDamagePercentageBonus( hero, healthPercentFactor )
    local percent_bonus = (healthPercentFactor - 1) * GetMountainGiantStat(hero) * 0.01
    if hero:HasModifier("modifier_item_item_set_t4_aa_4") then
        percent_bonus = percent_bonus + 0.1
    end
    percent_bonus = percent_bonus + 0.025 * hero:GetModifierStackCount("modifier_dfury", nil)
    if hero:HasModifier("modifier_retri_crit") then
        percent_bonus = percent_bonus + 1
    end
    if hero:HasModifier("modifier_lichking") then
        percent_bonus = percent_bonus + 0.5
    end
    if hero.talents[78] and hero.talents[78] > 0 then
        percent_bonus = percent_bonus + 0.03 * hero.talents[78]
    end
    if hero:HasModifier("modifier_pala_str_bonus_check") then
        percent_bonus = percent_bonus + 1
    end
    if hero:HasModifier("modifier_temple_furystance") then
        percent_bonus = percent_bonus + 0.25
    end
    local fury5 = hero:FindAbilityByName("fury5")
    if fury5 and fury5:GetLevel() >= 4 then
        percent_bonus = percent_bonus + 0.5
    end
    local fury6 = hero:FindAbilityByName("fury6")
    if fury6 and fury6:GetLevel() >= 4 then
        percent_bonus = percent_bonus + 0.5
    end
    local wind5 = hero:FindAbilityByName("wind5")
    if wind5 and wind5:GetLevel() >= 2 then
        percent_bonus = percent_bonus + 0.2
    end
    if hero:HasModifier("modifier_temple_brawler_titan") then
        percent_bonus = percent_bonus + 0.25
    end
    if hero:HasModifier("modifier_beastrage") then
        local beast4 = hero:FindAbilityByName("Beastrage")
        if beast4 and beast4:GetLevel() <= 2 then
            percent_bonus = percent_bonus + 0.2
        else
            percent_bonus = percent_bonus + 0.4
        end
    end
    percent_bonus = percent_bonus + 0.1 * hero.talents[18]
    return percent_bonus
end

function GetArmorStaticBonus( hero, strength, agility, mana, magicres )
    local static_bonus = hero.runeword[3] + hero.talents[10]
    local ability = hero:FindAbilityByName("pala5")
    if ability and ability:GetLevel() >= 4 then
        static_bonus = static_bonus + agility * 0.02
    end
    if hero:HasModifier("modifier_class_sanct2") and hero:GetName() == "npc_dota_hero_phantom_lancer" then
        static_bonus = static_bonus + 50 * magicres
    end
    if hero.talents[33] and hero.talents[33] > 0 and not hero.resourcesystem then
        local ms = hero.talents[33] * mana / 500
        if ms > 30 then
            ms = 30
        end
        static_bonus = static_bonus + ms
    end
    if hero.talents[4] and hero.talents[4] > 0 and hero:GetPrimaryAttribute() == 0 then
        static_bonus = static_bonus + 1 * hero.talents[4]
    end
    if hero.talents[91] and hero.talents[91] > 0 then
        static_bonus = static_bonus + 1 * hero.talents[91]
    end
    if hero.talents[139] and hero.talents[139] > 0 then
        static_bonus = static_bonus + CountAbilitiesWithLevel(hero, 2) * 3 * hero.talents[139]
    end
    if hero.talents[116] and hero.talents[116] > 0 then
        local value = hero.talents[116] * 0.00333 * GetAgilityCustom(hero)
        if value > 30 then
            value = 30
        end
        static_bonus = static_bonus + value
    end
    --if hero:HasModifier("modifier_deathchill") then
    --    static_bonus = static_bonus + 3 * hero.talents[104]
    --end
    if hero.talents[19] and hero.talents[19] > 0 then
        local bonusPerLevel = 0.15
        if not hero:IsRangedAttacker() then
            bonusPerLevel = bonusPerLevel * 1.25
        end
        static_bonus = static_bonus + 0.04 * bonusPerLevel * hero.talents[19] * agility
    end
    if hero.talents[112] and hero.talents[112] > 0 then
        local barkSkinArmor = 0.01334 * hero.talents[112] * strength
        if barkSkinArmor > 25 then
            barkSkinArmor = 25
        end
        static_bonus = static_bonus + barkSkinArmor
    end
    local stoneskinStacks = hero:GetModifierStackCount("modifier_stoneskin", nil)
    if stoneskinStacks >= 1 then
        static_bonus = static_bonus + stoneskinStacks * hero.talents[109]
    end
    if hero.nearby_enemies and hero.talents[85] and hero.talents[85] > 0 then
        local glaive_armor_factor = 1
        local enemy_count = hero.nearby_enemies
        local enemy_cap = 8
        if not hero:IsRangedAttacker() then
            enemy_cap = 12
        end
        if hero:HasModifier("modifier_pathbuff_085") then
            glaive_armor_factor = 2
        end
        static_bonus = static_bonus + 0.33 * hero.talents[85] * enemy_count * glaive_armor_factor
    end
    --print(static_bonus)
    return static_bonus
end

function GetArmorPercentageBonus( hero, strengthPercentFactor )
    local percent_bonus = (strengthPercentFactor - 1) * 0.01 * GetChivalryStat(hero)
    if hero.talents[4] > 0 then
        percent_bonus = percent_bonus + 0.025 + 0.025 * hero.talents[4]
    end
    if hero:HasModifier("modifier_temple_defstance") then
        percent_bonus = percent_bonus + 0.5
    end
    if hero:HasModifier("modifier_ironshield") then
        percent_bonus = percent_bonus + 0.5
    end
    if hero.is_warrior then
        percent_bonus = percent_bonus + 0.15
    end
    if GetLevelOfAbility(hero, "mars4") >= 3 then
        percent_bonus = percent_bonus + 0.2
    end
    if hero:HasModifier("modifier_brute_force") then
        percent_bonus = percent_bonus + 0.5
    end
    return percent_bonus
end

function GetManaPercentageBonus( hero )
    local percent_bonus = hero.talents[34] * 0.1
    if hero:HasModifier("modifier_nether_explosion_buff") then
        percent_bonus = percent_bonus + 0.5
    end
    local holy6 = hero:FindAbilityByName("holy6")
    if holy6 and holy6:GetLevel() >= 3 then
        percent_bonus = percent_bonus + 0.25
    end
    return percent_bonus
end

function GetAttackSpeedBonus( hero, armor, strength, agility )
    local static_bonus = 0
    if agility >= 1 then
        static_bonus = static_bonus + 0.05 * agility
    end
    local frostdk6 = hero:FindAbilityByName("frostdk6")
    if frostdk6 and frostdk6:GetLevel() >= 4 then
        static_bonus = static_bonus + armor * 5
    end
    frostdk6 = hero:FindAbilityByName("rogue1")
    if frostdk6 and frostdk6:GetLevel() >= 2 then
        static_bonus = static_bonus + agility * 0.1
    end
    if hero.attackspeed_system_bonus and hero.attackspeed_system_bonus > 0 then
        static_bonus = static_bonus + hero.attackspeed_system_bonus
    end
    if hero:HasModifier("modifier_class_am") and hero:HasModifier("modifier_asfury") then
        static_bonus = static_bonus + strength
    end
    local buffstacks = hero:GetModifierStackCount("modifier_frostmourne", nil)
    if buffstacks >= 1 then
        static_bonus = static_bonus + buffstacks * hero.talents[92]
    end
    if hero.talents[80] and hero.talents[80] > 0 then
        static_bonus = static_bonus + 15 * hero.talents[80]
    end
    if hero.talents[119] and hero.talents[119] > 0 and hero.magicalResistance then
        local factor = 100
        if hero:HasModifier("modifier_stormgiant") then
            factor = factor * 2
        end
        static_bonus = static_bonus + hero.magicalResistance * hero.talents[119] * factor
    end
    if hero.talents[139] and hero.talents[139] > 0 then
        static_bonus = static_bonus + CountAbilitiesWithLevel(hero, 1) * 25 * hero.talents[139]
    end
    local value = hero.talents[15] * 30 + static_bonus
    return value
end

function GetHealthStaticBonus( hero, strength, agility, intellect, armor, magicres, maxMana )
    local static_bonus = 25 * (hero:GetLevel() - 1) + 200 --bugged, must use getherolevel here but would lead to op hp in lategame
    if hero.talents[120] and hero.talents[120] > 0 then
        static_bonus = static_bonus + 0.1 * hero.talents[120] * maxMana
    end
    if hero.talents[65] and hero.talents[65] > 0 then
        static_bonus = static_bonus + 250 * hero.talents[65]
    end
    if hero.talents[115] and hero.talents[115] > 0 then
        static_bonus = static_bonus + 1500 * hero.talents[115]
    end
    if hero.talents[14] and hero.talents[14] > 0 then
        if hero:IsRangedAttacker() then
            static_bonus = static_bonus + (0.5 + 0.5 * hero.talents[14]) * agility
        else
            static_bonus = static_bonus + (1.5 + 0.5 * hero.talents[14]) * agility
        end
    end
    if hero.talents[128] and hero.talents[128] > 0 then
        static_bonus = static_bonus + intellect * (0.5 + 0.5 * hero.talents[128])
    end
    if hero:HasModifier("modifier_pathbuff_084") then
        static_bonus = static_bonus + 1 * (strength + agility + intellect)
    end
    local bear4 = hero:FindAbilityByName("bear4")
    if bear4 and bear4:GetLevel() >= 3 and armor >= 1 then
        static_bonus = static_bonus + 35 * armor
    end
    local bear6 = hero:FindAbilityByName("bear6")
    if bear6 and bear6:GetLevel() >= 4 then
        static_bonus = static_bonus + agility * 3
    end
    bear6 = hero:FindAbilityByName("terror1")
    if bear6 and bear6:GetLevel() >= 3 then
        static_bonus = static_bonus + strength * 3
    end
    bear6 = GetLevelOfAbility(hero, "ench4")
    if bear6 >= 3 then
        static_bonus = static_bonus + GetHeroLevel(hero) * 25
    end
    if hero:HasModifier("modifier_inttohp2") then
        static_bonus = static_bonus + intellect * 7
    elseif hero:HasModifier("modifier_inttohp") then
        static_bonus = static_bonus + intellect * 5
    end
    return static_bonus
end

function GetHealthPercentageBonus( hero, armor, magicres )
    local percent_bonus = hero.talents[67] * 0.07 + GetGlobalHPAuraStat()
    if hero:HasModifier("modifier_item_item_set_t4_str_4") then
        percent_bonus = percent_bonus + 0.15
    end
    if hero:HasModifier("modifier_item_btshp2") then
        percent_bonus = percent_bonus + 0.1
    end
    if hero:HasModifier("modifier_divinedef") then
        percent_bonus = percent_bonus + 0.15
    end
    if hero:HasModifier("modifier_bloodbrother") then
        percent_bonus = percent_bonus + 0.25
    end
    if hero:HasModifier("modifier_class_ds2") then
        percent_bonus = percent_bonus + 0.1
    end
    if HeroHasNeutralItem(hero, "item_neutral_3") then
        percent_bonus = percent_bonus + 0.2
    end
    if HeroHasNeutralItem(hero, "item_neutral_37") then
        percent_bonus = percent_bonus + 0.1
    end
    if hero:HasModifier("modifier_demon_form") then
        percent_bonus = percent_bonus + 1
    end
    if hero:HasModifier("modifier_voidhp") then
        percent_bonus = percent_bonus + 0.2
    end
    if hero:HasModifier("modifier_pathbuff_117") then
        percent_bonus = percent_bonus + 0.1
    end
    if hero.talents[51] and hero.talents[51] > 0 and magicres >= 0.7 and armor >= 46 then
        percent_bonus = percent_bonus + hero.talents[51] * 0.1
    end
    if hero.inMonkeyKingForm then
        percent_bonus = percent_bonus + 0.01 * armor
    end
    if hero.talents[9] and hero.talents[9] > 0 then
        percent_bonus = percent_bonus + hero.talents[9] * 0.03 + 0.01
    end
    local beast6 = hero:FindAbilityByName("Bear")
    if beast6 and beast6:GetLevel() >= 4 then
        percent_bonus = percent_bonus + 0.25 * GetCompanionAndPetCount(hero)
    end
    local bear2 = hero:FindAbilityByName("bear2")
    if bear2 and bear2:GetLevel() >= 4 then
        percent_bonus = percent_bonus + 0.2
    end
    if hero:HasModifier("modifier_fanatism_2") and hero:HasModifier("modifier_class_sanctified") then
        percent_bonus = percent_bonus + 1
    end
    local mythicHP = hero:GetModifierStackCount("modifier_mythic_mhp", nil)
    percent_bonus = percent_bonus + 0.01 * (mythicHP + hero:GetModifierStackCount("modifier_growingpains", nil))
    return percent_bonus
end

function GetAutoAttackDamageStaticBonus( hero, str, agi, int )
    local value = hero.talents[18] * 50 + hero.talents[146] * 0.2 * agi + hero.talents[12] * 0.25 * str
    if hero:HasModifier("modifier_dominance") then
        value = value + hero.talents[84] * 0.25 * (str + agi + int)
    end
    return value
end

function GetAutoAttackDamagePercentBonus( hero )
    local value = hero.talents[49] * 0.25 + hero.talents[120] * 0.1
    if hero:HasModifier("modifier_furycharge") then
        value = value + 1
    end
    if hero:HasModifier("modifier_item_needleaa") then
        value = value + 0.25
    end
    if hero:HasModifier("modifier_aaa2") then
        value = value + 0.25
    end
    if hero:HasModifier("modifier_crusader_mount") then
        value = value + 0.5
    end
    if hero:HasModifier("modifier_cloakitem") then
        value = value + 0.25
    end
    --local ability = hero:FindAbilityByName("rogue1")
    --if ability and ability:GetLevel() >= 4 then
    --    value = value + 0.25
    --end
    if hero:HasModifier("modifier_exorcism_aura") then
        local ability = hero:FindAbilityByName("Retri5")
        if ability and ability:GetLevel() >= 3 then
            value = value + 0.5
        end
    end
    if hero:HasModifier("modifier_pala_dmg") then
        value = value + 0.3
    end
    if hero:HasModifier("modifier_lightningfury") then
        local ability = hero:FindAbilityByName("Ghost1")
        if ability and ability:GetLevel() >= 3 then
            value = value + 2
        end
    end
    local buffstacks = hero:GetModifierStackCount("modifier_abil_bonus_5_percent", nil)
    if buffstacks >= 1 then
        value = value + 0.2 * buffstacks
    end
    buffstacks = hero:GetModifierStackCount("modifier_crowfall", nil)
    if buffstacks >= 1 then
        value = value + 0.02 * buffstacks
    end
    return value
end

function GetStatBuffByAttribute( Attribute )
    if Attribute == STR then
        return "modifier_str_custom"
    end
    if Attribute == AGI then
        return "modifier_agi_custom"
    end
    if Attribute == INT then
        return "modifier_int_custom"
    end
    if Attribute == AA then
        return "modifier_attackdamage"
    end
    if Attribute == AS then
        return "modifier_attackspeed"
    end
    if Attribute == HP then
        return "modifier_hp_custom"
    end
    if Attribute == MANA then
        return "modifier_mana_custom"
    end
    if Attribute == ARM then
        return "modifier_armor"
    end
    if Attribute == AAA then
        return "modifier_autoattackdamage"
    end
end
--[[
COverthrowGameMode.PathStatistics = {
    "000000000000010000000000000000000000030003300003000000000003000000000000000003030300000000030000000000000003030030003030",
"003003000000000000000000223300003000003002000000000000001000003000000000000300030003300300000000000000000000000000000000",
"303030000300300300200000000000000000030200000000003000000000303030300000003000000000000000000000000000000000000000000000",
"000000000000030300000000303000032030301011030023000000300303000000000000000000000000000000000000000000000000000000000000",
"no",
"030000000000030030100000030000000000030201003010000000000000300003030033303000000000000000000000000000000000000000000000",
"030003202200000000000000210030300021300001000000200000010000330030000030000000000000000000000000000000000000000000000000",
"030030003003000000000000330000003030300001000000000000300000300000000000000000000000000000000000000000000003003030000000",
"303030000300210300000000003000000000021001000000003000000000303030300000003000000000000000000000000000000",
"000000000000210300003000313000101030231001003020000000300003300000000000000000000000000000000000000000000001000000000000",
"303030000330030300300000000000000000021001000000000000000000303030300000003000000000000000000000000000000",
"000000000000030300000000310003002030301001000000000000301000300000000000000000000000000000000000000000000003033020030000",
"000000000000030300000000313300333330201031000000000000011000003000000000000000000000000000",
"000000000000000000000000030300033300000000000000000000001000000000000000000000000000000000303030000030000300300300300003",
"003030000000000000000000333300003330000000000000000000001000000000000000000300030003300300000000000000000000000000000000",
"303030000300230000000000003000000000030301000000003000000000300030300000000000000000000000002000000000000000000000000000",
"000000000000210300000000313000303030301001000000000000301000300000000000000000000000000000000000000000000003030030000000",
"303030000300330300300000003000000000031001000000002000000000300030300000000000000000000000000000000000000000000000000000",
"030030300000210300000000000000000000030003030030000000000003000000000000000003030003103000010000000000000000000000000000",
"003003000000000000000000333300031000003001000000000000001000000000000000000300030033000300",
"no",
"000000000000000000000000033300030030030021000000000000031000000000000000000000000000000000303000300030001003300000000000",
"303030000300210300300000000000000000031300000000003000000000300030300000000300000000000000",
"000000000000010000000000030300333300030001000000000000021000000000000000000300030003300302000000000000000000000000000000",
"330000203303210300003000000000000000031001000000000000000000300300300003000000000000000000000000000000000000000000000000",
"000000000000030300000000300300001000003001000000000000000000000000000000000300030033000300303030000030000000000000000000",
"303030000330000000000000003000000000030001000000003000000000303000300000000000000000000000000000000000000300300300000000",
"300030033300000000000000000000000000000000000000000000000000303000330000033030003003100000000000000000000000000000000000",
"201003000000030030000000210300003000021001000000000000000000003000000000000300030033000300000000000000000000000000000000",
"201003000000000000000000003300000000003001000000000000000000000000000000000300030033000300303030000030000000000000000000",
"003003000000030000000000012300033000000000000000000000031000000000000000000300030033000303000000000000000000000000000000",
"303030000300330000300001003000000000030001000000003000000000300030300030000000000000000000000000000000000000000000000000",
"030000000000000000000000303000331330300033030000000000300303000000000000000000000000000000000000000000000000000000000000",
"003000000000030300000000313300031000003001000000000000011000000000000000000300030033000300000000000000000000000000000000",
"303030000300310300300000003000000000031301000000003000000000300030100000000000000000000000000000000000000000000000000000",
"020000000000030300000000303000031030301011003030000000301303000000000000000000000000000000000000000000000000000000000000",
"000000000000003000000000000000000000030003300003000000000003000000000000000003030000000000000000000000000030030000000000",
"000000000000030300003000303000033230301031003010000000300003000000000000000000000000000000000000000000000000000000000000",
"003003000000000000000000223100033000003001000000000000001000000000000000000300030033000303000000000000000000000000000000",
"000000000000000000000000302200131230300021013013000000001303000000000000000000000000000000000000000000000003030000000000",
"000000000000210210003301000000000000021001000000000000000000000000000000000300003300030200300000000000000033030000000000",
"103003000000003030000000003300033000000000000000000000001000003000000000000300030033000300000000000000000000000000000000",
"303030000300010000000000000000000000030001000000001000000000300030300030003000000000000000303002100010000",
"303030000330030000000000000000000000030301000000003000000000003030300030000000000000000000300000000000000000000000000000",
"201002000000000000000000030300003300003002000000000000031000000000000000000300030033000303000000000000000100000000000000",
"300030003303000000000000000000000000000000000000003000000000000000000000000000000000000000003300300200000000000000000000",
"003000000000010000000000023300033100013001000000000000011000030000000000000300030033000200000000000000000000000000000000",
"000000000000003003000000000000000000003012300000000000000000000000000000000003030300001000030000000000000003030000000000",
"000000000000300300000000330000333310030001000000000000001000300000000000000000000000000000303000300010000000000000000000",
"201003000000000000000000030300033000003002000000000000011000000000000000000300030033000303000000000000000000000000000000",
"003003000000012300000000312000003000021001000000000000000000003000000000000130030013100300000000000000000000000000000000",
"003000000000030300000000303300003330003003000000000000031000003000000000000300000000000000",
"000000000000000000000000300210031033000000000000000000301000030303000303300000000000000000000000000000000032000000000000",
"330000203303210300003000000000000000031001000000000000000000300300300003000000000000000000000000000000000000000000000000",
"003000000000000000000000333200233000003003000000000000001000003000000000000300000000000000300000000000000030000000000000",
"003000000000003300010000030300033300003003000000000000003000000000000000000000000000000000300000000000000300003000000000",
"303030000320010000000000000000000000030301000000003000000000300030300000000000000000000000000000000000000300300300000000",
"003030000000010000000000031300033000000000000000000000011000003000000000000300030033000300300000000000000000000000000000",
"303003000300000000000000030300013000003003000000000000000000000000000000000300030033000300000000000000000000000000000000",
"303030000330010000000000003300000000030321000000003000000000000000000000000000000000000000000000000000000300300300000000",
"000000000000030000000000030300303300003001000000000000021000000000000000000300030003300303000000000000000000000000000000",
"303030000330000000000000001000000000030301000000000000000000300030100000000000000000000000000000000000000330000300000000",
"000000000000300330000030312000003000030001000000000000000000300000000000000000000000000000001000000000000003032030003000",
"030030303003030330000003000000000000001000000000000010000000000000000000000003003003003000030000000000000000000000000000",
"000000000000000000000000030300031000000000000000000000000000033000003003000030300032100300000000000000000003003000000000",
"030030303300010000000000110000000000030001000000000000000000300000000000000300003003003000000000000000000030003000000000",
"303030000330030300100000000000000000030201000000003000000000300000000000000000000000000000000000000000000030300300000000",
"300130333300000000000000000000000000000000000000303000000000000000000000000000000000000000000000000000000003033030003030",
"000000000000000000000000000000000000000000000000000000000000000000000000000003033210003233030000000000000033003000003330",
"301020102100000000000000000000000000000000000000000000000000300000000000000003030300003030000000000000000003030300030030",
"000000000000300030000000000000000000030201003030000000000003300003030033303000000000000000000000000000000001000000000000",
"003003000000000000000000303300033000033013000000000000030000303000000000000000000000000000000000000000000000000000000000",
"030030300000210300000000300000000000021001000000000000000000300000000000000030003003003000000000000000000003003000000000",
"303030000300210300300001000000000000031101000000003000000000300030300030000000000000000000",
"303003000300001000000000030300003000000000000000000000000000003000000000000300030033000303000000000000000000000000000000",
"301030033303010000000000000000000000331301000000003000000000300000000000000300000000000000300000000000000000000000000000",
"no",
"003003000000000000000000330300033000000000000000000000031000000000000000000030030023100303000000000000000000000000000000",
"300030030300010000000000000000000000030003003000300000000000300033300030300000000000000000000000000000000000000000000000",
"003000000000003310000000033300030300003032000000000000031000000000000000000000000000000000000000000000000030003000000000",
"303030000300010000000000002000000000030321000000003000000000003030300030103000000000000000001000000000000000000000000000",
"000000000000001000000000320000000000030030000000000000000000330000300033030000000000000000000000000000000000000000000000",
"no",
"000000000000030300001000303000032030301021030020000000301003000000000000000030000000000000000000000000000000000000000000",
"300030331303000000000000003000000000030012030030303000000300000000000000000000000000000000000000000000000000000000000000",
"000000000000003300000000303300003330003001000000000000011000330003300000000000000000000000",
"030030303000210300000000000000000000201001000000000000000000300000000000000030003003103000000000000000000030003000000000",
"201003000000010000000000130300033100301001000000000000101000000000000000000300030033000300000000000000000000000000000000",
"303030000310310300300000000000000000031001000000000000000000303033000000003000000000000000000000000000000000000000000000",
"303030000330330000300000003000000000030301000000000000000000300030300000000000000000000000000000000000000000000000000000",
"000000000000030300000000303000030330301011030030000000301003000000000000000000000000000000000000000000000000000000000000",
"000000000000030030000000033300030300030001000000000000001000000000000000000300030033000300000000000000000",
"000000000000000000000000000000000000030012030030000000000032003300003000000000000000000000000000000000000033000030300300",
"000000000000120300002000313000101030131001003030000000311003300000000000000000000000000000000000000000000000000000000000",
"000000000000030203001003000000000000030201300003000300000303000000000000000003030100000000010000000000000",
"003003000000000000000000231300033000000000000000000000011000000000000000000300030033000303000000000000000000000000000000",
"103003000000000000000000033300003000030001000000000000011000000000000000000300030033000300003000000000000100000000000000",
"303030000300030300300001000000000000030300000000003000000000300030300000000000000000000000000000000000000300000000000000",
"030300003003330300000000000000000000301003003011300000000003000000000000000000000000000000000000000000000003003000000000",
"301020133303000000000000003000000000030012030030303000000300000000000000000000000000000000000000000000000000000000000000",
"003003000000000000000000033300033000003003000000000000001000000000000000000300030032100300000000000000000000000000000000",
"000000000000000000000000330000301321000000000000000000301000330030000033000000000000000000000000000000000003003030000000",
"000000000000000000000000000000000000300031030033000000000103001000000000000000000000000000000000000000000000000000000000",
"000000000000003300000000330300003000030001000000000000000000000000000000000300030030000000000000000000000200000000000000",
"300003000000000000000000313300003000003003000000000000001000000000000000000300030033000303000000000000000000000000000000",
"303030000300120200000000000000000000031301000000003000000000303030300000003000000000000000000000000000000000000000000000",
"000000000000030300000000203200002130201031000000000000111000030030300032000000000000000000",
"303030000330000000000000000000000000030301000000000000000000303000300000000000000000000000000000000000000300300300030000",
"301030011300010000000000000000000000030302001000003000000000300030300000000000000000000000000000000000000302010300000000",
"no",
"303030000300000000000000000000000000030301000000003000000000003030300030000000000000000000000000000000000300300300000000",
"000000000000030300000000303000332330300001000000000000310000000000000000000000000000000000000000000000000033030000000000",
"300120003303000000000000000000000000300000000000030000000000003030300030000000000000000000000000000000000000000000000000",
"000000000000000000000000030300003030021001000000000000001000000000000000000300000000000000303030000010000000000000000000",
"303030000300330000300000000000000000030302000000003000000000303030300000000000000000000000000000000000000000000000000000",
"003002000000000000000000300300000000003003000000000000000000000000000000000330000033000300000000000000000000000000000000",
"003003000000030300000000033300003000003001000000000000000000000000000000000300030003300300000000000000000",
"030030003300303003003000000000000000030001000000300100000000000000000000000003030000000000000000000000000000000000000000",
"003003000000000000000000033300003000021002000000000000011000000000000000000300030033000303000000000000000000000000000000",
"303003000300000000000000030300003030030001000000000000001000000000000000000300030003300300000000000000000000000000000000",
"000000000000000000000000333300000030033001000000000000000000000000000000000000000000000000000000000000000000000000000000",
"301030300303010000000000000000000000031003003000000000000000300300300000000000000000000000000000000000000000000000000000",
"000000000000330030000301000000000000031001000000000030000000303030000030000003003310000000010000000000000000000000000000",
"003000000000030030000000310300303100003000000000000000000000000000000000000300030033000300000000000000000111000000000000",
"000000000000210033000300000000000000030003030003000030000300000000000000000003003320000000010000000000000000000000000000",
"001000000000000000000000333300333000003000000000000000001000003000000000000300030033000300000000000000000000000000000000",
"000000000000000000000000003300001000003001000000000000000000003000000000000300030010000000000000000000000000000000000000",
"130000000000000000000000000000000000000000000000000000000000000000000000000030000000000000300300003300030000000000000000",
"300030030303000000000000000000000000000000000000203000000000300030300020000000000000000000000000000000000000000000000000",
"003003000000000000000000012300003300201001000000000000001000000000000000000300020000000000303030000030002100000000000000",
"303003000200000000000000030300033000000000000000000000001000000000000000000300030003300303000000000000000100000000000000",
"000000000000030300000000313000301030031101003030000000311003300000000000000000000000000000000000000000000000000000000000",
"303030000330000000000000000000000000030301000000003000000000003030300000000000000000000000000000000000000300300300000000",
"303030000330000000000000000000000000030301000000033000000000003030300000000000000000000000300000000000000300000000000000",
"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"003003000000000000000000030300033000000000000000000000001000003000000000000300030033000303000000000000000300000000000000",
"000000000000300330000030030300331030000000000000000000300000330000003030000000000000000000001000000000000000000000000000",
"301030003303000000000000000000000000030001000000003000000000303030300003003000000000000000000000000000000300000000000000",
"303030000300130000000000003000000000030001000000003000000000303030300000003000000000000000000000000000000000000000000000",
"000000000000000000000000330000303300300001000000000000001000300300030033300000000000000000000000000000000000000000000000"
}]]

function GetPathStatisticsAccumulated( pathList, normalizeToPercent )
    local statistics = {}
    local healthyEntries = 0
    for i = 1, COverthrowGameMode.maxtalents do
        statistics[i] = 0
    end
    for i=1, #pathList do
        local pathpoints = pathList[i]
        local pathpointslength = string.len(pathpoints)
        if pathpointslength >= 10 then
            healthyEntries = healthyEntries + 1
            for p=1, pathpointslength do
                statistics[p] = statistics[p] + tonumber(string.sub(pathpoints, p, p))
            end
        end
    end
    if normalizeToPercent and healthyEntries >= 1 then
        for i = 1, COverthrowGameMode.maxtalents do
            statistics[i] = math.floor(statistics[i] * 100 / (healthyEntries * 3))
        end
    end
    return statistics
end

function GetCastRangeBonus(hero)
    local bonus = GetInterstellarStat(hero)
    if not hero:IsRangedAttacker() then
        return 0
    end
    if hero:HasModifier("modifier_pathbuff_107") then
        bonus = bonus + 100
    end
    if hero:HasModifier("modifier_pathbuff_052") then
        bonus = bonus + 100
    end
    if hero:HasModifier("modifier_new3") then
        bonus = bonus + 200
    end
    if hero:HasModifier("modifier_new32") then
        bonus = bonus + 300
    end
    if hero:HasModifier("modifier_shadow_form_ds") and hero:HasModifier("modifier_class_ds2") then
        bonus = bonus + 450
    end
    if GetLevelOfAbility(hero, "special_bonus_unique_nether_wizard_6") >= 1 then
        bonus = bonus + 300
    end
    return bonus
end

function GetRequiredAttackRangeBonuses( hero )
    local bonus = GetInterstellarStat(hero)
    return bonus
end

function PassiveStatCalculation(event)
    --if COverthrowGameMode.CalculatedPathStatistics then
        --return
    --end
    --COverthrowGameMode:GamblingPressedButton(nil, {player_id = 0, item = 401})

    local hero = event.caster

    --fix staying at 0 health
    if hero:GetHealth() <= 0 then
        hero:SetHealth(1) --might work
    end

    local updateEveryXSecs = 1
    local ability = event.ability
    local dur = 10
    local isUpdateTickEvery5secs = false
    local isUpdateTickEvery10secs = false

    -- keeping track of current hp %, so that when changes to max HP occur, we can still keep same current hp %, by setting this again after all max hp changes were applied
    local hpPercent = hero:GetHealth() / hero:GetMaxHealth()
    if hero:GetGold() > 0 then
        hero:SetGold(0, true)
        hero:SetGold(0, false)
    end
    if hero.cheater then
        return
    end
    if not hero.PassiveStatCalculationCounter then
        hero.PassiveStatCalculationCounter = 0
    end
    hero.PassiveStatCalculationCounter = hero.PassiveStatCalculationCounter + 1
    if hero.PassiveStatCalculationCounter > 5 then
        hero.PassiveStatCalculationCounter = 1
        isUpdateTickEvery5secs = true
        if not hero.isUpdateTickEvery5secs then
            hero.isUpdateTickEvery5secs = true
        else
            hero.isUpdateTickEvery5secs = false
            isUpdateTickEvery10secs = true
        end
    end
    --mana regen
    SetManaRegeneration(hero, GetManaRegenerationPerSec(hero))
    CheckForMaxManaCap(hero)
    --mres
    local castRangeBonus = GetCastRangeBonus(hero)
    if castRangeBonus >= 1 then
        --event.ability:ApplyDataDrivenModifier(hero, hero, "modifier_castrange", {Duration = -1})
        --hero:RemoveModifierByName("modifier_item_aether_lens")
        hero:RemoveModifierByName("modifier_item_aether_lens")
        hero:AddNewModifier(hero, event.ability, "modifier_item_aether_lens", {duration = -1})
        event.ability:SetLevel(math.floor(castRangeBonus / 50))
        --hero:SetModifierStackCount("modifier_item_aether_lens", event.ability, castRangeBonus)
    else
        event.ability:SetLevel(0)
        hero:RemoveModifierByName("modifier_item_aether_lens")
    end
    local attackRangeBonusToApply = GetRequiredAttackRangeBonuses(hero) --this is not the actual total bonus, just some bonuses require a buff to be applied
    if attackRangeBonusToApply >= 1 then
        hero.combat_system_ability:ApplyDataDrivenModifier(hero, hero, "modifier_attack_range2", {Duration = updateEveryXSecs + 1})
        hero:SetModifierStackCount("modifier_attack_range2", hero.combat_system_ability, attackRangeBonusToApply)
    end
    local magicres = hero:Script_GetMagicalArmorValue(false, nil)
    --spelldamage
    hero.spellpower = GetSpellpower(event)
    if isUpdateTickEvery5secs then
        hero.lifeblood = 1
    end
    --first clear all stat buffs
    for i = 1, totalAttributes do
        local buff = GetStatBuffByAttribute(i)
        hero:RemoveModifierByName(buff)
    end
    --hero:RemoveModifierByName("modifier_int_custom")
    hero:RemoveModifierByName("modifier_int_custom_penalty")
    --hero:RemoveModifierByName("modifier_mana_from_custom_int")
    --hero:RemoveModifierByName("modifier_str_custom")
    --hero:RemoveModifierByName("modifier_agi_custom")
    hero:RemoveModifierByName("modifier_agi_custom_penalty")
    hero:RemoveModifierByName("modifier_str_custom_penalty")
    hero:RemoveModifierByName("modifier_armor_custom_penalty")
    --hero:RemoveModifierByName("modifier_dmg_from_primary")
    --hero:RemoveModifierByName("modifier_aa_from_abi")
    local system_aacrit_stacks = 0
    if hero:HasModifier("system_aacrit") then
        system_aacrit_stacks = hero:GetModifierStackCount("system_aacrit", nil)
        hero:RemoveModifierByName("system_aacrit")
    end

    --rune words
    local fah = hero:GetModifierStackCount("modifier_runeword_fah", nil)
    local loo = hero:GetModifierStackCount("modifier_runeword_loo", nil)
    local wii = hero:GetModifierStackCount("modifier_runeword_wii", nil)
    local sin = hero:GetModifierStackCount("modifier_runeword_sin", nil) --new
    local tal = hero:GetModifierStackCount("modifier_runeword_tal", nil)
    local nah = hero:GetModifierStackCount("modifier_runeword_nah", nil)
    local ser = hero:GetModifierStackCount("modifier_runeword_ser", nil)
    local roh = hero:GetModifierStackCount("modifier_runeword_roh", nil)
    local time = hero:GetModifierStackCount("modifier_runeword_mine", nil)
    local tic = hero:GetModifierStackCount("modifier_runeword_tic", nil)
    local kil = hero:GetModifierStackCount("modifier_runeword_kil", nil)

    --fah = 10
    --nah = 10
    --kil = 10

    local assumed_max_runeword_value = 75 --pre ancient, now rather 75+, 350 abil4dmg is possible
    if not hero.runeword then
        hero.runeword = {}
    end
    hero.runeword[1] = GetRuneWordValue(  loo , nah , time, 500 / assumed_max_runeword_value )
    hero.runeword[2] = GetRuneWordValue(  wii , ser , time, 500/ assumed_max_runeword_value )
    hero.runeword[3] = GetRuneWordValue(  wii , tal , time, 50/ assumed_max_runeword_value )
    hero.runeword[4] = GetRuneWordValue(  wii , tal , tic, 50/ assumed_max_runeword_value )
    if hero.runeword[4] > 50 then
        hero.runeword[4] = 50
    end
    hero.runeword[5] = GetRuneWordValue(  fah , tal , time, 500 / assumed_max_runeword_value )
    hero.runeword[6] = GetRuneWordValue(  fah , nah , tic, 1000 / assumed_max_runeword_value )
    hero.runeword[7] = GetRuneWordValue(  fah , ser , time, 750 / assumed_max_runeword_value )
    hero.runeword[8] = GetRuneWordValue(  fah , tal , kil, 6 / assumed_max_runeword_value )
    hero.runeword[9] = GetRuneWordValue(  loo , nah , kil, 4 / assumed_max_runeword_value )
    hero.runeword[10] = GetRuneWordValue(  wii , nah , kil, 6 / assumed_max_runeword_value )
    hero.runeword[11] = GetRuneWordValue(  loo , ser , time, 5 / assumed_max_runeword_value )
    hero.runeword[12] = GetRuneWordValue(  fah , tal , tic, 7 / assumed_max_runeword_value )
    hero.runeword[13] = GetRuneWordValue(  wii , ser , tic, 4 / assumed_max_runeword_value )
    hero.runeword[14] = GetRuneWordValue(  loo , nah , tic, 5 / assumed_max_runeword_value )
    hero.runeword[15] = GetRuneWordValue(  wii , tal , kil, 5 / assumed_max_runeword_value )
    hero.runeword[16] = GetRuneWordValue(  loo , tal , time, 350 / assumed_max_runeword_value )
    hero.runeword[17] = GetRuneWordValue(  wii , nah , tic, 6 / assumed_max_runeword_value )
    hero.runeword[18] = GetRuneWordValue(  loo , tal , tic, 25 / assumed_max_runeword_value )
    hero.runeword[19] = GetRuneWordValue(  wii , ser , kil, 20 / assumed_max_runeword_value )
    hero.runeword[20] = GetRuneWordValue(  fah , ser , kil, 4 / assumed_max_runeword_value )
    hero.runeword[21] = GetRuneWordValue(  fah , ser , tic, 5 / assumed_max_runeword_value )
    hero.runeword[22] = GetRuneWordValue(  fah , nah , time, 4 / assumed_max_runeword_value )
    hero.runeword[23] = GetRuneWordValue(  wii , nah , time, 5 / assumed_max_runeword_value )
    hero.runeword[24] = GetRuneWordValue(  fah , nah , kil, 7 / assumed_max_runeword_value )
    hero.runeword[25] = GetRuneWordValue(  loo , tal , kil, 60 / assumed_max_runeword_value )
    hero.runeword[26] = GetRuneWordValue(  loo , ser , tic, 5 / assumed_max_runeword_value )
    hero.runeword[27] = GetRuneWordValue(  loo , ser , kil, 20 / assumed_max_runeword_value )
    --new
    hero.runeword[28] = GetRuneWordValue(  wii , roh , time, 5 / assumed_max_runeword_value )
    hero.runeword[29] = GetRuneWordValue(  fah , roh , time, 3 / assumed_max_runeword_value )
    hero.runeword[30] = GetRuneWordValue(  loo , roh , time, 4 / assumed_max_runeword_value )
    hero.runeword[31] = GetRuneWordValue(  wii , roh , kil, 6 / assumed_max_runeword_value )
    hero.runeword[32] = GetRuneWordValue(  fah , roh , kil, 5 / assumed_max_runeword_value )
    hero.runeword[33] = GetRuneWordValue(  loo , roh , kil, 5 / assumed_max_runeword_value )
    hero.runeword[34] = GetRuneWordValue(  wii , roh , tic, 6 / assumed_max_runeword_value )
    hero.runeword[35] = GetRuneWordValue(  fah , roh , tic, 3 / assumed_max_runeword_value )
    hero.runeword[36] = GetRuneWordValue(  loo , roh , tic, 4 / assumed_max_runeword_value )

    hero.runeword[37] = GetRuneWordValue(  sin , roh , time, 3 / assumed_max_runeword_value )
    hero.runeword[38] = GetRuneWordValue(  sin , tal , time, 3 / assumed_max_runeword_value )
    hero.runeword[39] = GetRuneWordValue(  sin , nah , time, 3 / assumed_max_runeword_value )
    hero.runeword[40] = GetRuneWordValue(  sin , ser , time, 3 / assumed_max_runeword_value )
    hero.runeword[41] = GetRuneWordValue(  sin , roh , kil, 3 / assumed_max_runeword_value )
    hero.runeword[42] = GetRuneWordValue(  sin , tal , kil, 3 / assumed_max_runeword_value )
    hero.runeword[43] = GetRuneWordValue(  sin , nah , kil, 3 / assumed_max_runeword_value )
    hero.runeword[44] = GetRuneWordValue(  sin , ser , kil, 3 / assumed_max_runeword_value )
    hero.runeword[45] = GetRuneWordValue(  sin , roh , tic, 3 / assumed_max_runeword_value )
    hero.runeword[46] = GetRuneWordValue(  sin , tal , tic, 3 / assumed_max_runeword_value )
    hero.runeword[47] = GetRuneWordValue(  sin , nah , tic, 3 / assumed_max_runeword_value )
    hero.runeword[48] = GetRuneWordValue(  sin , ser , tic, 3 / assumed_max_runeword_value )



    
    --send word over to panorama
    local runeword_id = 0
    local runepower = 0
    for j=1,48 do
        if hero.runeword[j] and hero.runeword[j] > 0 then
            runeword_id = j
        end
    end
    if runeword_id > 0 then
        runepower = hero.runeword[runeword_id]
        CustomGameEventManager:Send_ServerToAllClients("runewordequip", { word = runeword_id, power = runepower, playerid = hero:GetPlayerID() } )
    end

    --primary stat bonuses
    local baseStats = {}
    local baseStatsPercentFactor = {1,1,1,1,1}
    baseStats[STR] = hero:GetStrength()
    baseStats[AGI] = hero:GetAgility()
    baseStats[INT] = hero:GetIntellect()
    baseStats[AA] = hero:GetAttackDamage()
    baseStats[HP] = hero:GetMaxHealth()
    baseStats[MANA] = hero:GetMaxMana()
    local primary_stats_percent_bonus = 0
    local primary_stats_static_bonus = 0
    if hero and hero.talents then
        if hero.talents[65] and hero.talents[65] > 0 then --and hero:GetMoveSpeedModifier(hero:GetBaseMoveSpeed()) < 300 then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.05 * hero.talents[65]
        end
        if hero.talents[10] and hero.talents[10] > 0 then --and hero:GetMoveSpeedModifier(hero:GetBaseMoveSpeed()) < 300 then
            primary_stats_static_bonus = primary_stats_static_bonus + 15 * hero.talents[10]
        end
        if hero:HasModifier("modifier_item_ancient_primary") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.1
            primary_stats_static_bonus = primary_stats_static_bonus + 60
        end
        if hero:HasModifier("modifier_pathbuff_070") and hero:HasModifier("modifier_path_from_shadows") and hero:HasModifier("modifier_talent_tiger_prowl") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.25
        end
        if hero:HasModifier("modifier_element_holy") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.2
        end
        if hero:HasModifier("modifier_mop") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.1
        end
        if hero:HasModifier("modifier_prep") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.15 * hero.talents[160]
        end
        if hero:HasModifier("modifier_item_ancient_primary_heal") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_new3") then
            primary_stats_static_bonus = primary_stats_static_bonus + 45
        end
        if hero:HasModifier("modifier_new32") then
            primary_stats_static_bonus = primary_stats_static_bonus + 250
        end
        if hero:HasModifier("modifier_new7") then
            primary_stats_static_bonus = primary_stats_static_bonus + 25
        end
        if hero:HasModifier("modifier_new72") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_new8") then
            primary_stats_static_bonus = primary_stats_static_bonus + 25
        end
        if hero:HasModifier("modifier_new82") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_item_nova_blade2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 40
        end
        if hero:HasModifier("modifier_item_ancient_dot") then
            primary_stats_static_bonus = primary_stats_static_bonus + 60
        end
        if hero.talents[71] and hero.talents[71] > 0 and hero:HasModifier("modifier_path_overwhelm") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.1 * hero.talents[71]
        end
        if hero:HasModifier("modifier_ring_of_blood_strength") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.1
        end
        if hero.talents[16] and hero.talents[16] > 0 and hero:HasModifier("modifier_fairy") then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.05 * hero.talents[16]
        end
        local innerFire = hero:GetModifierStackCount("modifier_innerfire", nil)
        if innerFire >= 1 then
            primary_stats_percent_bonus = primary_stats_percent_bonus + 0.01 * GetInnerFireStat(hero) * innerFire
        end
        if hero:HasModifier("modifier_cain_legendary") then
            primary_stats_static_bonus = primary_stats_static_bonus + 25
        end
        if hero:HasModifier("modifier_rage") then
            primary_stats_static_bonus = primary_stats_static_bonus + 25
        end
        if hero:HasModifier("modifier_rage2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_cain_immo") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_cain_divine") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_cain_set2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 300
        end
        if hero:HasModifier("modifier_cain_set") then
            primary_stats_static_bonus = primary_stats_static_bonus + 250
        end
        if hero:HasModifier("modifier_pathbuff_037") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero.talents[121] and hero.talents[121] > 0 and hero.bosskills then
            primary_stats_percent_bonus = primary_stats_percent_bonus + (0.0025 + 0.0025 * hero.talents[121]) * hero.bosskills
        end
        if hero:HasModifier("modifier_item_cd_65") then
            primary_stats_static_bonus = primary_stats_static_bonus + 30
        end
        if hero:HasModifier("modifier_firenature2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_firenature") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_item_nova_blade") then
            primary_stats_static_bonus = primary_stats_static_bonus + 20
        end
        if hero:HasModifier("modifier_frostcrit2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_frostcrit") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_storm2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_storm") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_crown3") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_crown2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_summon2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 200
        end
        if hero:HasModifier("modifier_summon") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_item_cd_65_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_051") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_054") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_060") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_075") then
            primary_stats_static_bonus = primary_stats_static_bonus + 125
        end
        if hero:HasModifier("modifier_pathbuff_057") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_item_cd_54") then
            primary_stats_static_bonus = primary_stats_static_bonus + 30
        end
        if hero:HasModifier("modifier_item_cd_54_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_item_agihaste") then
            primary_stats_static_bonus = primary_stats_static_bonus + 30
        end
        if hero:HasModifier("modifier_item_agihaste_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_item_cd_43") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_item_cd_43_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 125
        end
        if hero:HasModifier("modifier_item_channel") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_item_channel_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 125
        end
        if hero:HasModifier("modifier_item_titanarmor") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_item_titanarmor_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 125
        end
        if hero:HasModifier("modifier_item_windfury") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_item_windfury_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 125
        end
        if hero:HasModifier("modifier_item_bighit") then
            primary_stats_static_bonus = primary_stats_static_bonus + 30
        end
        if hero:HasModifier("modifier_item_bighit_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_item_multi_element") then
            primary_stats_static_bonus = primary_stats_static_bonus + 30
        end
        if hero:HasModifier("modifier_item_multi_element_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_item_wolf_sword") then
            primary_stats_static_bonus = primary_stats_static_bonus + 30
        end
        if hero:HasModifier("modifier_item_wolf_sword_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_item_silverblood3") then
            primary_stats_static_bonus = primary_stats_static_bonus + 30
        end
        if hero:HasModifier("modifier_critmaster") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_critmaster2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_firebow") then
            primary_stats_static_bonus = primary_stats_static_bonus + 35
        end
        if hero:HasModifier("modifier_firebow2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_pathbuff_004") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_005") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_007") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_009") then
            primary_stats_static_bonus = primary_stats_static_bonus + 80
        end
        if hero:HasModifier("modifier_pathbuff_010") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_011") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_030") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_035") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_036") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_042") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_047") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_tunic_hunt_item") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_056") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_063") then
            primary_stats_static_bonus = primary_stats_static_bonus + 125
        end
        if hero:HasModifier("modifier_pathbuff_064") then
            primary_stats_static_bonus = primary_stats_static_bonus + 150
        end
        if hero:HasModifier("modifier_pathbuff_065") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_066") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_067") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_068") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_071") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_093") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_094") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_095") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_096") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_097") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_099") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_100") then
            primary_stats_static_bonus = primary_stats_static_bonus + 125
        end
        if hero:HasModifier("modifier_pathbuff_101") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_102") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_103") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_105") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_106") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_107") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_108") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_110") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_111") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_113") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_115") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_117") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_119") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end

        if hero:HasModifier("modifier_pathbuff_072") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_077") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_079") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_081") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_pathbuff_083") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_086") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_088") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_golden_raven") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_089") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_moonlighttiger") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
        if hero:HasModifier("modifier_item_bloodlust_proc_2") then
            primary_stats_static_bonus = primary_stats_static_bonus + 200
        end
        if hero:HasModifier("modifier_item_bloodlust_proc") then
            primary_stats_static_bonus = primary_stats_static_bonus + 100
        end
        if hero:HasModifier("modifier_pathbuff_158") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_pathbuff_152") then
            primary_stats_static_bonus = primary_stats_static_bonus + 50
        end
        if hero:HasModifier("modifier_endboss") then
            primary_stats_static_bonus = primary_stats_static_bonus + 75
        end
    end
    --finish raw stat calculation: grab other static bonuses
    --static:
    local wingsOfDominanceStatsPerLevel = 15
    if hero:HasModifier("modifier_wing2") then
        wingsOfDominanceStatsPerLevel = wingsOfDominanceStatsPerLevel * 2
    elseif hero:HasModifier("modifier_wing") then
        wingsOfDominanceStatsPerLevel = wingsOfDominanceStatsPerLevel * 1.5
    end
    baseStats[STR] = baseStats[STR] + hero.runeword[5] + hero.runeword[16] + wingsOfDominanceStatsPerLevel * hero.talents[84] + hero.talents[63] * 15 + hero.talents[46] * 15 + hero.talents[10] * 15 + GetGlobalStrengthAuraStat() + GetAllStats(hero)
    baseStats[AGI] = baseStats[AGI] + hero.runeword[1] + hero.runeword[16] + wingsOfDominanceStatsPerLevel * hero.talents[84] + hero.talents[40] * 15 + hero.talents[46] * 15 + GetGlobalAgilityAuraStat() + GetAllStats(hero)
    baseStats[INT] = baseStats[INT] + hero.runeword[2] + wingsOfDominanceStatsPerLevel * hero.talents[84] + hero.talents[35] * 30 + GetGlobalIntellectAuraStat() + GetAllStats(hero)
    if GetLevelOfAbility(hero, "special_bonus_unique_nether_wizard_8") >= 1 then
        baseStats[INT] = baseStats[INT] + 75
    end
    --primary static
    baseStats[hero:GetPrimaryAttribute()+1] = baseStats[hero:GetPrimaryAttribute()+1] + primary_stats_static_bonus
    if hero.primary_bonus_system then
        baseStats[hero:GetPrimaryAttribute()+1] = baseStats[hero:GetPrimaryAttribute()+1] + hero.primary_bonus_system
    end
    --percentage
    baseStatsPercentFactor[STR] = baseStatsPercentFactor[STR] + GetStrengthPercentageBonus(hero, primary_stats_percent_bonus)
    baseStatsPercentFactor[AGI] = baseStatsPercentFactor[AGI] + GetAgilityPercentageBonus(hero, primary_stats_percent_bonus)
    baseStatsPercentFactor[INT] = baseStatsPercentFactor[INT] + GetIntellectPercentageBonus(hero, primary_stats_percent_bonus)
    --primary percentage
    --baseStatsPercentFactor[hero:GetPrimaryAttribute()+1] = baseStatsPercentFactor[hero:GetPrimaryAttribute()+1] + primary_stats_percent_bonus
    --calc pre-final values
    local realBaseStats = {}
    local realBaseStatsToApply = {}
    realBaseStats[STR] = baseStats[STR] * baseStatsPercentFactor[STR]
    realBaseStats[AGI] = baseStats[AGI] * baseStatsPercentFactor[AGI]
    realBaseStats[INT] = baseStats[INT] * baseStatsPercentFactor[INT]
    --last: stat transfers like demonfury etc, it must get percentage bonuses too
    local hasDemonfuryIntellectEffect = hero:HasModifier("modifier_wise_eye")
    if not hasDemonfuryIntellectEffect then
        if GetTitanSorcererStat(hero) >= 1 then
            realBaseStats[INT] = realBaseStats[INT] + realBaseStats[STR] * 0.01 * GetTitanSorcererStat(hero) * baseStatsPercentFactor[INT]
        end
        if hero.talents[61] and hero.talents[61] > 0 then
            realBaseStats[AGI] = realBaseStats[AGI] + (realBaseStats[STR] + realBaseStats[INT]) * 0.05 * hero.talents[61] * baseStatsPercentFactor[AGI]
        end
        if hero:HasModifier("modifier_class_riki2") and hero:GetName() == "npc_dota_hero_riki" then
            realBaseStats[AGI] = realBaseStats[AGI] + realBaseStats[STR] * 0.5 * baseStatsPercentFactor[AGI]
        end
    else
        if GetTitanSorcererStat(hero) >= 1 then
            realBaseStats[INT] = realBaseStats[INT] + realBaseStats[STR] * 0.01 * GetTitanSorcererStat(hero) * baseStatsPercentFactor[INT]
        end
        if hero:HasModifier("modifier_class_riki2") and hero:GetName() == "npc_dota_hero_riki" then
            realBaseStats[AGI] = realBaseStats[AGI] + realBaseStats[STR] * 0.5 * baseStatsPercentFactor[AGI]
        end
        if hero.talents[61] and hero.talents[61] > 0 then
            realBaseStats[INT] = realBaseStats[INT] + (realBaseStats[STR] + realBaseStats[AGI]) * 0.05 * hero.talents[61] * baseStatsPercentFactor[INT]
        end
    end
    


    --base stats done, now nullify dota stats and add fake stats
    --new main stat system: nullify all stats, add bonuses via new buffs
    --strength
    local strengthStat = hero:GetStrength()
    if strengthStat < 1 then
        strengthStat = 0
        hero:RemoveModifierByName("modifier_str_custom")
        hero:RemoveModifierByName("modifier_str_custom_penalty")
    else
        local buff = "modifier_str_custom"
        ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = -1})
        hero:SetModifierStackCount(buff, ability, realBaseStats[STR])
        buff = "modifier_str_custom_penalty"
        ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
        hero:SetModifierStackCount(buff, ability, strengthStat)
    end
    --agi
    local agiStat = hero:GetAgility()
    if agiStat < 1 then
        agiStat = 0
        hero:RemoveModifierByName("modifier_agi_custom")
        hero:RemoveModifierByName("modifier_agi_custom_penalty")
    else
        local buff = "modifier_agi_custom"
        ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = -1})
        hero:SetModifierStackCount(buff, ability, realBaseStats[AGI])
        buff = "modifier_agi_custom_penalty"
        ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
        hero:SetModifierStackCount(buff, ability, agiStat)
    end
    --int
    local intStat = hero:GetIntellect()
    if intStat < 1 then
        intStat = 0
        hero:RemoveModifierByName("modifier_int_custom")
        hero:RemoveModifierByName("modifier_int_custom_penalty")
    else
        local buff = "modifier_int_custom"
        ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = -1})
        hero:SetModifierStackCount(buff, ability, realBaseStats[INT])
        buff = "modifier_int_custom_penalty"
        ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
        hero:SetModifierStackCount(buff, ability, intStat)
    end

    --now we can calc real AA and AS and mana and HP, (primary attribute must give aa dmg): order is important! important: need to substract what we already have at the end
    --Mana
    local manaPerInt = 1 --10 --12
    if hero.resourcesystem then
        manaPerInt = 0.0 --0.1
    end
    local maxManaBonusesFromNonItems = realBaseStats[INT] * manaPerInt + hero.talents[120] * 100
    if GetLevelOfAbility(hero, "special_bonus_unique_nether_wizard_5") >= 1 then
        maxManaBonusesFromNonItems = maxManaBonusesFromNonItems + 500
    end
    baseStats[MANA] = hero:GetMaxMana() + maxManaBonusesFromNonItems --these base stats are wrong because mana per int is added by original values, needs fix to remove int mana
    --print("hero:GetMaxMana() " .. hero:GetMaxMana() .. " baseStats[MANA] " .. baseStats[MANA])
    
    baseStatsPercentFactor[MANA] = 1 + GetManaPercentageBonus(hero)
    hero.manaPercentValue = baseStatsPercentFactor[MANA] - 1
    local baseManaHeroActuallyHas = baseStats[MANA]
    if intStat >= 1 then
        baseManaHeroActuallyHas = baseManaHeroActuallyHas - (intStat - 1) * 12 
    end
    local manaFromPercentageBonuses = baseManaHeroActuallyHas * (baseStatsPercentFactor[MANA] - 1)
    --print("baseManaHeroActuallyHas " .. baseManaHeroActuallyHas)
    realBaseStats[MANA] = baseManaHeroActuallyHas + manaFromPercentageBonuses  --baseStats[MANA] * baseStatsPercentFactor[MANA]
    realBaseStatsToApply[MANA] = manaFromPercentageBonuses + maxManaBonusesFromNonItems --realBaseStats[MANA] - hero:GetMaxMana()
    --print("realBaseStats[MANA] " .. realBaseStats[MANA])
    --print("realBaseStatsToApply[MANA] " .. realBaseStatsToApply[MANA])
    hero.real_custom_mana = realBaseStats[MANA]
    if hero.resourcesystem then
        local extraEnergy = 1 + hero.talents[120] * 10 --dota change of mana per int requires 1 extra mana for energy users
        realBaseStatsToApply[MANA] = extraEnergy
    end
    --Armor
    baseStats[ARM] = hero:GetPhysicalArmorValue(false) + 0.04 * realBaseStats[AGI] + GetArmorStaticBonus( hero, realBaseStats[STR], realBaseStats[AGI], realBaseStats[MANA], magicres )
    baseStatsPercentFactor[ARM] = 1 + GetArmorPercentageBonus(hero, baseStatsPercentFactor[STR])
    realBaseStats[ARM] = baseStats[ARM] * baseStatsPercentFactor[ARM]
    realBaseStatsToApply[ARM] = realBaseStats[ARM] - hero:GetPhysicalArmorValue(false)
    --AS
    local passiveASBonus = hero:GetAttackSpeed(true) * 100 - 100
    baseStats[AS] = GetAttackSpeedBonus(hero, realBaseStats[ARM], realBaseStats[STR], realBaseStats[AGI]) + passiveASBonus   --100 base AS are given but in fact theyre not doing anything
    baseStatsPercentFactor[AS] = 1
    realBaseStats[AS] = baseStats[AS] * baseStatsPercentFactor[AS]
    realBaseStatsToApply[AS] = realBaseStats[AS] - passiveASBonus
    --HP
    local hpPerStr = 10
    if hero.talents[3] and hero.talents[3] > 0 then
        hpPerStr = hpPerStr + 0.5 + 0.5 * hero.talents[3]
    end
    baseStats[HP] = hero:GetMaxHealth() + realBaseStats[STR] * hpPerStr + GetHealthStaticBonus( hero, realBaseStats[STR], realBaseStats[AGI], realBaseStats[INT], realBaseStats[ARM], magicres, realBaseStats[MANA] )
    baseStatsPercentFactor[HP] = 1 + GetHealthPercentageBonus( hero, realBaseStats[ARM], magicres )
    hero.hpPercentValue = baseStatsPercentFactor[HP] - 1
    realBaseStats[HP] = baseStats[HP] * baseStatsPercentFactor[HP]
    realBaseStatsToApply[HP] = realBaseStats[HP] - hero:GetMaxHealth()
    --AA
    baseStats[AA] = hero:GetAttackDamage() + realBaseStats[hero:GetPrimaryAttribute()+1] + GetAttackDamageStaticBonus(hero, realBaseStats[AS], realBaseStats[STR], realBaseStats[HP]) --aa dmg needs real AS and str values
    baseStatsPercentFactor[AA] = (1 + GetAttackDamagePercentageBonus(hero, baseStatsPercentFactor[HP]))
    realBaseStats[AA] = baseStats[AA] * baseStatsPercentFactor[AA]
    realBaseStatsToApply[AA] = realBaseStats[AA] - hero:GetAttackDamage()

    --armor cap 150
    local armorCap = 150
    if hero:HasModifier("modifier_pathbuff_051") then
        armorCap = 175
    end
    if realBaseStats[ARM] > armorCap then
        local buff = "modifier_armor_custom_penalty"
        ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
        hero:SetModifierStackCount(buff, ability, realBaseStats[ARM] - armorCap)
    end

    --now we have calculated all basic stats, lets apply them!
    for i = 4, totalAttributes do --str int agi already applied
        local buff = GetStatBuffByAttribute(i)
        if i == AAA or realBaseStatsToApply[i] >= 1 then
            if i ~= AAA then
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, realBaseStatsToApply[i])
                --print(i)
                --print(realBaseStatsToApply[i])
            else
                --AAA needs special treatment: requires aaplying AA first
                hero:CalculateStatBonus(true)
                baseStats[AAA] = hero:GetAverageTrueAttackDamage(hero) + GetAutoAttackDamageStaticBonus(hero, realBaseStats[STR], realBaseStats[AGI], realBaseStats[INT]) --static AAA can be already there from items
                baseStatsPercentFactor[AAA] = (1 + GetAutoAttackDamagePercentBonus(hero)) * GetAbilityDamageModifierMultiplicative({caster = hero}, hero, hero, nil, ability, false, false, false, false, false, false, false, false, false) * GetElementalDamageModifierAdditive({caster = hero}, hero, hero, nil, ability, false, false, 1, false) --ability damage % and physical % now also grant AA %
                realBaseStats[AAA] = baseStats[AAA] * baseStatsPercentFactor[AAA]
                realBaseStatsToApply[AAA] = realBaseStats[AAA] - hero:GetAverageTrueAttackDamage(hero)
                --apply
                if realBaseStatsToApply[i] >= 1 then
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                    hero:SetModifierStackCount(buff, ability, realBaseStatsToApply[i])
                end
            end
        end
    end
    --update new UI
    local player = PlayerResource:GetPlayer(hero:GetPlayerID())
    CustomGameEventManager:Send_ServerToAllClients("set_main_stats", {id = hero:GetPlayerID(), str = math.floor(realBaseStats[STR]), agi = math.floor(realBaseStats[AGI]), int = math.floor(realBaseStats[INT]), level = hero.level, levelPercentage = hero.levelPercentage})
    --pathwords
    --local pathwords = GetPathBonusesFromPathWords(hero)
    --local pathSynergies = GetPathSynergyBonuses(hero)
    --SendPathWordsToUI(hero, pathwords)
    --path bonus calculation
    local soul = GetSoulItemTalent(hero)
    --local classringbonus = GetClassRingPower(hero) --unused?
    local amuletpathbonus = GetArtifactPathBonus(hero, 8)
    local ringpathbonus = GetArtifactPathBonus(hero, 3)
    for i=1, COverthrowGameMode.maxtalents do
        local soul_item_bonus = 0
        local path_word_bonus = 0
        for k=1, 3 do
            if i == soul[k][1] then
                soul_item_bonus = soul[k][2]
            end
        end
        local path_bonus_from_ring_given = 0
        --for k=1, 3 do
        --    if i == classringbonus[-1+k*2] then
        --        path_bonus_from_ring_given = classringbonus[k*2]
        --        soul_item_bonus = soul_item_bonus + classringbonus[k*2]
        --    end
        --end
        for k=1, 3 do
            if i == amuletpathbonus[-1+k*2] then
                --if amuletpathbonus[k*2] > path_bonus_from_ring_given then
                    --only when the amulet gives more points than the ring it takes effect
                    soul_item_bonus = soul_item_bonus + amuletpathbonus[k*2] - path_bonus_from_ring_given
                --end
            end
            if i == ringpathbonus[-1+k*2] then
                --if ringpathbonus[k*2] > path_bonus_from_ring_given then
                    --only when the amulet gives more points than the ring it takes effect
                    soul_item_bonus = soul_item_bonus + ringpathbonus[k*2] - path_bonus_from_ring_given
                --end
            end
        end
        --if pathwords and pathwords[i] and pathwords[i][1] and pathwords[i][1] > 0 then
        --    soul_item_bonus = soul_item_bonus + pathwords[i][1]
        --    path_word_bonus = pathwords[i][1]
        --end
        --if pathSynergies and pathSynergies[i] and pathSynergies[i] >= 1 then
            --soul_item_bonus = soul_item_bonus + pathSynergies[i]
        --end
        if i == 87 then
            soul_item_bonus = soul_item_bonus + hero.runeword[13]
        end
        if i == 6 then
            soul_item_bonus = soul_item_bonus + hero.runeword[24]
        end
        if i == 8 then
            soul_item_bonus = soul_item_bonus + hero.runeword[26]
        end
        if i == 49 then
            soul_item_bonus = soul_item_bonus + hero.runeword[15]
        end
        if i == 17 then
            soul_item_bonus = soul_item_bonus + hero.runeword[12]
        end
        if i == 53 then
            soul_item_bonus = soul_item_bonus + hero.runeword[20]
        end
        if i == 135 then --genesis
            soul_item_bonus = soul_item_bonus + hero.runeword[22]
        end
        if i == 92 or i == 104 then --frostmourne
            soul_item_bonus = soul_item_bonus + hero.runeword[23]
        end
        --new runewords
        if i == 101 then
            soul_item_bonus = soul_item_bonus + hero.runeword[28]
        end
        if i == 78 then
            soul_item_bonus = soul_item_bonus + hero.runeword[29]
        end
        if i == 36 then
            soul_item_bonus = soul_item_bonus + hero.runeword[30]
        end
        if i == 96 then
            soul_item_bonus = soul_item_bonus + hero.runeword[31]
        end
        if i == 89 then
            soul_item_bonus = soul_item_bonus + hero.runeword[32]
        end
        if i == 22 then
            soul_item_bonus = soul_item_bonus + hero.runeword[33]
        end
        if i == 57 then
            soul_item_bonus = soul_item_bonus + hero.runeword[34]
        end
        if i == 117 then
            soul_item_bonus = soul_item_bonus + hero.runeword[35]
        end
        if i == 51 then
            soul_item_bonus = soul_item_bonus + hero.runeword[36]
        end

        if i == 145 then
            soul_item_bonus = soul_item_bonus + hero.runeword[41]
        end
        if i == 146 then
            soul_item_bonus = soul_item_bonus + hero.runeword[46]
        end
        if i == 147 then
            soul_item_bonus = soul_item_bonus + hero.runeword[37]
        end
        if i == 148 then
            soul_item_bonus = soul_item_bonus + hero.runeword[47]
        end
        if i == 152 then
            soul_item_bonus = soul_item_bonus + hero.runeword[42]
        end
        if i == 154 then
            soul_item_bonus = soul_item_bonus + hero.runeword[48]
        end
        if i == 155 then
            soul_item_bonus = soul_item_bonus + hero.runeword[44]
        end
        if i == 156 then
            soul_item_bonus = soul_item_bonus + hero.runeword[45]
        end
        if i == 158 then
            soul_item_bonus = soul_item_bonus + hero.runeword[38]
        end
        if i == 159 then
            soul_item_bonus = soul_item_bonus + hero.runeword[39]
        end
        if i == 161 then
            soul_item_bonus = soul_item_bonus + hero.runeword[43]
        end
        if i == 162 then
            soul_item_bonus = soul_item_bonus + hero.runeword[40]
        end

        if i == 70 and hero:HasModifier("modifier_item_night_shoulders") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 86 and hero:HasModifier("modifier_new3") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 86 and hero:HasModifier("modifier_new32") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 71 and hero:HasModifier("modifier_item_dragonshield") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 104 and hero:HasModifier("modifier_item_frostmourne") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 2 and hero:HasModifier("modifier_item_ancient_wolf") then
            soul_item_bonus = soul_item_bonus + 2
        end
        --new set perks
        if i == 63 and hero:HasModifier("modifier_item_item_set_t4_agi_4") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 41 and hero:HasModifier("modifier_item_wolf_sword") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 41 and hero:HasModifier("modifier_item_wolf_sword_2") then
            soul_item_bonus = soul_item_bonus + 3
        end
        if i == 13 and hero:HasModifier("modifier_item_set_agi_dmg_full_tiger") then
            soul_item_bonus = soul_item_bonus + 3
        end
        if i == 13 and hero:HasModifier("modifier_item_set_agi_dmg_full_t1_2") then
            soul_item_bonus = soul_item_bonus + 3
        end
        if i == 50 and hero:HasModifier("modifier_item_set_str_tank_full_t1_dream") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 81 and hero:HasModifier("modifier_item_set_agi_skyfall") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 51 and hero:HasModifier("modifier_item_set_str_t3_2_full_dream") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 75 and hero:HasModifier("modifier_item_set_agi_t3_2_shad_ref") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 57 and hero:HasModifier("modifier_npc_dota_hero_pugna") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 67 and hero:HasModifier("modifier_pathbuff_096") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 63 and hero:HasModifier("modifier_pathbuff_105") then
            soul_item_bonus = soul_item_bonus + 1
        end
        
        if i == 15 and hero:HasModifier("modifier_pathbuff_098") then
            soul_item_bonus = soul_item_bonus + 1
        end
        
        if i == 15 and hero:HasModifier("modifier_npc_dota_hero_dragon_knight") and hero:HasModifier("modifier_shieldbash") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 73 and hero:HasModifier("modifier_npc_dota_hero_riki") and hero:HasModifier("modifier_shadowstep1") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 69 and hero:HasModifier("modifier_item_aura_ancient") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 76 and hero:HasModifier("modifier_item_intmana") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 79 and hero:HasModifier("modifier_item_channel") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 79 and hero:HasModifier("modifier_item_channel_2") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 59 and hero:HasModifier("modifier_item_ancient_dmg") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if (i == 25 or i == 26 or i == 32) and hero:HasModifier("modifier_dragonmind") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if (i == 4 or i == 10 or i == 12) and hero:HasModifier("modifier_dragonmind2") then
            soul_item_bonus = soul_item_bonus + 1
        end
        --end set perks
        if i == 47 and hero:HasModifier("modifier_item_ancient_wolf") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 47 then
            soul_item_bonus = soul_item_bonus + hero.runeword[14]
        end
        if i == 33 and hero:HasModifier("modifier_item_ancient_dragon") and hero.talents_clicked and hero.talents_clicked[i] and hero.talents_clicked[i] > 0 then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 5 and hero:HasModifier("modifier_ancient_allstats") and hero.talents_clicked and hero.talents_clicked[i] and hero.talents_clicked[i] > 0 then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 18 and hero:HasModifier("modifier_item_dmg5") and hero.talents_clicked and hero.talents_clicked[i] and hero.talents_clicked[i] > 0 then
            soul_item_bonus = soul_item_bonus + 3
        end
        if i == 53 and hero:HasModifier("modifier_item_dmg5") and hero.talents_clicked and hero.talents_clicked[i] and hero.talents_clicked[i] > 0 then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 11 and hero:HasModifier("modifier_item_ancient_primary_heal") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 50 and hero:HasModifier("modifier_item_ancient_primary_heal") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 53 and hero:HasModifier("modifier_class_fury") and hero:HasModifier("modifier_furycharge") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 84 and hero:HasModifier("modifier_pathbuff_057") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if (i == 37 or i == 38) and hero:HasModifier("modifier_pathbuff_060") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 34 and hero:HasModifier("modifier_item_winterbreeze4") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 20 and hero:HasModifier("modifier_item_ancient_elune") and hero.talents_clicked and hero.talents_clicked[i] and hero.talents_clicked[i] > 0 then
            soul_item_bonus = soul_item_bonus + 3
        end
        if i == 56 and hero:HasModifier("modifier_item_ancient_primary") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 36 and hero:HasModifier("modifier_item_ancient_primary") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 49 and hero:HasModifier("modifier_item_ancient_grizzly") and hero.talents_clicked and hero.talents_clicked[i] and hero.talents_clicked[i] > 0 then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 46 then
            if hero:HasModifier("modifier_item_crit_pure_immortal_2") then
                soul_item_bonus = soul_item_bonus + 2
            end
            soul_item_bonus = soul_item_bonus + hero.runeword[11]
        end
        if i == 55 then
            soul_item_bonus = soul_item_bonus + hero.runeword[10]
        end
        if i == 32 then
            soul_item_bonus = soul_item_bonus + hero.runeword[17]
        end
        if i == 69 then
            soul_item_bonus = soul_item_bonus + hero.runeword[8]
        end
        if i == 22 and hero:HasModifier("modifier_moonlighttiger") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 135 and HeroHasNeutralItem(hero, "item_neutral_1") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 138 and HeroHasNeutralItem(hero, "item_neutral_27") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 127 and HeroHasNeutralItem(hero, "item_neutral_23") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if (i == 13 or i == 14 or i == 15) and HeroHasNeutralItem(hero, "item_neutral_24") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 128 and HeroHasNeutralItem(hero, "item_neutral_8") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 125 and HeroHasNeutralItem(hero, "item_neutral_10") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 141 and HeroHasNeutralItem(hero, "item_neutral_12") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 142 and HeroHasNeutralItem(hero, "item_neutral_11") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 131 and HeroHasNeutralItem(hero, "item_neutral_13") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 143 and HeroHasNeutralItem(hero, "item_neutral_18") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if i == 136 and hero:HasModifier("modifier_thunderclub") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if (i == 35 or i == 86) and HeroHasNeutralItem(hero, "item_neutral_20") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if (i == 23 or i == 126) and HeroHasNeutralItem(hero, "item_neutral_21") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if (i == 31 or i == 34) and HeroHasNeutralItem(hero, "item_neutral_4") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if (i == 121 or i == 123) and HeroHasNeutralItem(hero, "item_neutral_17") then
            soul_item_bonus = soul_item_bonus + 1
        end
        if (i == 60 or i == 139) and hero:HasModifier("modifier_rider_boots") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 23 then
            soul_item_bonus = soul_item_bonus + hero.runeword[9]
        end
        if i == 29 then
            soul_item_bonus = soul_item_bonus + hero.runeword[21]
        end
        if (i == 39 or i == 40 or i == 42) and hero:HasModifier("modifier_ancient_def_wolf") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if (i == 145 or i == 147 or i == 159 or i == 162) and hero:HasModifier("modifier_nameless") then
            soul_item_bonus = soul_item_bonus + 2
        end
        if i == 73 and hero:HasModifier("modifier_item_rogueblades2") and hero:GetUnitName() == "npc_dota_hero_riki" then
            soul_item_bonus = soul_item_bonus + 1
        end

        local new_talent_value = hero.talents_clicked[i] + soul_item_bonus
        --if i == 39 then
        --    new_talent_value = 3
        --end
        
        --new divine doubling soul items
        local pathbuff = "modifier_pathbuff_0"
        if i <= 9 then
            pathbuff = "modifier_pathbuff_00"
        elseif i >= 100 then
            pathbuff = "modifier_pathbuff_"
        end
        pathbuff = pathbuff..i
        if hero:HasModifier(pathbuff) then
            local pathbuff_factor = 1
            local pathBonus = 3
            if i == 132 then
                pathBonus = 2
            end
            --if i == 1 or i == 13 or i == 25 or i == 37 then
            --    pathbuff_factor = 3
            --end
            --if i == 15 or i == 17 then
            --    pathbuff_factor = 3
            --end
            --if i == -1 then
            --    pathbuff_factor = 1
            --end
            --ravencraft fixes
            if i == 88 and not hero:HasModifier("modifier_path_088_ability_points") then
                --not activated gives 0 extra points
                pathbuff_factor = 0
            end
            if i == 88 and hero:HasModifier("modifier_path_088_ability_points") then
                hero.has_used_ravencraft_abilitypoint_item = true
            end
            --old
            --new_talent_value = new_talent_value * pathbuff_factor
            --path_word_bonus = path_word_bonus * pathbuff_factor
            --new
            if pathbuff_factor == 1 then
                new_talent_value = new_talent_value + pathBonus
            end
        end
        --update talent tree when it changes, for ALL players
        

        local showStatistics = false
        if showStatistics then
            if not COverthrowGameMode.CalculatedPathStatistics then
                COverthrowGameMode.CalculatedPathStatistics = GetPathStatisticsAccumulated(COverthrowGameMode.PathStatistics, true)
            end
            new_talent_value = COverthrowGameMode.CalculatedPathStatistics[i]
        end

        --new_talent_value = 5
        --if i == 95 then
        --    new_talent_value = 10
        --end
        --if i == 111 then
        --    new_talent_value = 5
        --end
        --new bottom row path caps
        if new_talent_value > 3 and (i == 125 or i == 129 or i == 134 or i == 137 or i == 142 or i == 143 or i == 144 or i == 160) then
            new_talent_value = 3
        end

        if i == 132 then --primal power special case
            local primalPowerCap = 3
            if hero:HasModifier("modifier_pathbuff_132") then
                primalPowerCap = 5
            end
            if new_talent_value > primalPowerCap then
                new_talent_value = primalPowerCap
            end
        end

        if hero.talents[132] > 0 and new_talent_value == 3 and ((i <= 39 and math.floor(1 + ((i - 1) % 12) / 3) == 1) or i == 61 or i == 62 or i == 63 or i == 76 or i == 77 or i == 78 or i == 91 or i == 92 or i == 93 or i == 106 or i == 107 or i == 108 or i == 145 or i == 146 or i == 147) then
            new_talent_value = new_talent_value + hero.talents[132]
        end
        local maxPathLevel = 1000 --10
        --genesis
        --if hero.talents[135] > 0 then
        --    maxPathLevel = 10 + 2 * hero.talents[135]
        --end
        
        if new_talent_value > maxPathLevel then
            new_talent_value = maxPathLevel
        end

        if hero.talents[i] ~= new_talent_value then
            local id = hero:GetPlayerID()
            CustomGameEventManager:Send_ServerToAllClients("talentleveled", { playerid = id, talent = i, level = new_talent_value } )
        end
        hero.talents[i] = new_talent_value
        hero.talents_without_pathwords[i] = new_talent_value - path_word_bonus
        --tests
        --hero.talents[66] = 3
        --hero.talents[85] = 3
        --hero.talents[57] = 3
        local level = hero.talents[i]
        
        if level > 0 or i == 1 or i == 5 or i == 13 or i == 14 or i == 15 or i == 18 or i == 20 or i == 25 or i == 26 or i == 18 or i == 34 or i == 52 or i == 67 or (i == 25 and hero.runeword[2] > 0) 
                or i == 27 or (i == 30 and hero.runeword[10] > 0) then
            if i == 1 then
                --some buffs must be added first
                if (hero:HasModifier("modifier_invisible") or hero:HasModifier("modifier_oocmana")) and hero.talents and hero.talents[70] and hero.talents[70] > 0 then
                    local buff = "modifier_path_from_shadows"
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = 14.9})
                    hero.fromTheShadows = 1 + 0.1 * hero.talents[70]
                end
            end
            if i == 14 then
                local buff = "modifier_movement"
                hero:RemoveModifierByName(buff)
                local static_bonus = level * 5
                if hero.talents[80] and hero.talents[80] > 0 then
                    static_bonus = static_bonus + 3 * hero.talents[80]
                end
                if GetLevelOfAbility(hero, "special_bonus_unique_nether_wizard_1") >= 1 then
                    static_bonus = static_bonus + 5
                end
                if hero.talents[139] and hero.talents[139] > 0 then
                    static_bonus = static_bonus + CountAbilitiesWithLevel(hero, 1) * 3 * hero.talents[139]
                end
                local value = static_bonus
                if value >= 1 then
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                    hero:SetModifierStackCount(buff, ability, value)
                end
            end
            if i == 15 then
                --evasion
                if level > 0 then
                    local value = level * 5
                    if value > 30 then
                        value = 30
                    end
                    ability:ApplyDataDrivenModifier(hero, hero, "modifier_evasion", {Duration = dur})
                    hero:SetModifierStackCount("modifier_evasion", ability, value)
                end
            end
            if i == 24 then
                local buff = "modifier_talent_crit"
                hero:RemoveModifierByName(buff)
                local value = level * 2 -- + hero.runeword[8]
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, value)
                --shield buff
                local refresh_base_time = 25
                if not hero:IsRangedAttacker() then
                    refresh_base_time = 20
                end
                local refresh_time = refresh_base_time - GetAgilityCustom(hero) / 50
                if refresh_time <= 5 then
                    refresh_time = 5
                end
                if hero.moonglaive_shield then
                    hero.moonglaive_shield = hero.moonglaive_shield + updateEveryXSecs
                    if hero.moonglaive_shield >= refresh_time then
                        hero.moonglaive_shield = hero.moonglaive_shield - refresh_time
                        --print(hero.moonglaive_shield)
                        local myevent = {}
                        myevent.caster = hero
                        myevent.target = hero
                        myevent.buff = "modifier_talent_moonglaive_shield"
                        myevent.ability = ability
                        myevent.addstacks = 1
                        local max_stack = 4
                        myevent.max = max_stack
                        ApplyBuffStack(myevent)
                    end
                else
                    hero.moonglaive_shield = 5
                end
            end
            if i == 20 then
                if level <= 0 then
                    hero.standsstill = 0
                    hero:RemoveModifierByName("modifier_careful_aim")
                else
                    StandStill({caster = hero})
                end
            end
            if i == 23 then
                local buff = "modifier_aa_starfall"
                hero:RemoveModifierByName(buff)
                local value = level
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, value)
            end
            if i == 26 and isUpdateTickEvery5secs then
                local percent_bonus = 0.01 * level
                local flat_bonus = 10 * level
                if not hero.resourcesystem then --mana user
                    if hero.talents[74] and hero.talents[74] > 0 and not hero:HasModifier("modifier_oocmana") then
                        if hero:GetMana() / hero:GetMaxMana() > 0.25 then
                            percent_bonus = percent_bonus - 0.15
                            hero.path_sacrifice_souls_paid = 4
                        else
                            hero.path_sacrifice_souls_paid = false
                        end
                    end
                else
                    hero.path_sacrifice_souls_paid = 4 --energy users dont pay here
                end
                if hero:HasModifier("modifier_item_item_set_t4_int_4") then
                    percent_bonus = percent_bonus + 0.01
                end
                if percent_bonus ~= 0 then
                    local value = hero:GetMaxMana() * percent_bonus + flat_bonus
                    local myevent = {caster = hero, target = hero, amount = value}
                    RestoreMana(myevent)
                end
            end
            if i == 58 and isUpdateTickEvery5secs then
                if not hero:HasModifier("modifier_oocmana") and hpPercent >= 0.65 then
                    --hero:SetHealth(hero:GetHealth() - hero:GetMaxHealth() * 0.15)
                    hpPercent = hpPercent - 0.15
                    hero.lifeblood = 1 + 0.1 * level
                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_POINT_FOLLOW, hero)
                    ParticleManager:ReleaseParticleIndex(particle)
                    ability:ApplyDataDrivenModifier(hero, hero, "modifier_talent_lifeblood", {Duration = 5})
                    AddHeroResource({caster = hero, amount = (0.5 + 0.5 * level), percent = true, energy = 5 * level, energypercent = true})
                end
            end
            if i == 27 then
                local buff = "modifier_spellres"
                hero:RemoveModifierByName(buff)
                local value1 = 0
                if level >= 1 then
                    value1 = 5 + level * 5
                end
                local value2 = hero.runeword[4]
                local value3 = 0
                if hero.talents[91] and hero.talents[91] > 0 then
                    value3 = 1 * hero.talents[91]
                end
                if value1 > 75 then
                    value1 = 75
                end
                local value4 = 0
                local pala4 = hero:FindAbilityByName("pala4")
                if pala4 and pala4:GetLevel() >= 4 then
                    value4 = realBaseStats[INT] * 0.02
                    if value4 > 25 then
                        value4 = 25
                    end
                end
                local value5 = 0
                if GetLevelOfAbility(hero, "special_bonus_unique_nether_wizard_7") >= 1 then
                    value5 = 35
                end
                local mresPerInt = 0.01
                if GetLevelOfAbility(hero, "ench3") >= 4 then
                    mresPerInt = mresPerInt * 2
                end
                local value6 = realBaseStats[INT] * mresPerInt --intellect stat mres
                local finalValue = ((100 - value1) / 100) * ((100 - value2) / 100) * ((100 - value3) / 100) * ((100 - value4) / 100) * ((100 - value5) / 100) * ((100 - value6) / 100) --diminishing calculation, result is damage factor: 0.2 means 80% reduction
                finalValue = (1 - finalValue) * 100
                if finalValue >= 1 then
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                    hero:SetModifierStackCount(buff, ability, finalValue)
                end
            end
            if i == 46 then
                local buff = "modifier_talent_beastmaster"
                hero:RemoveModifierByName(buff)
                local value = level
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, value)
            end
            if i == 21 then
                local buff = "modifier_talent_glass_cannon"
                hero:RemoveModifierByName(buff)
                local value = level
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, value)
            end
            if i == 52 and isUpdateTickEvery5secs then
                if level > 0 then
                    local myevent = {}
                    myevent.caster = hero
                    myevent.target = hero
                    myevent.buff = "modifier_talent_tiger_prowl"
                    myevent.ability = ability
                    myevent.dur = -1
                    myevent.addstacks = 5
                    local max_stack = 10
                    if hero:HasModifier("modifier_item_ancient_elune") then
                        max_stack = 15
                    end
                    myevent.max = max_stack
                    ApplyBuffStack(myevent)
                else
                    hero:RemoveModifierByName("modifier_talent_tiger_prowl")
                end
            end
            if i == 65 then
                if not hero:HasModifier("modifier_oocmana") then
                    local buff = "modifier_movement_minus"
                    hero:RemoveModifierByName(buff)
                    local value = 15
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                    hero:SetModifierStackCount(buff, ability, value)
                end
            end
            if i == 85 then -- and isUpdateTickEvery5secs then
                local buff = "modifier_stormcrow"
                --hero:RemoveModifierByName(buff)
                local value = CountNearbyEnemies(hero, 900)
				
                hero.nearby_enemies = value
				
                --ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                --hero:SetModifierStackCount(buff, ability, value)
                local feast_threshold = 3
                if hero:HasModifier("modifier_pathbuff_075") then
                    feast_threshold = 2
                end

                if value >= feast_threshold then
                	--PathFeastForCrowsAOE(hero)
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = 4 + 2 * level})
                end
            end
            if i == 88 then
                if not hero.path_all_knowing_crow_points_given then
                    hero.path_all_knowing_crow_points_given = 0
                end
                if level > hero.path_all_knowing_crow_points_given then
                    local missing_points = level - hero.path_all_knowing_crow_points_given
                    hero:SetAbilityPoints(hero:GetAbilityPoints() + missing_points)
                    hero.path_all_knowing_crow_points_given = hero.path_all_knowing_crow_points_given + missing_points
                end
            end
            --[[
            if i == 104 then
                local ability5 = hero:GetAbilityByIndex(4)
                local ability6 = hero:GetAbilityByIndex(5)
                if ability5 and ability5:GetCooldownTimeRemaining() > 0 and ability6 and ability6:GetCooldownTimeRemaining() > 0 and not hero:HasModifier("modifier_deathchill_cd") then
                    local dur = 10
                    ability:ApplyDataDrivenModifier(hero, hero, "modifier_deathchill", {Duration = dur})
                    ability:ApplyDataDrivenModifier(hero, hero, "modifier_deathchill_cd", {Duration = dur * 2})
                end
            end]]
            if i == 106 and isUpdateTickEvery5secs then
                ability:ApplyDataDrivenModifier(hero, hero, "modifier_guardianshield", {Duration = -1})
            end
            if i == 107 then
                local value = CountNearbyEnemies(hero, 450)
                if value <= 0 then
                    ability:ApplyDataDrivenModifier(hero, hero, "modifier_lonedruid", {Duration = 60})
                    if isUpdateTickEvery5secs then
                        local myevent = {caster = hero, target = hero, attributefactor = 50 * level, heal = 0, ability = ability}
                        Timers:CreateTimer(0.25, function()
                            HealUnit(myevent)
                            AddAttackSpeed(hero, 250, 5)
                        end)
                    end
                else
                    hero:RemoveModifierByName("modifier_lonedruid")
                end
            end
            if i == 109 then
                local max_stack = 10
                local myevent = {caster = hero, target = hero, buff = "modifier_stoneskin", ability = ability, dur = -1, addstacks = 1, max = max_stack}
                ApplyBuffStack(myevent)
            end
            if i == 116 then
                local buff = "modifier_spellres2"
                hero:RemoveModifierByName(buff)
                local value = level * 0.00333 * GetAgilityCustom(hero)
                if value > 30 then
                    value = 30
                end
                if value >= 1 then
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                    hero:SetModifierStackCount(buff, ability, value)
                end
            end
            if i == 115 then
                local buff = "modifier_attackspeed_minus"
                hero:RemoveModifierByName(buff)
                local value = level * 25
                if value >= 1 then
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                    hero:SetModifierStackCount(buff, ability, value)
                end
            end
            
        end
    end


    
    --local buff = "modifier_dmg_from_primary"
    --ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = -1})
    --hero:SetModifierStackCount(buff, ability, dmgFromPrimaryAttribute)

    --[[ new penalties to counter base stat gains 
        local agility = hero:GetAgility()
        local penalty = agility * 0.103 --0.1228
                           -- 0.076 = 1armor per 15
        if hero.talents and hero.talents[19] and hero.talents[19] > 0 then
            local factor_melee_ranged = 0.006
            if not hero:IsRangedAttacker() then
                factor_melee_ranged = factor_melee_ranged * 1.25
            end
            penalty = penalty - factor_melee_ranged * hero.talents[19] * agility
        end
        local buff = "modifier_armor_penalty"
        hero:RemoveModifierByName(buff)
        if penalty >= 1 then
            ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
            hero:SetModifierStackCount(buff, ability, penalty)
        end
        penalty = agility * 49/50
        buff = "modifier_attackspeed_penalty"
        hero:RemoveModifierByName(buff)
        if penalty >= 1 then
            ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
            hero:SetModifierStackCount(buff, ability, penalty)
        end
        if hero:GetPrimaryAttribute() == 0 then
            penalty = hero:GetStrength()
            buff = "modifier_str_custom"
            if penalty >= 1 then
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = -1})
                hero:SetModifierStackCount(buff, ability, penalty)
            end
            buff = "modifier_str_custom_penalty"
            if penalty >= 1 then
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, penalty)
            end
        end
        if hero:GetPrimaryAttribute() == 1 then
            penalty = hero:GetAgility() * 0.06
            buff = "modifier_ms_penalty"
            hero:RemoveModifierByName(buff)
            if penalty >= 1 then
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, penalty)
            end
        end
        if hero:GetPrimaryAttribute() == 2 then
            penalty = hero:GetIntellect()
            buff = "modifier_int_custom"
            if penalty >= 1 then
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = -1})
                hero:SetModifierStackCount(buff, ability, penalty)
            end
            buff = "modifier_int_custom_penalty"
            if penalty >= 1 then
                ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                hero:SetModifierStackCount(buff, ability, penalty)
            end
        end
        if hero:GetPrimaryAttribute() == 0 or hero:GetPrimaryAttribute() == 1 then
            if hero.resourcesystem and hero.resourcesystem ~= 4 then
                penalty = hero:GetIntellect()
                buff = "modifier_int_custom_penalty"
                if penalty >= 1 then
                    ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = dur})
                    hero:SetModifierStackCount(buff, ability, penalty)
                end
                hero:SetBaseManaRegen(0)
            end
        end]]

        --new aa ability % system
        --must remove aa crits here to ensure clean green aa dmg
    --local hero_aa_dmg = hero:GetAverageTrueAttackDamage(hero) --hero:GetAttackDamage() --hero:GetAverageTrueAttackDamage(hero) --bugs because of crits adding green damage, then getting bonuses for that green dmg too
    --local from_abi = GetAbilityDamageModifierMultiplicative({caster = hero}, hero, hero, nil, ability, false, false, false, false, false, false, false, false)
    --local from ele = GetElementalDamageModifierAdditive({caster = hero}, hero, hero, nil, ability, false, false, 1)
    --local aa_from_abi = hero_aa_dmg * from_abi * ele - hero_aa_dmg
    --if aa_from_abi and aa_from_abi >= 1 then
    --    ability:ApplyDataDrivenModifier(hero, hero, "modifier_aa_from_abi", {Duration = dur})
    --    hero:SetModifierStackCount("modifier_aa_from_abi", ability, aa_from_abi)
    --end
    if hero.temple_class then
        ability:ApplyDataDrivenModifier(hero, hero, "modifier_aa_temple_penalty", {Duration = dur})
    end
    hero:CalculateStatBonus(true)
    hero.magicalResistance = hero:Script_GetMagicalArmorValue(false, nil)
    --re add auto crit if we had one active
    if system_aacrit_stacks > 0 and hero.combat_system_ability then
        hero.combat_system_ability:ApplyDataDrivenModifier(hero, hero, "system_aacrit", nil)
        hero:SetModifierStackCount("system_aacrit", hero.combat_system_ability, system_aacrit_stacks)
    end
    --hp fix to keep current hp % the same, even if max hp changes
    hero:SetHealth(hero:GetMaxHealth() * hpPercent)
    ProcsEverySecond(hero)
    if isUpdateTickEvery5secs then
        ProcsEvery5Seconds(hero)
    end
    if isUpdateTickEvery10secs then
        ProcsEvery10Seconds(hero)
    end
end

function ProcsEverySecond(hero)
    if HeroHasNeutralItem(hero, "item_neutral_25") and GetAbilitiesOnCooldown(hero) >= 4 and not hero:HasModifier("modifier_timeshaperCD") then
        EmitSoundOn("Item.CrimsonGuard.Cast", hero)
        local particle = ParticleManager:CreateParticle("particles/items3_fx/lotus_orb_reflect.vpcf", PATTACH_POINT_FOLLOW, hero)
        ParticleManager:ReleaseParticleIndex(particle)
        ResetAllCooldowns(hero)
        hero.combat_system_ability:ApplyDataDrivenModifier(hero, hero, "modifier_timeshaperCD", {Duration = 120 * GetInnerCooldownFactor(hero)})
    end
    if GetFlamewalkerStat(hero) >= 1 then
        local ev = {caster = hero, target = hero, firedmg = 1, ability = hero.combat_system_ability, damage = 0, attributefactor = GetFlamewalkerStat(hero), attributechangestragi = 1, aoe = 250, targeteffect = "blood", isaoe = 1, dontdamagereflect = true }
        DamageAOE(ev)
    end
    if GetLevelOfAbility(hero, "Concussive_Blow") >= 2 then
        RestoreResource({caster = hero, amount = 3})
    end
    if hero.talents[159] > 0 and hero:HasModifier("modifier_invisible") then
        hero.ambushTalent = 10
    end
    if hero.talents[137] > 0 then
        if not hero.hysteriaCounter then
            hero.hysteriaCounter = 0
        end
        hero.hysteriaCounter = hero.hysteriaCounter + 1
        if hero.hysteriaCounter >= 4 - hero.talents[137] and not hero:HasModifier("modifier_invisible") then
            hero.hysteriaCounter = 0
            local range = 300
            if hero:IsRangedAttacker() then
                range = 900
            end
            local target = FindClosestEnemy({caster = hero, radius = range})
            if target and not HasDamageReflect(target) then
                PerformAutoAttackWithDelay(hero, target, 0.25)
                if HeroHasNeutralItem(hero, "item_neutral_9") then
                    PerformAutoAttackWithDelay(hero, target, 0.5)
                    PerformAutoAttackWithDelay(hero, target, 0.75)
                end
            end
        end
    end
    if not hero:HasModifier("modifier_oocmana") then
        TyphoonProc(hero, FindClosestEnemy({caster = hero, radius = 900}), false)
    end
    if hero.talents[153] > 0 and not hero:HasModifier("modifier_bloodmoonCD") then
        if hero:GetHealth() / hero:GetMaxHealth() < 0.5 then
            hero.combat_system_ability:ApplyDataDrivenModifier(hero, hero, "modifier_bloodmoonCD", {Duration = (360 - 60 * hero.talents[153]) * GetInnerCooldownFactor(hero)})
            ResetAllCooldowns(hero)
            ApplyBuff({caster = hero, target = hero, ability = hero.combat_system_ability, buff = "modifier_bloodmoon", dur = hero.talents[153]})
        end
    end
end

function ProcsEvery5Seconds(hero)
    if hero.talents and hero.talents[21] > 0 then
        hero.fragileAACrit = 0.15 * hero.talents[21]
    end
    if hero.talents[124] > 0 then
        ApplyBuffStack({caster = hero, target = hero, ability = hero.combat_system_ability, buff = "modifier_lunarecl", dur = -1, addstacks = 3, max = 15})
    end
    if hero.talents[136] > 0 then
        ApplyBuffStack({caster = hero, target = hero, ability = hero.combat_system_ability, buff = "modifier_typhoon", dur = -1, addstacks = 1, max = 10})
    end
    if HeroHasNeutralItem(hero, "item_neutral_3") and not hero.helmUndyingLifeGiven then
        if AddLivesToHero(hero, 2) then
            hero.helmUndyingLifeGiven = true
        end
    end
    if HeroHasNeutralItem(hero, "item_neutral_33") and not hero.oceanLifeGiven then
        if AddLivesToHero(hero, 1) then
            hero.oceanLifeGiven = true
        end
    end
    if HeroHasNeutralItem(hero, "item_neutral_31") and not hero.triumpABPGiven then
        hero.triumpABPGiven = true
        hero:SetAbilityPoints(hero:GetAbilityPoints() + 3)
    end
    if hero:HasModifier("modifier_special_bonus_attack_damage") then
        --AutoAttackCriticalStrike({attacker = hero, target = nil, ability = hero.combat_system_ability, aacrit_factor = 250, aacrit_chance = 100})
        --hero.combat_system_ability:ApplyDataDrivenModifier(hero, hero, "modifier_critguaranteed", {Duration = 5})
        hero.passiveAACrit = 250
    end

    if hero.talents[39] and hero.talents[39] > 0 then
        local level = hero.talents[39]
        local value = level
        local fixedheal = 75 * level
        local myevent = {caster = hero, target = hero, percenthp = value, heal = fixedheal, ability = hero.combat_system_ability}
        HealUnit(myevent)
        if hero:HasModifier("modifier_pathbuff_039") then
            if not hero.blindfold_lickwounds_heal_counter then
                hero.blindfold_lickwounds_heal_counter = 0
            end
            hero.blindfold_lickwounds_heal_counter = hero.blindfold_lickwounds_heal_counter + 1
            if hero.blindfold_lickwounds_heal_counter == 5 then
                local particle = ParticleManager:CreateParticle( "particles/items4_fx/combo_breaker_buff.vpcf", PATTACH_POINT_FOLLOW, hero )
                ParticleManager:SetParticleControl(particle, 1, hero:GetAbsOrigin())
                ParticleManager:ReleaseParticleIndex(particle)
            end
        end
    end
end

function ProcsEvery10Seconds(hero)
    if GetTidesOfTimeStat(hero) >= 1 then
        ApplyBuffStack({caster = hero, target = hero, buff = "modifier_tot", ability = hero.combat_system_ability, dur = 3, addstacks = GetTidesOfTimeStat(hero)})
    end
    --fix gold after reconnect
    SetGold( hero, GetGold(hero) )
end

function GetIntellectCustom( hero )
    --if hero:GetPrimaryAttribute() == 2 then
        return hero:GetModifierStackCount("modifier_int_custom", nil)
    --else
    --    return hero:GetIntellect()
    --end
end

function GetStrengthCustom( hero )
    --if hero:GetPrimaryAttribute() == 0 then
        return hero:GetModifierStackCount("modifier_str_custom", nil)
    --else
    --    return hero:GetStrength()
    --end
end

function GetAgilityCustom( hero )
    return hero:GetModifierStackCount("modifier_agi_custom", nil)
end

function GetPrimaryStatValueCustom( hero )
    if hero:GetPrimaryAttribute() == 2 then
        return GetIntellectCustom( hero )
    elseif hero:GetPrimaryAttribute() == 0 then
    	return GetStrengthCustom( hero )
    else
        return GetAgilityCustom( hero )
    end
end

function GetAllStats(hero)
    local value = 0
    if GetLevelOfAbility(hero, "special_bonus_unique_nether_wizard_2") >= 1 then
        value = value + 15
    end
    return value
end

function GetMaxManaCustom( hero )
    if hero.real_custom_mana then
        return hero.real_custom_mana
    end
    return hero:GetMaxMana()
end

function GetAbsorbtionFactor( hero )
    local factor = 1
    if hero.talents and hero.talents[93] then
        factor = factor + 0.1 * hero.talents[93]
    end
    return factor
end

function BloodwolfBuff(event)
    --local caster = event.caster
    --local ability = event.ability
    --local amount = caster:GetModifierStackCount("modifier_talent_beastmaster", nil)
    --for i=1,amount do
    --    ability:ApplyDataDrivenModifier(caster, caster, "modifier_bloodwolf_buff", {Duration = 15})
    --end
end

function IsImmortal(hero)
    if hero:HasModifier("modifier_godschosen") or hero:HasModifier("modifier_invul") or hero:HasModifier("modifier_shieldreflect") then
        return true
    end
    return false
end

function SetElementalItem(event)
    event.caster.elemental_item3 = event.ability
end

function AddAbilityToUnit(event)
    local caster = event.target
    local level = 1
    if COverthrowGameMode.jungledifficulty >= 10 then
        level = 2
    end
    if COverthrowGameMode.jungledifficulty >= 100 then
        level = 3
    end
    caster:AddAbility(event.abil):SetLevel(level)
    if event.setglobalowner then
        COverthrowGameMode.totemCastUnit = caster
    end
end

function SetModelForModel(event)
    local caster = event.target
    caster:SetModel(event.model)
    caster:SetOriginalModel(event.model)
end

function BlizzardEffect(event)
    local caster = event.target
    local pos = caster:GetAbsOrigin()
    local distance = event.aoe / 2
    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_crystalmaiden/maiden_freezing_field_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, pos)
    ParticleManager:ReleaseParticleIndex(particle)
    pos = pos + Vector(distance,0,0)
    particle = ParticleManager:CreateParticle("particles/units/heroes/hero_crystalmaiden/maiden_freezing_field_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, pos)
    ParticleManager:ReleaseParticleIndex(particle)
    pos = pos + Vector(-2*distance,0,0)
    particle = ParticleManager:CreateParticle("particles/units/heroes/hero_crystalmaiden/maiden_freezing_field_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, pos)
    ParticleManager:ReleaseParticleIndex(particle)
    pos = pos + Vector(distance,distance,0)
    particle = ParticleManager:CreateParticle("particles/units/heroes/hero_crystalmaiden/maiden_freezing_field_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, pos)
    ParticleManager:ReleaseParticleIndex(particle)
    pos = pos + Vector(0,-2*distance,0)
    particle = ParticleManager:CreateParticle("particles/units/heroes/hero_crystalmaiden/maiden_freezing_field_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, pos)
    ParticleManager:ReleaseParticleIndex(particle)
    EmitSoundOn("hero_Crystal.preAttack", caster)
end

function BlizzardTalent( caster, target, ignoreInnerCD )
    if caster.talents[30] <= 0 then
        return
    end
    if not ignoreInnerCD then
        caster.talent_30_cd = true
    end
    local delay = 0.25
    local aoe = 300
    local event = {target = target, aoe = 300}
    BlizzardEffect(event)
    local damage = 150
    if caster:HasModifier("modifier_pathbuff_104") then
        damage = damage * 2
    end
    event = {caster = caster, target = target, ability = caster.combat_system_ability, targetpos = 1, damage = 0, attributefactor = damage * caster.talents[30], aoe = aoe, targeteffect = "blood", isaoe = 1, delay = delay, dontbreakcc = 1, frostdmg = 1 }
    DamageAOEDelayed( event )
    Timers:CreateTimer(delay, function()
        EmitSoundOn("hero_Crystal.freezingField.explosion", caster)
        local buffevent = { caster = caster, target = target, ability = caster.combat_system_ability, aoe = aoe, targetpos = 1, buff = "modifier_slowtalent", dur = 5}
        ApplyBuffAOE(buffevent)
    end)
    if not ignoreInnerCD then
        Timers:CreateTimer(5 * GetInnerCooldownFactor(caster), function()
            caster.talent_30_cd = false
        end)
    end
    OnNaturalDisasterProcced( caster, target, 2 )
end

function ProtCounterBlow(event)
    local caster = event.caster
    if caster:HasModifier("modifier_shieldbash") and caster.q_level and caster.q_level >= 3 then
        ApplyBuffStack(event)
    end
end

function ProtCounterBlowSetLevel(event)
    local caster = event.caster
    caster.q_level = event.ability:GetLevel()
end

function BossAOESpells(event)
    local caster = event.caster
    local ability = event.ability
    local pos = caster:GetAbsOrigin()
    local aoetype = event.aoetype
    local aoe = event.aoe
    local startdelay = event.startdelay
    local tickdelay = event.tickdelay
    local movement = event.movement
    local lifetimeinticks = event.lifetimeinticks
    local aoefx = "particles/econ/items/centaur/centaur_ti6/centaur_ti6_warstomp.vpcf"
    local sound = "Hero_Tiny.Attack"
    local warningfx = event.warningfx
    local warningfxpath = "particles/econ/items/earthshaker/egteam_set/hero_earthshaker_egset/earthshaker_echoslam_start_egset.vpcf"
    local aoeamount = event.aoeamount
    local dmg = event.dmg
    if event.theme == "rock" then
        aoefx = "particles/units/heroes/hero_centaur/centaur_warstomp.vpcf"
    end
    if event.theme == "water" then
        aoefx = "particles/econ/items/kunkka/divine_anchor/hero_kunkka_dafx_skills/kunkka_spell_torrent_splash_fxset.vpcf"
        sound = "hero_Crystal.projectileImpact"--"Ability.GushCast"
        warningfxpath = "particles/econ/items/kunkka/divine_anchor/hero_kunkka_dafx_skills/kunkka_spell_torrent_splash_fxset.vpcf"
    end
    if event.theme == "water2" then
        aoefx = "particles/econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship_impact.vpcf"
        sound = "hero_Crystal.projectileImpact"--"Ability.GushCast"
        warningfxpath = "particles/econ/items/kunkka/divine_anchor/hero_kunkka_dafx_skills/kunkka_spell_torrent_splash_fxset.vpcf"
    end
    if event.theme == "frost" then
        aoefx = "particles/units/heroes/hero_crystalmaiden/maiden_freezing_field_explosion.vpcf"
        sound = "hero_Crystal.projectileImpact"
        warningfxpath = "particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf"
    end
    if event.theme == "thunder" then
        aoefx = "particles/units/heroes/hero_zeus/zeus_cloud_strike.vpcf"
        sound = "Item.Maelstrom.Chain_Lightning.Jump"
        warningfxpath = "particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf"
    end
    if event.theme == "frost_big" then
        aoefx = "particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf"
        sound = "hero_Crystal.projectileImpact"
        warningfxpath = "particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf"
    end
    if event.rootboss then
        caster:ApplyDataDrivenModifier(caster, caster, "modifier_rooted", {Duration = event.rootboss})
    end
    if warningfx then
        EmitSoundOn("DOTA_Item.HeavensHalberd.Activate", caster)
        local particle = ParticleManager:CreateParticle(warningfxpath, PATTACH_ABSORIGIN_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 1, Vector(600,1,1))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    for j=1,aoeamount do
        Timers:CreateTimer(startdelay, function()
            if aoetype == "outercircle_innercircle" then
                local radius = 600
                local offset_start = math.random(0,359)
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(i-1), function()
                        if i > lifetimeinticks / 2 then
                            radius = 200
                        end
                        local strikepos = pos + Vector(radius*math.cos(math.rad(offset_start+2*i*360/lifetimeinticks)), radius*math.sin(math.rad(offset_start+2*i*360/lifetimeinticks)), 0)
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,aoe,aoe))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = aoe
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
            if aoetype == "spiral_in_random" then
                local offset_start = math.random(0,359)
                local strikepos = pos
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(lifetimeinticks-i), function()
                        local degree = offset_start+i*20
                        local rad = math.rad(offset_start+i*20)
                        local cos = math.cos(degree)
                        strikepos = strikepos + Vector((lifetimeinticks-i)*movement*math.cos(math.rad(offset_start+i*20)), (lifetimeinticks-i)*movement*math.sin(math.rad(offset_start+i*20)), 0)
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,aoe,aoe))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = 225
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
            if aoetype == "spiral_out_random" then
                local offset_start = math.random(0,359)
                local strikepos = pos
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(i-1), function()
                        strikepos = strikepos + Vector(i*movement*math.cos(math.rad(offset_start+i*20)), i*movement*math.sin(math.rad(offset_start+i*20)), 0)
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,aoe,aoe))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = 225
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
            if aoetype == "from_out_inwards" then
                local offset_start = math.random(0,359)
                local strikepos = pos + Vector(1500*math.cos(math.rad(offset_start)), 1500*math.sin(math.rad(offset_start)), 0)
                local direction = (pos - strikepos):Normalized()
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(i-1), function()
                        strikepos = strikepos + i*movement*direction
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,aoe,aoe))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = 225
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
            if aoetype == "random" then
                local offset_start = math.random(0,359)
                local strikepos = pos + Vector(math.random(150,200)*math.cos(math.rad(offset_start)), math.random(150,200)*math.sin(math.rad(offset_start)), 0)
                local path_direction = Vector(0,0,0) + RandomVector(1)
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(i-1), function()
                        strikepos = strikepos + movement*path_direction
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,aoe,aoe))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = 225
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
            if aoetype == "circleoutin" then
                local offset_start = math.random(0,359)
                local strikepos = pos
                local distance = 0
                local distance_per_tick = 30
                local angle = 0
                local angle_per_tick = 15
                local path_direction = Vector(0,0,0) + RandomVector(1)
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(i-1), function()
                        distance = distance + distance_per_tick
                        angle = angle + angle_per_tick
                        if i == math.floor(lifetimeinticks / 2) then
                            distance_per_tick = -1 * distance_per_tick
                        end
                        strikepos = pos + RotateVectorAroundAngle(Vector(1,0,0), angle) * distance
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,1,1))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = event.aoe
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
            if aoetype == "forwardandcircle" then
                local startpos = pos - caster:GetForwardVector() * 2000
                local radius = 650
                local angle = 0
                local angle_per_tick = 25
                local forward_per_tick = 25
                local path_direction = (pos - startpos):Normalized()
                lifetimeinticks = 150
                tickdelay = 0.2
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(i-1), function()
                        angle = angle + angle_per_tick
                        local strikepos = startpos + RotateVectorAroundAngle(Vector(1,0,0), angle) * radius + path_direction * i * forward_per_tick
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 3, strikepos)
                        --ParticleManager:SetParticleControl(particle, 1, Vector(aoe,1,1))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = event.aoe
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
            if aoetype == "forwardrandom" then
                local strikepos = pos
                local path_direction = Vector(0,0,0) + RandomVector(1)
                local angle_max = 15
                movement = 50
                for i=1, lifetimeinticks do
                    Timers:CreateTimer(tickdelay*(i-1), function()
                        strikepos = strikepos + movement*path_direction
                        path_direction = RotateVectorAroundAngle(path_direction, math.random(-angle_max, angle_max))
                        angle_max = angle_max + 3
                        local particle = ParticleManager:CreateParticle(aoefx, PATTACH_WORLDORIGIN, caster)
                        ParticleManager:SetParticleControl(particle, 0, strikepos)
                        ParticleManager:SetParticleControl(particle, 1, strikepos + Vector(0,0,450))
                        ParticleManager:SetParticleControl(particle, 6, Vector(1,1,1))
                        ParticleManager:ReleaseParticleIndex(particle)
                        EmitSoundOn(sound, caster)
                        local tab = {}
                        tab.caster = caster
                        tab.damage = 0.0
                        tab.spelldamagefactor = 0.0
                        tab.attributefactor = 0.0
                        tab.includeauto = dmg
                        tab.ability = ability
                        tab.aoe = 225
                        tab.targeteffect = "blood"
                        tab.onlyhero = 1
                        tab.target_points = {}
                        tab.target_points[1] = strikepos
                        DamageAOE(tab)
                    end)
                end
            end
        end)
    end
end

function HeartBuffItem( event )
    local caster = event.caster
    local target = event.target
    if event.target ~= event.caster then
        event.ability:ApplyDataDrivenModifier(caster, target, event.buff, {Duration = event.dur})
    end
end

function TalentOnAttacked( event )
    local caster = event.caster
    local attacker = event.attacker
    local corSkinStacks = GetCorrosiveSkinStat(caster)
    if corSkinStacks >= 1 then
        ApplyBuffStack({caster = caster, target = attacker, ability = caster.combat_system_ability, buff = "modifier_corrosive_skin2", dur = 10, addstacks = corSkinStacks, max = corSkinStacks})
    end
    if caster.talents then
        if caster.talents[104] and caster.talents[104] > 0 and math.random(1,100) <= 2.5 + 2.5 * caster.talents[104] then
            ApplyBuff({caster = caster, target = attacker, ability = caster.combat_system_ability, dur = 3, buff = "modifier_icenova"})
        end
        if caster.talents[145] and caster.talents[145] > 0 and not caster.elusiveness then
            ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = 2 + caster.talents[145], buff = "modifier_elusiveness"})
            caster.elusiveness = true
            Timers:CreateTimer(45 * GetInnerCooldownFactor(caster), function()
                caster.elusiveness = false
            end)
        end
        local abil = caster:FindAbilityByName("shadow5")
        if abil and abil:GetLevel() >= 2 and not caster.shadow5CDS then
            caster.shadow5CDS = true
            ApplyBuff({caster = caster, target = attacker, ability = abil, buff = "modifier_fearsp_bonus", dur = 3})
            Timers:CreateTimer(15 * GetInnerCooldownFactor(caster), function()
                caster.shadow5CDS = false
            end)
        end
    end
    --[[
    if caster.talents then
        if and caster.talents[12] and caster.talents[12] > 0 then
            local talent_level = caster.talents[12]
            if not caster:HasModifier("modifier_talent12cd") and caster ~= attacker then
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_talent12cd", { Duration = 85-5*caster.talents[12]})
                local particle = ParticleManager:CreateParticle("particles/items_fx/necronomicon_spawn_warrior.vpcf", PATTACH_POINT_FOLLOW, attacker)
                ParticleManager:ReleaseParticleIndex(particle)
                local myevent = {}
                myevent.caster = caster
                myevent.target = attacker
                myevent.ability = event.ability
                myevent.damage = 0.0
                myevent.spelldamagefactor = 0.0
                myevent.attributefactor = 0.0
                myevent.counterblow = 100
                DamageUnit(myevent)
                local myevent2 = {}
                myevent2.caster = caster
                myevent2.target = attacker
                myevent2.buff = "modifier_stunned"
                myevent2.ability = event.ability
                myevent2.dur = 6
                ApplyBuff(myevent2)
                --caster.path_counterclaw = true
                --Timers:CreateTimer(15, function()
                --    caster.path_counterclaw = false
                --end)
            end
        end
    end]]
end

function ReduceHighestRemainingCD( event )
    local caster = event.caster
    local ab_cd = GetHighestRemainingCooldownAbility(caster)
    if ab_cd then
        local myevent = {caster = caster, amount = event.amount, ability = ab_cd }
        ReduceCooldown(myevent)
    end
end

function TalentOnAttackStart( event ) --for crits
    local caster = event.attacker
    local target = event.target
    local ability = event.ability
    if caster.talents then
        --AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 200, aacrit_chance = 100})
        if caster.passiveAACrit then
            caster.passiveAACrit = false
            AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 250, aacrit_chance = 100})
            --CheckForAutoAttackCriticalStrikeProcs(caster, target)
        end
    end
end

function TalentOnAttack( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local has_windfury_item = (caster:HasModifier("modifier_item_windfury") or caster:HasModifier("modifier_item_windfury_2"))
    --aa stats tracking
    if caster.ability_stats then
        if not caster.ability_stats[6] then
            caster.ability_stats[6] = 0
        end
        caster.ability_stats[6] = caster.ability_stats[6] + event.damage
    end
    if caster.talents then
        if caster.talents[146] and caster.talents[146] > 0 then
            if not caster.dualWieldCD then
                caster.dualWieldCD = true
                PerformAutoAttackWithDelay( caster, target, 0.2 )
                local innercd = (5 - caster.talents[146]) * GetInnerCooldownFactor(caster)
                if innercd < 1 then
                    innercd = 1
                end
                Timers:CreateTimer(innercd, function()
                    caster.dualWieldCD = false
                end)
            end
        end
        if caster.talents[90] and caster.talents[90] > 0 then
            local ab_cd = GetHighestRemainingCooldownAbility(caster)
            if ab_cd then
                local myevent = {caster = caster, amount = 0.1 * caster.talents[90], ability = ab_cd }
                ReduceCooldown(myevent)
            end
        end
        if caster.talents[54] and caster.talents[54] > 0 then
            caster.tiger_fury_next_abi_bonus = 1 + 0.15 * caster.talents[54]
            AddHeroResource({caster = caster, amount = (0.5 + 0.5 * caster.talents[54]), percent = true, energy = 0.5 + 0.5 * caster.talents[54], energypercent = true})
        end
        if caster.talents[53] and caster.talents[53] > 0 and not caster.talent_cd_53 then
            local talent_level = caster.talents[53]
            local windfury_attacks = 2
            if has_windfury_item then
                windfury_attacks = windfury_attacks + 1
            end
            local bonus_chances = 1
            if caster:HasModifier("modifier_pathbuff_071") and caster:HasModifier("modifier_path_overwhelm") then
                bonus_chances = 2
            end
            if math.random(1,100) <= talent_level * 2 * bonus_chances then
                local windCD = 1
                if caster:HasModifier("modifier_pathbuff_053") and caster:HasModifier("modifier_windbreaker") then
                    windCD = 0.5
                end
                windCD = windCD * GetInnerCooldownFactor(caster)
                ApplyBuffStack({caster = caster, target = caster, ability = caster.combat_system_ability, dur = 5, buff = "modifier_windfury_path", addstacks = talent_level, max = talent_level})
                caster.talent_cd_53 = true
                local particle = ParticleManager:CreateParticle("particles/econ/items/sven/sven_ti7_sword/sven_ti7_loadout_burst.vpcf", PATTACH_POINT_FOLLOW, caster)
                ParticleManager:ReleaseParticleIndex(particle)
                local delay = 0
                if caster:IsRangedAttacker() then
                    windfury_attacks = windfury_attacks + 1
                    delay = 1
                end
                for i=1, windfury_attacks do
                    Timers:CreateTimer(0.15*(i-delay), function()
                        CheckForAutoAttackCriticalStrikeProcs(caster, target)
                        caster:PerformAttack(target, true, true, true, true, true, false, false)
                    end)
                end
                Timers:CreateTimer(windCD, function()
                    caster.talent_cd_53 = false
                end)
            end
        end
        if caster.talents[78] and caster.talents[78] > 0 then
            ApplyBuffStack({caster = caster, target = caster, ability = ability, dur = 30, buff = "modifier_stormclaws", max = 5})
        end
        if caster.talents[87] and caster.talents[87] > 0 then
            PathStormStrikeProc(caster, target, true, false, false, false)
        end
        if caster.talents[149] and caster.talents[149] > 0 then
            if target == caster.last_attack_target then
                if not caster.markedForDeath then
                    caster.markedForDeath = 0
                end
                caster.markedForDeath = caster.markedForDeath + 1
                if caster.markedForDeath >= 25 then
                    caster.markedForDeath = 0
                    ApplyBuff({caster = caster, target = target, ability = caster.combat_system_ability, dur = caster.talents[149], buff = "modifier_mfd"})
                end
            else
                caster.markedForDeath = 0
            end
        end
    end
    if caster and has_windfury_item and not caster.item_windfury then
        caster.item_windfury = true
        local particle = ParticleManager:CreateParticle("particles/econ/items/sven/sven_ti7_sword/sven_ti7_loadout_burst.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        if caster.item_windfury_ability_1 and not caster.item_windfury_ability_1:IsNull() then
            caster.item_windfury_ability_1:StartCooldown(10)
        end
        if caster.item_windfury_ability_2 and not caster.item_windfury_ability_2:IsNull() then
            caster.item_windfury_ability_2:StartCooldown(10)
        end
        local strikes = 4
        if caster:IsRangedAttacker() then
            strikes = 3
        end
        for i=1,strikes do
            Timers:CreateTimer(0.15*i, function()
                caster.windfury_proc_crit_bonus = true
                CheckForAutoAttackCriticalStrikeProcs(caster, target)
                caster:PerformAttack(target, true, true, true, true, true, false, false)
                if i == strikes then
                    Timers:CreateTimer(0.25, function() --some extra time for projectiles to fly
                        caster.windfury_proc_crit_bonus = false
                    end)
                end
            end)
        end
        Timers:CreateTimer(10, function()
            caster.item_windfury = nil
        end)
    end
    caster.last_attack_target = target
end

function Multistrike( event )
    for i=1,event.hits do
        Timers:CreateTimer(0.15*i, function()
            if not event.caster:IsRangedAttacker() and event.target and not event.target:IsNull() then
                local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf", PATTACH_POINT_FOLLOW, event.target)
                ParticleManager:ReleaseParticleIndex(particle)
                 EmitSoundOn("DOTA_Item.DiffusalBlade.Activate", event.target)
            end
            if event.target and not event.target:IsNull() then
                CheckForAutoAttackCriticalStrikeProcs(event.caster, event.target)
                event.caster:PerformAttack(event.target, true, true, true, true, true, false, false)
            end
        end)
    end
end

function SetWindfuryItem( event )
    if event.id == 1 then
        event.caster.item_windfury_ability_1 = event.ability
    end
    if event.id == 2 then
        event.caster.item_windfury_ability_2 = event.ability
    end
end

function SetBloodlustItem( event )
    event.caster.item_bloodlust_ability = event.ability
end

function SetArmorKnowledgeItem( event )
    event.caster.item_armor_knowledge_ability = event.ability
end

function SetHorrorItem( event )
    event.caster.item_horror_ability = event.ability
end

function SetMultiElementItem( event )
    event.caster.item_multi_element_ability = event.ability
end

function GetManaRefundAmount( hero )
    local refund = 0
    if GetManawormStat(hero) >= 1 then
        refund = refund + GetManawormStat(hero)
    end
    return refund
end

function DH2( event )
    local caster = event.caster
    local target = caster.last_attack_target
    if target and not target:IsNull() and target:IsAlive() and caster:GetMana() >= 50 and (caster:GetAbsOrigin()-target:GetAbsOrigin()):Length() <= 175 then
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_dh2_toggle_proc", nil)
    end
end

function OnApplyDebuff(event)
    local caster = event.caster
    local target = event.target
    if caster.talents then
        if caster.talents[111] and caster.talents[111] > 0 then
            local buff = "modifier_overgrowth"
            local dot_dur = 5
            local myevent = { caster = caster, target = caster, dur = dot_dur, buff = buff, ability = caster.combat_system_ability, addstacks = 1, max = caster.talents[111] * 10}
            ApplyBuffStack(myevent)
        end
        if GetLevelOfAbility(caster, "terror1") >= 4 and event.buff and event.buff == "modifier_stunned" then
            HealUnit({caster = caster, target = caster, ability = event.ability, heal = caster:GetMaxHealth()*0.05})
        end
    end
    --[[
    if false and caster.talents and caster.talents[49] and caster.talents[49] > 0 then
        local myevent = {}
        myevent.caster = caster
        myevent.target = target
        myevent.ability = event.ability
        myevent.damage = 0.0
        myevent.spelldamagefactor = 0.0
        myevent.attributefactor = 20 * caster.talents[49]
        Timers:CreateTimer(0.01*math.random(25,75), function()
            DamageUnit(myevent)
        end)
    end]]
    if event.buff == "modifier_stunned" then
        OnStunEnemy(event)
    end
end

function OnStunEnemy(event)
    local caster = event.caster
    local target = event.target
    if caster:HasModifier("modifier_warrior_3") then
        local myevent = { caster = caster, target = target, dur = 5, buff = "modifier_warrior3dot", ability = caster:FindAbilityByName("warrior_3"), settickrate = 1}
        ApplyBuff(myevent)
    end
end

function GetSoulItemTalent(hero)
    local result = {{0,0},{0,0},{0,0}}
    local has_ravencraft_abilitypoint_soul_equipped = false
    for i=1,3 do
        local item = hero:GetItemInSlot(5+i)
        if item and not item:IsMuted() then
            item = item:GetName()
            --print(item)
            if item and string.len(item) == 20 and string.sub(item, 1, 13) == "item_mastery_" then
                local talent = tonumber(string.sub(item, 14, 16))
                if talent and talent == 4 then
                    talent = 6
                elseif talent and talent == 5 then
                    talent = 4
                elseif talent and talent == 6 then
                    talent = 5
                end
                local talent_level = tonumber(string.sub(item, 18, 20))
                --if talent_level and talent_level > 1 and talent and (talent == 28) then --timebender
                --    talent_level = 1
                --end
                local talent_tree = COverthrowGameMode:GetTalentTreeByTalentPoint( talent )
                if talent_tree and hero:HasModifier("modifier_path_soul_bonus_" .. tostring(talent_tree)) then
                    talent_level = talent_level + 1
                end
                --riki +1 talent
                local riki_talent = hero:FindAbilityByName("hawk2")
                if i == 1 and riki_talent and riki_talent:GetLevel() >= 4 then
                    talent_level = talent_level + 1
                end
                if i == 1 and hero.talents[105] and hero.talents[105] >= 1 and talent ~= 105 then
                    talent_level = talent_level + math.floor((hero.talents[105] + 2) / 3)
                end
                if i == 2 and hero.talents[105] and hero.talents[105] >= 2 and talent ~= 105 then
                    talent_level = talent_level + math.floor((hero.talents[105] + 1) / 3)
                end
                if i == 3 and hero.talents[105] and hero.talents[105] >= 3 and talent ~= 105 then
                    talent_level = talent_level + math.floor(hero.talents[105] / 3)
                end
                if i == 3 and hero:HasModifier("modifier_item_item_set_t4_aad_5") then
                    talent_level = talent_level + 1
                end
                if talent == 88 then
                    hero.has_used_ravencraft_abilitypoint_soul = true
                    has_ravencraft_abilitypoint_soul_equipped = true
                end
                result[i] = {talent, talent_level }
            end
        end
    end
    if hero.has_used_ravencraft_abilitypoint_soul and not has_ravencraft_abilitypoint_soul_equipped then
        return {{0,0},{0,0},{0,0}}
    end
    return result --test {{3,5},{54,5},{0,0}}
end

function AddHeroResource(event)
    local hero = event.caster
    if event.buffcondition and not hero:HasModifier(event.buffcondition) then
        return
    end
    if hero.resourcesystem and hero.resourcesystem > 0 then
        --non mana user
        if event.energypercent then
            event.energy = GetMaxEnergy(event)  * event.energy / 100
        end
        AddEnergy(event)
    else
        --mana user
        if event.cancel_on_mana_class then
            return
        end
        RestoreMana(event)
    end
end

function SpikeTrapActivate( event )
    local caster = event.caster
    local ability = event.ability
    --local triggerName = "temple_spike_trap" --caster:GetName()
    --local spikes = triggerName .. "_model"
    if not caster.trap_cooldown then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_dmg_aoe_trap", nil)
        caster.trap_cooldown = true
        --StartAnimation(caster, {activity=ACT_DOTA_CAST_ABILITY_4, duration=2.0, rate=0.5})
        --EmitSoundOn( "Conquest.SpikeTrap.Plate" , caster)
        --DoEntFire( spikes, "SetAnimation", "spiketrap_activate", 0, self, self )
        Timers:CreateTimer(2, function()
            caster.trap_cooldown = nil
        end)
    end
end

function MissileTrapActivate( event )
    local caster = event.caster
    if not IsEnemyInRange(caster, 5000) then
        return
    end
    local ability = event.ability
    local activate_every = 3
    local missile_fx = "particles/fireball_linear_4.vpcf"
    local sound = "Hero_Lina.PreAttack"
    local distance = 3500
    local speed = 900
    local aoe = 0
    local width = 75
    local width_end = 75
    local cone = false
    local turnspeed = 0
    local directionChange = 1
    if caster.trap_element and caster.trap_element == "shadow" then
        missile_fx = "particles/fireball_linear_4.vpcf"
        activate_every = 6
    end
    if caster.trap_element and caster.trap_element == "shadowshort" then
        missile_fx = "particles/fireball_linear_4.vpcf"
        activate_every = 6
        distance = 1500
        speed = 600
    end
    if caster.trap_element and caster.trap_element == "water" then
        missile_fx = "particles/units/heroes/hero_morphling/morphling_waveform.vpcf"
        distance = 6000
        speed = 750
    end
    if caster.trap_element and caster.trap_element == "ice" then
        missile_fx = "particles/units/heroes/hero_tusk/tusk_ice_shards_projectile.vpcf"
    end
    if caster.trap_element and caster.trap_element == "poison" then
        missile_fx = "particles/units/heroes/hero_venomancer/venomancer_venomous_gale.vpcf"
        activate_every = 10
    end
    if caster.trap_element and caster.trap_element == "5darts" then
        missile_fx = "particles/units/heroes/hero_windrunner/windrunner_spell_powershot.vpcf"
        aoe = 5
        speed = 600 --900
    end
    if caster.trap_element and caster.trap_element == "3skulls" then
        missile_fx = "particles/fireball_linear_5.vpcf"
        activate_every = 2
        distance = 2000
        speed = 400 --500
        aoe = 3
    end
    if caster.trap_element and caster.trap_element == "1fire" then
        missile_fx = "particles/units/heroes/hero_dragon_knight/dragon_knight_breathe_fire.vpcf"
        sound = "Hero_Lina.DragonSlave"
        distance = 2500
        speed = 450 --550
        width = 150
        width_end = 350
        cone = true
    end
    if caster.trap_element and caster.trap_element == "1fireturn" then
        missile_fx = "particles/units/heroes/hero_dragon_knight/dragon_knight_breathe_fire.vpcf"
        sound = "Hero_Lina.DragonSlave"
        distance = 2500
        speed = 450 --550
        width = 150
        width_end = 350
        cone = true
        activate_every = 2
        turnspeed = math.random(2,10)
        if math.random(1,100) <= 50 then
            turnspeed = - turnspeed
        end
    end
    if caster.trap_element and caster.trap_element == "2frostturn" then
        missile_fx = "particles/fireball_linear_6.vpcf"
        sound = "Hero_Lina.DragonSlave"
        distance = 2500
        speed = 450
        width = 150
        width_end = 150
        cone = false
        activate_every = 3
        turnspeed = math.random(2,10)
        if math.random(1,100) <= 50 then
            turnspeed = - turnspeed
        end
    end
    if caster.trap_element and caster.trap_element == "5dartsshort" then
        missile_fx = "particles/venomancer_venomous_gale_viper.vpcf"
        aoe = 5
        distance = 2000
        speed = 550
    end
    if caster.trap_element and caster.trap_element == "5dartsshortrandom" then
        missile_fx = "particles/venomancer_venomous_gale_viper.vpcf"
        aoe = 5
        distance = 2000
        speed = 550
        activate_every = 1
        if math.random(1,100) <= 50 then
            directionChange = -1
        end
    end
    if caster.trap_element and caster.trap_element == "5darts_ice" then
        missile_fx = "particles/units/heroes/hero_tusk/tusk_ice_shards_projectile.vpcf"
        aoe = 5
    end
    if caster.trap_element and caster.trap_element == "5darts_water" then
        missile_fx = "particles/units/heroes/hero_morphling/morphling_waveform.vpcf"
        aoe = 5
    end
    if caster.trap_element and caster.trap_element == "5darts_shadow" then
        missile_fx = "particles/fireball_linear_4.vpcf"
        aoe = 5
    end
    if caster.trap_element and caster.trap_element == "fire" then
        missile_fx = "particles/fireball_linear_2.vpcf"
        speed = 400
    end
    if caster.trap_timer_set then
        activate_every = caster.trap_timer_set
    end
    if caster.trap_timer then
        caster.trap_timer = caster.trap_timer + 1
        if caster.trap_timer < activate_every then
            return
        end
    else
        caster.trap_timer = 1
        return
    end
    caster.trap_timer = 0
    EmitSoundOn(sound, caster)
    if aoe == 0 then
        local info = 
        {
            Ability = ability,
            EffectName = missile_fx,
            vSpawnOrigin = caster:GetAbsOrigin()+Vector(0,0,75),
            fDistance = distance,
            fStartRadius = width,
            fEndRadius = width_end,
            Source = caster,
            bHasFrontalCone = cone,
            bReplaceExisting = false,
            iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
            iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
            iUnitTargetType = DOTA_UNIT_TARGET_HERO,
            fExpireTime = GameRules:GetGameTime() + 60.0,
            bDeleteOnHit = false,
            vVelocity = speed * caster:GetForwardVector():Normalized(),
            bProvidesVision = true,
            iVisionRadius = 1000,
            iVisionTeamNumber = caster:GetTeamNumber()
        }
        local projectile = ProjectileManager:CreateLinearProjectile(info)
    end
    if aoe == 3 or aoe == 5 then
        for i=1, aoe do
            local shoot_vector = speed * directionChange * caster:GetForwardVector():Normalized()
            local angle = 30 * (i-(0.5+aoe/2))
            shoot_vector = RotateVectorAroundAngle(shoot_vector, angle)
            local info = 
            {
                Ability = ability,
                EffectName = missile_fx,
                vSpawnOrigin = caster:GetAbsOrigin()+Vector(0,0,75),
                fDistance = distance,
                fStartRadius = 75,
                fEndRadius = 75,
                Source = caster,
                bHasFrontalCone = false,
                bReplaceExisting = false,
                iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
                iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                iUnitTargetType = DOTA_UNIT_TARGET_HERO,
                fExpireTime = GameRules:GetGameTime() + 60.0,
                bDeleteOnHit = false,
                vVelocity = shoot_vector,
                bProvidesVision = true,
                iVisionRadius = 1000,
                iVisionTeamNumber = caster:GetTeamNumber()
            }
            local projectile = ProjectileManager:CreateLinearProjectile(info)
        end
    end
    if caster.random_new_direction then
        local new_vec = RandomVector(1.0)
        local result = Vector(new_vec[1],new_vec[2],0)
        Timers:CreateTimer(1, function()
            if caster and not caster:IsNull() then
                caster:SetForwardVector(result)
            end
        end)
    end
    if turnspeed ~= 0 and not caster.trap_has_turning_enabled then
        caster.trap_has_turning_enabled = true
        Timers:CreateTimer(0.03, function()
            if caster and not caster:IsNull() then
                local new_vec = RotateVectorAroundAngle(caster:GetForwardVector(), turnspeed)
                caster:SetForwardVector(new_vec)
                return 0.03
            end
        end)
    end
end

function IsEnemyInRange( unit, distance )
    if unit and not unit:IsNull() then
        local enemies = FindUnitsInRadius( unit:GetTeamNumber(), unit:GetAbsOrigin(), unit, distance, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_ALL, 0, 0, false )
        if #enemies > 0 then
            for _,enemy in pairs(enemies) do
                --print((unit:GetAbsOrigin()-enemy:GetAbsOrigin()):Length())
                return true
            end
        end
    end
    return false
end

function RotateVectorAroundAngle( vec, angle )
    local x = vec[1]
    local y = vec[2]
    angle = angle * 0.01745
    local vec2 = Vector(0,0,0)
    vec2[1] = x * math.cos(angle) - y * math.sin(angle)
    vec2[2] = x * math.sin(angle) + y * math.cos(angle)
    return vec2
end

function ProcBuffAfterXAttacks( event )
    local caster = event.attacker
    if not caster.proc_attack_counter then
        caster.proc_attack_counter = 1
    else
        caster.proc_attack_counter = caster.proc_attack_counter + 1
    end
    if caster.proc_attack_counter >= 10000000 then
        caster.proc_attack_counter = 0
    end
    if caster.proc_attack_counter % event.attacks == 0 then
        event.ability:ApplyDataDrivenModifier(caster, event.target, event.buff, nil)
    end
end

function GetRandomMonsterNameByAct(act)
    act_monsters = {}
    act_monsters[1] = {
        "temple_wolf",
        "temple_wolf_brown",
        "temple_wolf_rage"
    }
    act_monsters[2] = {
        "temple_sand_dustlord",
        "temple_sand_dustboar",
        "temple_sand_stonegolem",
        "temple_sand_dustgolem"
    }
    act_monsters[3] = {
        "temple_fungal_spawn",
        "temple_fungal_slark",
        "temple_fungal_morph",
        "temple_fungal_morph",
        "temple_fungal_slardar",
        "temple_fungal_ancient"
    }
    act_monsters[4] = {
        "temple_shadow_melee",
        "temple_shadow_archer",
        "temple_shadow_undying",
        "temple_shadow_nightspider",
        "temple_shadow_colossus",
        "temple_shadow_demon"
    }
    act_monsters[5] = {
        "temple_dragon_jakiro",
        "temple_dragon_garg",
        "temple_dragon_garg2",
        "temple_dragon_melee"
    }
    act_monsters[6] = {
        "temple_mount_fireele",
        "temple_mount_archer",
        "temple_mount_tree",
        "temple_mount_plant",
        "temple_mount_wisp"
    }
    act_monsters[7] = {
        "temple_tomb_spider",
        "temple_tomb_skeleton",
        "temple_tomb_shadow",
        "temple_tomb_bug"
    }
    act_monsters[8] = {
        "temple_volcano_fireborn",
        "npc_dota_creature_imp_volcano",
        "temple_volcano_flameborn"
    }
    act_monsters[9] = {
        "temple_mogushan_ranged",
        "temple_mogushan_melee",
        "temple_mogushan_runner"
    }
    act_monsters[10] = {
        "temple_tomb_shadow"
        --"temple_volcano_fireele"
        --"temple_shadow_spectre"
    }
    act_monsters[11] = {
        "temple_shadow_spectre_2",
        "temple_shadow_archer"
    }
    act_monsters[12] = {
        "temple_jungle_raptor",
        "temple_jungle_viper",
        "temple_jungle_spider",
        "temple_jungle_troll"
    }
    act_monsters[13] = {
        "act13_1",
        "act13_2",
        "act13_3",
        "act13_4",
        "act13_5",
        "act13_6"
    }
    if act_monsters[act] and act_monsters[act][1] then
        return act_monsters[act][math.random(1,#act_monsters[act])]
    end
    return "temple_wolf"
end

function SpawnMonsterSwarm( act, min_count, max_count, triggering_unit, random_offset, target_to_attack, chance_for_champion, attack_random_hero, spawn_point_list, pvescale )
    local count = math.random(min_count,max_count)
    if count <= 0 then
        count = 1
    end
    local position
    if triggering_unit then
        position = triggering_unit.swarm_on_death_position
    end
    if not position then
        position = Vector(0,0,0)
    end
    local order_position
    if triggering_unit and not triggering_unit:IsNull() then
        order_position = triggering_unit:GetAbsOrigin()
    end
    local scale = 1
    if triggering_unit and triggering_unit.pvescale then
        scale = triggering_unit.pvescale
    end
    if pvescale then
        scale = pvescale
    end
    local order_delay = 0.1
    local jump_time = 2
    if triggering_unit and not triggering_unit:IsNull() and triggering_unit.swarm_on_death_jumptolocation then
        order_delay = order_delay + jump_time
    end
    local unit_name = GetRandomMonsterNameByAct(act)
    for i=1, count do
        if triggering_unit and not triggering_unit:IsNull() and triggering_unit.swarm_on_death_force_unit_type then
            unit_name = triggering_unit.swarm_on_death_force_unit_type
        end
        if random_offset then
            position = position + RandomVector(random_offset)
        end
        if spawn_point_list then
            position = spawn_point_list[math.random(1,#spawn_point_list)]
        end
        if triggering_unit and triggering_unit.spawn_point_list then
            position = triggering_unit.spawn_point_list[math.random(1,#triggering_unit.spawn_point_list)]
        end
        local unit = CreateUnitByName(unit_name, position+RandomVector(150.0), true, nil, nil, DOTA_TEAM_BADGUYS )
        local dmg = 75
        local hp = 2000/count
        if chance_for_champion and i == count - 1 and math.random(1,100) <= 5 and scale > 1 then
            dmg = 50
            hp = 2500
            unit.chance_for_champion = 100--5% for 2 nd champion
            unit:SetModelScale(1.25*unit:GetModelScale())
        end
        if chance_for_champion and i == count and math.random(1,100) <= 50 and scale > 1 then
            dmg = 100
            hp = 1500
            unit.chance_for_champion = 100
            unit:SetModelScale(1.15*unit:GetModelScale())
        end
        unit.act = act
        COverthrowGameMode:SetTempleStats(unit,scale,dmg,hp,25/count,0)
        local ability = unit:FindAbilityByName("pveboss_system")
        if ability then
            ability:ApplyDataDrivenModifier(unit, unit, "modifier_phased", {Duration = 0.25})
        end
        local order = 
        {
            UnitIndex = unit:entindex(),
            OrderType = DOTA_UNIT_ORDER_ATTACK_MOVE,
            Position = order_position,
            Queue = false
        }
        if target_to_attack and not target_to_attack:IsNull() and target_to_attack:IsAlive() then
            order = 
            {
                UnitIndex = unit:entindex(),
                OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                TargetIndex = target_to_attack:entindex(),
                Queue = false
            }
        end

        if attack_random_hero then
            local all = HeroList:GetAllHeroes()
            local hero_to_attack = all[math.random(1,#all)]
            if hero_to_attack then
                order = 
                {
                    UnitIndex = unit:entindex(),
                    OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                    TargetIndex = hero_to_attack:entindex(),
                    Queue = false
                }
            end
        end
        Timers:CreateTimer(order_delay, function()
            ExecuteOrderFromTable(order)
        end)
        if triggering_unit and triggering_unit.swarm_on_death_jumptolocation then
            Timers:CreateTimer(0.3, function()
                --local target_points = {}
                --target_points[1] = order_position + RandomVector(300)
                --local myevent = {caster = unit, target_points = target_points, crush = 1, upintheair = 2, jumpdur = 2}
                --KnockBack(myevent)
                --LeapToLocation( unit, order_position, 1.5 )
                LeapToLocation( unit, order_position+RandomVector(150), jump_time)
            end)
        end
        local particle = ParticleManager:CreateParticle("particles/econ/events/fall_major_2016/force_staff_fm06_dust.vpcf", PATTACH_POINT_FOLLOW, unit)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function ApplyBuffStackStandingStill( event )
    local caster = event.caster
    local buff = event.buff
    if caster:IsMoving() then
        caster:RemoveModifierByName(buff)
    else
        ApplyBuffStack(event)
    end
end

function SmoothCurve( x )
    return -(x*x) + 1
end

function LeapToLocation( unit, target_position, duration )
    local start_position = unit:GetAbsOrigin()
    --unit:SetForwardVector((target_position-start_position):Normalized())
    EmitSoundOn("Item.Bullwhip.Cast", unit)
    target_position = GetGroundPosition(target_position, unit)
    local distance_to_travel = (target_position - start_position):Length()
    local ticks = 30*duration
    local height = 200
    for i=1, ticks do
        Timers:CreateTimer(0.03*i, function()
            if unit and (not unit:IsNull()) and unit:IsAlive() and ticks > 0 then
                local new_position = start_position * (ticks - i) / ticks + target_position * i / ticks
                local normalized_x = SmoothCurve(-1 + i * 2 / ticks)
                new_position[3] = GetGroundHeight(new_position, unit) + normalized_x * height --height - height * math.abs(ticks/2-i) / (ticks/2) 
                unit:SetAbsOrigin(new_position)
            end
        end)
    end
    local ability = unit:FindAbilityByName("pveboss_system")
    if ability then
        ability:ApplyDataDrivenModifier(unit, unit, "jump_animation", {Duration = duration})
        --ability:ApplyDataDrivenModifier(unit, unit, "modifier_disarmed", {Duration = duration})
    end
    local ability = unit:FindAbilityByName("pveboss_system")
    Timers:CreateTimer(duration, function()
        if ability then
            ability:ApplyDataDrivenModifier(unit, unit, "modifier_phased", {Duration = 0.1})
        end
    end)
end

function LeapToLocationWithAOEDamage( unit, target_position, duration, damage, aoe )
    LeapToLocation( unit, target_position, duration )
    local tab = {}
    tab.caster = unit
    tab.damage = 0.0
    tab.spelldamagefactor = 0
    tab.attributefactor = 0
    tab.difficultyscalelinear = damage
    tab.ability = unit:FindAbilityByName("pveboss_system")
    tab.aoe = aoe
    tab.targeteffect = "blood"
    tab.target_points = {}
    tab.target_points[1] = target_position
    Timers:CreateTimer(duration*0.95, function()
        if unit and not unit:IsNull() and unit:IsAlive() then
            local particle = ParticleManager:CreateParticle("particles/econ/items/centaur/centaur_ti6/centaur_ti6_warstomp.vpcf", PATTACH_WORLDORIGIN, unit)
            ParticleManager:SetParticleControl(particle, 0, target_position)
            ParticleManager:SetParticleControl(particle, 1, Vector(aoe,aoe,aoe))
            ParticleManager:ReleaseParticleIndex(particle)
            DamageAOE(tab)
            EmitSoundOn("Ability.TossImpact", unit)
        end
    end)
end

function JumpStomp( event )
    local caster = event.caster
    local delay = event.delay
    local count = event.count
    local damage = event.dmg
    local jump_duration = 2
    local ability = caster:FindAbilityByName("pveboss_system")
    local aoe = event.aoe
    caster.is_leaping = true
    Timers:CreateTimer(count*delay+jump_duration + 0.05, function()
        caster.is_leaping = false
    end)
    for i=1,count do
        Timers:CreateTimer((i-1)*delay + 0.05, function()
            if caster:IsAlive() then
                local target = COverthrowGameMode:PVERandomTarget( event )
                if target then
                    order = 
                    {
                        UnitIndex = caster:entindex(),
                        OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                        TargetIndex = target:entindex(),
                        Queue = false
                    }
                    ExecuteOrderFromTable(order)
                    Timers:CreateTimer(0.1, function()
                        --if ability then
                        --    ability:ApplyDataDrivenModifier(caster, caster, "modifier_stunned", {Duration = jump_duration})
                        --end
                        LeapToLocationWithAOEDamage( caster, target:GetAbsOrigin(), jump_duration, damage, aoe )
                    end)
                end
            end
        end)
    end
end

function ShadowOrbFX( event )
    local caster = event.caster
    if caster:GetModifierStackCount("modifier_shadoworb", nil) >= 3 then
        local particle = ParticleManager:CreateParticle("particles/items3_fx/glimmer_cape_initial_flash_ember.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function SetPathDarknessLevel( event )
    event.caster.pathdarknesslevel = event.ability:GetLevel()
end

function AttackRandomHero( unit )
    Timers:CreateTimer(0.1, function()
        --local all = HeroList:GetAllHeroes()
        local hero_to_attack = COverthrowGameMode:PVERandomTargetNearTarget(unit, 3500)
        if hero_to_attack then
            order = 
            {
                UnitIndex = unit:entindex(),
                OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                TargetIndex = hero_to_attack:entindex(),
                Queue = false
            }
            ExecuteOrderFromTable(order)
        end
    end)
end

function AttackHero( unit, hero )
    Timers:CreateTimer(0.1, function()
        if hero and unit and not unit:IsNull() and unit:IsAlive() then
            order = 
            {
                UnitIndex = unit:entindex(),
                OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
                TargetIndex = hero:entindex(),
                Queue = false
            }
            ExecuteOrderFromTable(order)
        end
    end)
end

function ChainBounceSpell( event )
    local caster = event.caster
    local target = event.target
    local distance = event.jumpdistance
    Timers:CreateTimer(0.1, function()
        if caster and not caster:IsNull() and caster:IsAlive() then
            local next_target = COverthrowGameMode:PVERandomTargetNearTarget(target, distance)
            if next_target then
                EmitSoundOn("hero_Crystal.preAttack", caster)
                local info = {
                    Target = next_target,
                    Source = target,
                    Ability = event.ability,
                    EffectName = event.missilefx,
                    bDodgeable = true,
                    bProvidesVision = true,
                    iMoveSpeed = 600,
                    iVisionRadius = 300,
                    iVisionTeamNumber = caster:GetTeamNumber(),
                    iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_HITLOCATION
                }
                ProjectileManager:CreateTrackingProjectile( info )
            end
        end
    end)
end

function WaveCaller( event )
    local caster = event.caster
    local start_position = caster:GetAbsOrigin() - caster:GetForwardVector() * 1500
    local direction = caster:GetForwardVector()
    local distance = 3000
    EmitSoundOn("viper_vipe_spawn_04", caster)
    for i=0,11 do
        local delay_factor = 0
        if i == 1 or i == 2 then
            delay_factor = 1
        end
        if i == 3 or i == 4 then
            delay_factor = 2
        end
        if i == 5 or i == 6 then
            delay_factor = 3
        end
        if i == 7 or i == 8 then
            delay_factor = 4
        end
        if i == 9 or i == 10 then
            delay_factor = 5
        end
        if i == 11 then
            delay_factor = 6
        end
        Timers:CreateTimer(2.25+delay_factor*2.5,function()
            if caster and not caster:IsNull() and caster:IsAlive() then
                local launch_position = start_position
                if i == 1 or i == 3 or i == 5 then
                    launch_position = start_position + RotateVectorAroundAngle(direction, 90) * 275 * delay_factor
                end
                if i == 2 or i == 4 or i == 6 then
                    launch_position = start_position - RotateVectorAroundAngle(direction, 90) * 275 * delay_factor
                end
                if i == 7 or i == 9 then
                    launch_position = start_position + RotateVectorAroundAngle(direction, 90) * 275 * (6 - delay_factor)
                end
                if i == 8 or i == 10 then
                    launch_position = start_position - RotateVectorAroundAngle(direction, 90) * 275 * (6 - delay_factor)
                end
                if caster and caster:IsNull() then
                    return
                end
                local info = 
                {
                    Ability = event.ability,
                    EffectName = "particles/econ/items/morphling/morphling_crown_of_tears/morphling_crown_waveform.vpcf",
                    vSpawnOrigin = launch_position,
                    fDistance = distance,
                    fStartRadius = 125,
                    fEndRadius = 125,
                    Source = caster,
                    bHasFrontalCone = false,
                    bReplaceExisting = false,
                    iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
                    iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                    iUnitTargetType = DOTA_UNIT_TARGET_HERO,
                    fExpireTime = GameRules:GetGameTime() + 60.0,
                    bDeleteOnHit = false,
                    vVelocity = 800 * direction,
                    bProvidesVision = true,
                    iVisionRadius = 1000,
                    iVisionTeamNumber = caster:GetTeamNumber()
                }
                local projectile = ProjectileManager:CreateLinearProjectile(info)
                EmitSoundOn("Ability.GushCast", caster)
            end
        end)
    end
end

function WaveCaller10( event )
    local caster = event.caster
    local start_position = caster:GetAbsOrigin() - caster:GetForwardVector() * 1500 + RotateVectorAroundAngle(caster:GetForwardVector(),90) * 1500
    local direction = caster:GetForwardVector()
    local distance = 5000
    local wavedelay = 3
    local gap = math.random(4,6)
    EmitSoundOn("viper_vipe_spawn_04", caster)
    for waves = 1, 5 do
        Timers:CreateTimer(wavedelay*waves,function()
            if caster and not caster:IsNull() and caster:IsAlive() then
                EmitSoundOn("Ability.GushCast", caster)
                if gap == 3 then
                    gap = 4
                elseif gap == 7 then
                    gap = 6
                elseif math.random(1,100) <= 50 then
                    gap = gap + 1
                else
                    gap = gap - 1
                end
                for i=-4,14 do
                    if i ~= gap then
                        local launch_position = start_position - RotateVectorAroundAngle(direction,90) * 300 * i
                        local info = 
                        {
                            Ability = event.ability,
                            EffectName = "particles/econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship.vpcf",
                            vSpawnOrigin = launch_position,
                            fDistance = distance,
                            fStartRadius = 150,
                            fEndRadius = 150,
                            Source = caster,
                            bHasFrontalCone = false,
                            bReplaceExisting = false,
                            iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
                            iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                            iUnitTargetType = DOTA_UNIT_TARGET_HERO,
                            fExpireTime = GameRules:GetGameTime() + 60.0,
                            bDeleteOnHit = false,
                            vVelocity = 475 * direction,
                            bProvidesVision = true,
                            iVisionRadius = 1000,
                            iVisionTeamNumber = caster:GetTeamNumber()
                        }
                        local projectile = ProjectileManager:CreateLinearProjectile(info)
                    end
                end
            end
        end)
    end
end

function WaveCaller2( event )
    local caster = event.caster
    local side_offset = 1500
    if math.random(1,100) <= 50 then
        side_offset = -1500
    end
    local steps = 15
    local start_position = caster:GetAbsOrigin() - caster:GetForwardVector() * 1000 + RotateVectorAroundAngle(caster:GetForwardVector(), 90) * side_offset
    local direction = caster:GetForwardVector()
    local step_offset = - RotateVectorAroundAngle(caster:GetForwardVector(), 90) * side_offset / (steps / 2)
    local distance = 3000
    for i=1,steps * 4 do
        local count = i
        Timers:CreateTimer(i*1.4,function()
            if caster and not caster:IsNull() and caster:IsAlive() then
                local stepNumber = count % steps
                if (count % (2 * steps)) > steps then
                    stepNumber = steps - count % steps
                end
                local launch_position = start_position + step_offset * stepNumber
                local info = 
                {
                    Ability = event.ability,
                    EffectName = "particles/econ/items/nyx_assassin/nyx_assassin_ti6_witness/nyx_assassin_impale_ti6_witness.vpcf",
                    vSpawnOrigin = launch_position,
                    fDistance = distance,
                    fStartRadius = 125,
                    fEndRadius = 125,
                    Source = caster,
                    bHasFrontalCone = false,
                    bReplaceExisting = false,
                    iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
                    iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                    iUnitTargetType = DOTA_UNIT_TARGET_HERO,
                    fExpireTime = GameRules:GetGameTime() + 60.0,
                    bDeleteOnHit = false,
                    vVelocity = 650 * direction,
                    bProvidesVision = true,
                    iVisionRadius = 1000,
                    iVisionTeamNumber = caster:GetTeamNumber()
                }
                local projectile = ProjectileManager:CreateLinearProjectile(info)
                EmitSoundOn("Ability.TossImpact", caster)
            end
        end)
    end
end

function WaveCaller3( event )
    local caster = event.caster
    if event.count < 1 then
        return
    end
    if not caster or caster:IsNull() then
        return
    end
    local first_strike_delay = 0
    local distance = 500
    local current_position = caster:GetAbsOrigin() - caster:GetForwardVector() * 950
    local current_direction = RotateVectorAroundAngle(caster:GetForwardVector(), 90)
    if not event.launch_pos then
        first_strike_delay = 3
        event.angle = -30
        event.count = 30
        event.launch_pos = current_position
        if math.random(1,100) <= 50 then
            current_direction = RotateVectorAroundAngle(caster:GetForwardVector(), -90)
            event.angle = event.angle * -1
        end
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nevermore/nevermore_shadowraze.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, current_position)
    end
    if not event.launch_dir then
        event.launch_dir = current_direction
    end 
    
    local info = 
    {
        Ability = event.ability,
        EffectName = "particles/units/heroes/hero_dragon_knight/dragon_knight_breathe_fire.vpcf",
        vSpawnOrigin = event.launch_pos,
        fDistance = distance,
        fStartRadius = 125,
        fEndRadius = 250,
        Source = caster,
        bHasFrontalCone = false,
        bReplaceExisting = false,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
        iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
        iUnitTargetType = DOTA_UNIT_TARGET_HERO,
        fExpireTime = GameRules:GetGameTime() + 60.0,
        bDeleteOnHit = false,
        vVelocity = 500 * event.launch_dir,
        bProvidesVision = true,
        iVisionRadius = 1000,
        iVisionTeamNumber = caster:GetTeamNumber()
    }
    Timers:CreateTimer(first_strike_delay,function()
        local projectile = ProjectileManager:CreateLinearProjectile(info)
        EmitSoundOn("Hero_Lina.attack", caster)
    end)
    Timers:CreateTimer(1+first_strike_delay,function()
        event.count = event.count - 1
        event.angle = event.angle * 1.045
        --print(event.angle)
        event.launch_pos = event.launch_pos + event.launch_dir * distance
        event.launch_dir = RotateVectorAroundAngle(event.launch_dir,event.angle)
        WaveCaller3(event)
    end)
end

function WaveCaller4( event )
    local caster = event.caster
    if event.count < 0 then
        return
    end
    if not caster or caster:IsNull() then
        return
    end
    local distance = 500
    local current_position = caster:GetAbsOrigin()
    local current_direction = RotateVectorAroundAngle(caster:GetForwardVector(), 45*event.startangle)
    if not event.launch_pos then
        event.angle = 0
        event.count = 20
        event.launch_pos = current_position
    end
    if not event.launch_dir then
        event.launch_dir = current_direction
    end 
    
    local info = 
    {
        Ability = event.ability,
        EffectName = "particles/econ/items/nyx_assassin/nyx_assassin_ti6_witness/nyx_assassin_impale_ti6_witness.vpcf",
        vSpawnOrigin = event.launch_pos,
        fDistance = distance,
        fStartRadius = 125,
        fEndRadius = 125,
        Source = caster,
        bHasFrontalCone = false,
        bReplaceExisting = false,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
        iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
        iUnitTargetType = DOTA_UNIT_TARGET_HERO,
        fExpireTime = GameRules:GetGameTime() + 60.0,
        bDeleteOnHit = false,
        vVelocity = 500 * event.launch_dir,
        bProvidesVision = true,
        iVisionRadius = 1000,
        iVisionTeamNumber = caster:GetTeamNumber()
    }
    local projectile = ProjectileManager:CreateLinearProjectile(info)
    EmitSoundOn("Hero_Lina.attack", caster)
    Timers:CreateTimer(1,function()
        event.count = event.count - 1
        if (event.count > 3 and event.count <= 8) or (event.count > 13 and event.count <= 18) then
            event.angle = -47
        else
            event.angle = 0
        end
        event.launch_pos = event.launch_pos + event.launch_dir * distance
        event.launch_dir = RotateVectorAroundAngle(event.launch_dir,event.angle)
        WaveCaller4(event)
    end)
end

function WaveCaller5( event )
    local caster = event.caster
    if event.count < 0 then
        return
    end
    if not caster or caster:IsNull() then
        return
    end
    local distance = 500
    local turn_threshold = 1750
    if not event.launch_pos then
        event.launch_pos = caster:GetAbsOrigin() + RandomVector(1500)
    end
    if not event.launch_dir then
        event.launch_dir = (caster:GetAbsOrigin() - event.launch_pos):Normalized()
    end
    
    local info = 
    {
        Ability = event.ability,
        EffectName = "particles/econ/items/nyx_assassin/nyx_assassin_ti6/nyx_assassin_impale_ti6_gold.vpcf",
        vSpawnOrigin = event.launch_pos,
        fDistance = distance,
        fStartRadius = 125,
        fEndRadius = 125,
        Source = caster,
        bHasFrontalCone = false,
        bReplaceExisting = false,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
        iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
        iUnitTargetType = DOTA_UNIT_TARGET_HERO,
        fExpireTime = GameRules:GetGameTime() + 60.0,
        bDeleteOnHit = false,
        vVelocity = 500 * event.launch_dir,
        bProvidesVision = true,
        iVisionRadius = 1000,
        iVisionTeamNumber = caster:GetTeamNumber()
    }
    local projectile = ProjectileManager:CreateLinearProjectile(info)
    EmitSoundOn("Hero_Lina.attack", caster)
    Timers:CreateTimer(1,function()
        event.count = event.count - 1
        event.launch_pos = event.launch_pos + event.launch_dir * distance
        if caster and (not caster:IsNull()) and (caster:GetAbsOrigin() - event.launch_pos):Length() > turn_threshold then
            event.launch_dir = (caster:GetAbsOrigin() - event.launch_pos):Normalized()
        end
        WaveCaller5(event)
    end)
end

function WaveCaller6( event )
    local caster = event.caster
    if event.count < 0 then
        return
    end
    if not caster or caster:IsNull() then
        return
    end
    local distance = 500
    local current_position = caster:GetAbsOrigin()
    local current_direction = RotateVectorAroundAngle(caster:GetForwardVector(), 45*event.startangle)
    if not event.launch_pos then
        event.angle = 0
        event.count = 20
        event.launch_pos = current_position
    end
    if not event.launch_dir then
        event.launch_dir = current_direction
    end 
    
    local info = 
    {
        Ability = event.ability,
        EffectName = "particles/econ/items/nyx_assassin/nyx_assassin_ti6/nyx_assassin_impale_ti6_gold.vpcf",
        vSpawnOrigin = event.launch_pos,
        fDistance = distance,
        fStartRadius = 125,
        fEndRadius = 125,
        Source = caster,
        bHasFrontalCone = false,
        bReplaceExisting = false,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
        iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
        iUnitTargetType = DOTA_UNIT_TARGET_HERO,
        fExpireTime = GameRules:GetGameTime() + 60.0,
        bDeleteOnHit = false,
        vVelocity = 500 * event.launch_dir,
        bProvidesVision = true,
        iVisionRadius = 1000,
        iVisionTeamNumber = caster:GetTeamNumber()
    }
    local projectile = ProjectileManager:CreateLinearProjectile(info)
    EmitSoundOn("Hero_Lina.attack", caster)
    Timers:CreateTimer(1,function()
        event.count = event.count - 1
        if event.count == 16 then
            event.launch_dir = - event.launch_dir
        end
        if event.count == 12 then
            event.launch_dir = RotateVectorAroundAngle(event.launch_dir,45)
        end
        event.launch_pos = event.launch_pos + event.launch_dir * distance
        --event.launch_dir = RotateVectorAroundAngle(event.launch_dir,event.angle)
        WaveCaller6(event)
    end)
end

function WaveCaller7( event )
    local caster = event.caster
    if event.count < 0 then
        return
    end
    if not caster or caster:IsNull() then
        return
    end
    local distance = 400
    if not event.launch_pos then
        event.launch_pos = caster:GetAbsOrigin() + RandomVector(1600)
    end
    if not event.launch_dir then
        event.launch_dir = (caster:GetAbsOrigin() - event.launch_pos):Normalized()
    end
    
    local info = 
    {
        Ability = event.ability,
        EffectName = "particles/units/heroes/hero_dragon_knight/dragon_knight_breathe_fire.vpcf",
        vSpawnOrigin = event.launch_pos,
        fDistance = distance,
        fStartRadius = 125,
        fEndRadius = 125,
        Source = caster,
        bHasFrontalCone = false,
        bReplaceExisting = false,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
        iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
        iUnitTargetType = DOTA_UNIT_TARGET_HERO,
        fExpireTime = GameRules:GetGameTime() + 60.0,
        bDeleteOnHit = false,
        vVelocity = 400 * event.launch_dir,
        bProvidesVision = true,
        iVisionRadius = 1000,
        iVisionTeamNumber = caster:GetTeamNumber()
    }
    local projectile = ProjectileManager:CreateLinearProjectile(info)
    EmitSoundOn("Hero_Lina.attack", caster)
    Timers:CreateTimer(1,function()
        event.count = event.count - 1
        event.launch_pos = event.launch_pos + event.launch_dir * distance
        if event.count == 18 then
            event.launch_dir = RotateVectorAroundAngle(event.launch_dir,45)
        end
        if event.count < 18 and event.count > 5 then
            event.launch_dir = RotateVectorAroundAngle(event.launch_dir,-45)
        end
        WaveCaller7(event)
    end)
end

function WaveCaller8( event )
    local caster = event.caster
    if event.count < 0 then
        return
    end
    if not caster or caster:IsNull() then
        return
    end
    local distance = 700
    if not event.launch_pos then
        event.launch_pos = caster:GetAbsOrigin()
        event.hero_to_follow = COverthrowGameMode:PVERandomTargetNearTarget(caster, 3500)
        if not event.hero_to_follow then
            event.hero_to_follow = caster
        end
    end
    if not event.launch_dir then
        event.launch_dir = (event.hero_to_follow:GetAbsOrigin() - event.launch_pos):Normalized()
    end
    
    local info = 
    {
        Ability = event.ability,
        EffectName = "particles/fireball_linear_2.vpcf",
        vSpawnOrigin = event.launch_pos + Vector(0,0,60),
        fDistance = distance,
        fStartRadius = 100,
        fEndRadius = 100,
        Source = caster,
        bHasFrontalCone = false,
        bReplaceExisting = false,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
        iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
        iUnitTargetType = DOTA_UNIT_TARGET_HERO,
        fExpireTime = GameRules:GetGameTime() + 60.0,
        bDeleteOnHit = false,
        vVelocity = 350 * event.launch_dir,
        bProvidesVision = true,
        iVisionRadius = 1000,
        iVisionTeamNumber = caster:GetTeamNumber()
    }
    local projectile = ProjectileManager:CreateLinearProjectile(info)
    EmitSoundOn("Hero_Lina.attack", caster)
    Timers:CreateTimer(2,function()
        event.count = event.count - 1
        event.launch_pos = event.launch_pos + event.launch_dir * distance
        event.launch_dir = (event.hero_to_follow:GetAbsOrigin() - event.launch_pos):Normalized()
        WaveCaller8(event)
    end)
end

function SpawnPendulumTrap( event )
    local caster = event.caster
    local target =  COverthrowGameMode:PVERandomTarget( event )
    local cast_target = caster
    if target then
        cast_target = target
    end
    local center = cast_target:GetAbsOrigin() + cast_target:GetForwardVector() * 200 + Vector(0,0,75)
    local direction = cast_target:GetForwardVector() --Vector(0,0,0) + RandomVector(1)
    local distance = 750
    local team = caster:GetTeamNumber()
    local pendulum = SpawnEntityFromTableSynchronous("prop_dynamic", {model = "models/props/traps/pendulum/pendulum.vmdl", DefaultAnim="pendulum_swing", targetname=DoUniqueString("prop_dynamic")})
    pendulum:SetAbsOrigin(center)
    pendulum:SetForwardVector(RotateVectorAroundAngle(direction, 270))
    --direction = RotateVectorAroundAngle(direction, 90)
    --pre effect sounds
    EmitGlobalSound("Conquest.Pendulum.Trigger")
    --EmitGlobalSound("tutorial_rockslide")
    --EmitGlobalSound("Conquest.Pendulum.Scrape")
    --pre effect marker to see pendulum area
    --[[
    for i=0,7 do
        Timers:CreateTimer(1.25+i*0.20,function()
            local particle = ParticleManager:CreateParticle("particles/items_fx/dagon.vpcf", PATTACH_WORLDORIGIN, caster)
            ParticleManager:SetParticleControl(particle, 0, center - direction * distance)
            ParticleManager:SetParticleControl(particle, 1, center + direction * distance)
            ParticleManager:ReleaseParticleIndex(particle)
        end)
    end]]
    Timers:CreateTimer(2.25,function()
        local particle = ParticleManager:CreateParticle("particles/drow_ti6_silence_gold_wave_no_arrow.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, center - direction * distance)
        ParticleManager:SetParticleControl(particle, 1, (center + direction * distance)-(center - direction * distance))
        ParticleManager:ReleaseParticleIndex(particle)
    end)
    --spawn shock wave 1
    for i=0,1 do
        Timers:CreateTimer(3.85+i*3.5,function()
            EmitGlobalSound("Conquest.Pendulum.Scrape")
            if i == 1 then
                direction = direction * -1
            end
            local info = 
            {
                Ability = event.ability,
                EffectName = "particles/econ/items/magnataur/shock_of_the_anvil/magnataur_shockanvil.vpcf",
                vSpawnOrigin = center - direction * distance,
                fDistance = distance * 2,
                fStartRadius = 175,
                fEndRadius = 175,
                Source = caster,
                bHasFrontalCone = false,
                bReplaceExisting = false,
                iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
                iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                iUnitTargetType = DOTA_UNIT_TARGET_HERO,
                fExpireTime = GameRules:GetGameTime() + 60.0,
                bDeleteOnHit = false,
                vVelocity = 1200 * direction,
                bProvidesVision = true,
                iVisionRadius = 1000,
                iVisionTeamNumber = team
            }
            local projectile = ProjectileManager:CreateLinearProjectile(info)
        end)
    end
    Timers:CreateTimer(17,function()
        UTIL_Remove(pendulum)
    end)
end

function SetupSpawnedTrap( event )
    local unit = event.target
    local direction = Vector(0,0,0) + RandomVector(1)
    if event.trap_type == "5dartsshort" then
        unit.trap_element = event.trap_type
        unit.random_new_direction = true
    end
    if event.trap_type == "5dartsshortrandom" then
        unit.trap_element = event.trap_type
    end
    if event.trap_type == "3skulls" then
        unit.trap_element = event.trap_type
        unit.random_new_direction = true
        --unit:AddAbility("pve_no_healthbar"):SetLevel(1)
    end
    if event.trap_type == "1fire" then
        unit.trap_element = event.trap_type
        unit.random_new_direction = true
        --unit:AddAbility("pve_no_healthbar"):SetLevel(1)
    end
    if event.trap_type == "1fireturn" then
        unit.trap_element = event.trap_type
        --unit:AddAbility("pve_no_healthbar"):SetLevel(1)
    end
    if event.trap_type == "2frostturn" then
        unit.trap_element = event.trap_type
        --unit:AddAbility("pve_no_healthbar"):SetLevel(1)
    end
    Timers:CreateTimer(0.03,function()
        unit:SetForwardVector(direction)
    end)
end

function YinYangSystemGenerate( event )
    local caster = event.caster
    local ability = event.ability
    if not caster.yinyangsystem then
        caster.yinyangsystem = {0,0}
    end
    if event.yin then
        for i=1, event.yin do
            if caster.yinyangsystem[1] + caster.yinyangsystem[2] < 3 then
                caster.yinyangsystem[1] = caster.yinyangsystem[1] + 1
                ability:ApplyDataDrivenModifier(caster, caster, "modifier_yin", {Duration = -1})
            end
        end
    end
    if event.yang then
        for i=1, event.yang do
            if caster.yinyangsystem[1] + caster.yinyangsystem[2] < 3 then
                caster.yinyangsystem[2] = caster.yinyangsystem[2] + 1
                ability:ApplyDataDrivenModifier(caster, caster, "modifier_yang", {Duration = -1})
            end
        end
    end
end

function YinYangSystemConsume( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if not caster.yinyangsystem then
        return
    end
    if event.resolve then
        if not caster.yingyangcombos then
            caster.yingyangcombos = {false, false, false, false}
        end
        --deadly shaolin finisher
        local strike_count = 0
        local yin = caster.yinyangsystem[1]
        local yang = caster.yinyangsystem[2]
        if yin + yang >= 3 then
            strike_count = 1
            local chance = event.resolvechancetriple
            if caster:FindAbilityByName("deadly6") and caster:FindAbilityByName("deadly6"):GetLevel() >= 3 then
                chance = chance * 2
            end
            if math.random(1,100) <= chance then
                strike_count = 3
            end
            YinYangSystemReset( event )

            caster.yingyangcombos[yin + 1] = true
            if caster:HasModifier("modifier_npc_dota_hero_shaolin2") and caster.yingyangcombos[1] and caster.yingyangcombos[2] and caster.yingyangcombos[3] and caster.yingyangcombos[4] then
                caster.yingyangcombos = {false, false, false, false}
                ability:ApplyDataDrivenModifier(caster, caster, "modifier_equilibrium", {Duration = 20})
            end
        end
        local baseDamageFactor = event.includeauto
        for i=1, strike_count do
            Timers:CreateTimer((i-1)*0.5,function()
                if yin == 3 then
                    event.firedmg = 1
                    event.includeauto = baseDamageFactor * 2
                    if caster:FindAbilityByName("deadly5") and caster:FindAbilityByName("deadly5"):GetLevel() >= 4 then
                        event.includeauto = event.includeauto * 1.5
                    end
                    DamageUnit(event)
                    EmitSoundOn("Hero_OgreMagi.Fireblast.Cast", target)
                    local particle = ParticleManager:CreateParticle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze.vpcf", PATTACH_POINT_FOLLOW, target)
                    ParticleManager:ReleaseParticleIndex(particle)
                end
                if yin == 2 and yang == 1 then
                    event.firedmg = 1
                    event.frostdmg = 1
                    ability:ApplyDataDrivenModifier(caster, caster, "modifier_molten_blade", {Duration = 30})
                    DamageUnit(event)
                    EmitSoundOn("Hero_OgreMagi.Fireblast.Cast", target)
                    local particle = ParticleManager:CreateParticle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze.vpcf", PATTACH_POINT_FOLLOW, target)
                    ParticleManager:ReleaseParticleIndex(particle)
                end
                if yin == 1 and yang == 2 then
                    event.frostdmg = 1
                    event.firedmg = 1
                    ability:ApplyDataDrivenModifier(caster, caster, "modifier_frozen_blade", {Duration = 5})
                    DamageUnit(event)
                    EmitSoundOn("Hero_Crystal.CrystalNova.Yulsaria", target)
                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_lich/lich_frost_nova.vpcf", PATTACH_POINT_FOLLOW, target)
                    ParticleManager:ReleaseParticleIndex(particle)
                end
                if yang == 3 then
                    local target_position = target:GetAbsOrigin()
                    local tab = {}
                    local aoe = 200
                    if caster:FindAbilityByName("deadly5") and caster:FindAbilityByName("deadly5"):GetLevel() >= 4 then
                        aoe = aoe * 2
                    end
                    tab.frostdmg = 1
                    tab.caster = caster
                    tab.damage = 0.0
                    tab.spelldamagefactor = 0
                    tab.attributefactor = 0
                    tab.includeauto = event.includeauto
                    tab.ability = ability
                    tab.aoe = aoe
                    tab.targeteffect = "water"
                    tab.target_points = {}
                    tab.target_points[1] = target_position
                    local particle = ParticleManager:CreateParticle("particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf", PATTACH_WORLDORIGIN, target)
                    ParticleManager:SetParticleControl(particle, 0, target_position)
                    ParticleManager:SetParticleControl(particle, 1, Vector(aoe,1,1))
                    ParticleManager:ReleaseParticleIndex(particle)
                    DamageAOE(tab)
                    EmitSoundOn("Hero_Crystal.CrystalNova.Yulsaria", target)
                end
            end)
        end
    end
end

function YinYangSystemReset( event )
    local caster = event.caster
    if not caster.yinyangsystem then
        return
    end
    if ConsumeComboPoints(caster, event.target) then
        caster.yinyangsystem[1] = 0
        caster.yinyangsystem[2] = 0
        for i=1,3 do
            caster:RemoveModifierByName("modifier_yin")
            caster:RemoveModifierByName("modifier_yang")
        end
    end
end

function TakeHealthPercentage( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local health_percent = event.healthtaken
    if event.t3bonus and caster:HasModifier("modifier_item_set_str_t3_full") then
        health_percent = health_percent * 1.3
    end
    local factor = 1 - health_percent / 100
    if event.ghoul and target:GetHealth() / target:GetMaxHealth() <  (health_percent / 100) then
        factor = 0.01
    end
    if factor <= 0 then
        factor = 0.01
    end
    local hp_before = target:GetHealth()
    local finalHP = hp_before*factor
    if finalHP < 5 then
        finalHP = 5
    end
    target:SetHealth(finalHP)
    local damage_equivalent = hp_before - target:GetHealth()
    if caster.owner then
        caster = caster.owner
    end
    if event.DKselfheal and ability and ability:GetLevel() >= 4 then
        HealUnit({caster = caster, target = caster, heal = hp_before - finalHP, spelldamagefactor = 0, attributefactor = 0})
    end
    local myevent = {}
    myevent.unit = target
    myevent.attacker = caster
    myevent.damagetaken = damage_equivalent
    COverthrowGameMode:PVEAggroAdd(myevent)
end

function StarsAlignFX(target)
    local particle = ParticleManager:CreateParticle("particles/invoker_chaos_meteor_fly_blue_fast.vpcf", PATTACH_WORLDORIGIN, target)
    ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + Vector(500,250,900))
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,50))
    ParticleManager:SetParticleControl(particle, 2, Vector(0.25,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
    particle = ParticleManager:CreateParticle("particles/invoker_chaos_meteor_fly_blue_fast.vpcf", PATTACH_WORLDORIGIN, target)
    ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + Vector(-500,-250,900))
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,50))
    ParticleManager:SetParticleControl(particle, 2, Vector(0.25,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
    EmitSoundOn("Hero_Luna.Eclipse.Cast", target)
    Timers:CreateTimer(0.25,function()
        particle = ParticleManager:CreateParticle("particles/econ/items/wisp/wisp_death_ti7_model.vpcf", PATTACH_WORLDORIGIN, target)
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end)
end

function GetCompanionAndPetCount( hero )
    local pets = 0
    if hero.Pet and not hero.Pet:IsNull() and hero.Pet:IsAlive() then
        pets = pets + 1
    end
    pets = pets + GetCompanionCount(hero)
    return pets
end

function GetCompanionCount(hero)
    local pets = 0
    for i=1,10 do
        if IsCompanionAlive(hero,i) then
            pets = pets + 1
        end
    end
    return pets
end

function SteedOfLightFX( event )
    local point = event.target_points[1]
    local caster = event.caster
    local direction = (point - caster:GetAbsOrigin()):Normalized() * 750
    local particle = ParticleManager:CreateParticle("particles/econ/items/keeper_of_the_light/kotl_ti7_illuminate/kotl_ti7_illuminate.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 3, caster:GetAbsOrigin())
    ParticleManager:SetParticleControl(particle, 1, direction)
    ParticleManager:SetParticleControl(particle, 8, Vector(3,0,0))
    ParticleManager:SetParticleControl(particle, 10, Vector(3,0,0))
    Timers:CreateTimer(3,function()
        ParticleManager:DestroyParticle(particle,false)
        ParticleManager:ReleaseParticleIndex(particle)
    end)
end

function PillarsOfHope( event )
    local caster = event.caster
    local pos = {}
    local particle = {}
    local dir = {}
    local missile_counter = 0
    local lifetime = 0
    local tick_frequency = 0.5
    for i=1,3 do
        if i == 1 then
            pos[i] = caster:GetAbsOrigin() + Vector(math.random(750,1200), math.random(-750,750),0)
        end
        if i == 2 then
            pos[i] = caster:GetAbsOrigin() + Vector(math.random(-1200,-750), math.random(-750,750),0)
        end
        if i == 3 then
            pos[i] = caster:GetAbsOrigin() + RandomVector(math.random(750,1200))
        end
        dir[i] = Vector(0,0,0) + RandomVector(math.random(15,30))
        particle[i] = ParticleManager:CreateParticle("particles/econ/items/invoker/invoker_apex/invoker_sun_strike_team_big_ray_immortal1.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle[i], 0, pos[i])
        ParticleManager:ReleaseParticleIndex(particle[i])
    end
    
    Timers:CreateTimer(tick_frequency,function()
        if caster and not caster:IsNull() and caster:IsAlive() and lifetime < 25 then
            lifetime = lifetime + tick_frequency
            missile_counter = missile_counter + 1
            for i=1,3 do
                pos[i] = pos[i] + dir[i]
                particle[i] = ParticleManager:CreateParticle("particles/econ/items/invoker/invoker_apex/invoker_sun_strike_team_big_ray_immortal1.vpcf", PATTACH_WORLDORIGIN, caster)
                ParticleManager:SetParticleControl(particle[i], 0, pos[i])
                ParticleManager:ReleaseParticleIndex(particle[i])
            end
            if missile_counter >= 6 then
                missile_counter = 0
                EmitSoundOn("Hero_Magnataur.ShockWave.Cast", caster)
                for i=1,3 do
                    for j=1,2 do
                        local index = i + j
                        if index > 3 then
                            index = index % 3
                        end
                        local direction = (pos[index] - pos[i]):Normalized()
                        local info = 
                        {
                            Ability = event.ability,
                            EffectName = "particles/econ/items/magnataur/shock_of_the_anvil/magnataur_shockanvil.vpcf",
                            vSpawnOrigin = pos[i],
                            fDistance = 2500,
                            fStartRadius = 75,
                            fEndRadius = 75,
                            Source = caster,
                            bHasFrontalCone = false,
                            bReplaceExisting = false,
                            iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_BOTH,
                            iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                            iUnitTargetType = DOTA_UNIT_TARGET_ALL,
                            fExpireTime = GameRules:GetGameTime() + 60.0,
                            bDeleteOnHit = false,
                            vVelocity = 450 * direction,
                            bProvidesVision = true,
                            iVisionRadius = 300,
                            iVisionTeamNumber = caster:GetTeamNumber()
                        }
                        local projectile = ProjectileManager:CreateLinearProjectile(info)
                    end
                end
            end
            return tick_frequency
        end
    end)
end

function PillarsOfHopeImpact( event )
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() == target:GetTeamNumber() then
        if caster == target then
            HealUnit({caster = caster, target = caster, ability = event.ability, heal = caster:GetMaxHealth()*0.25})
        end
    else
        DamageUnit(event)
    end
end

function OmniRevelation( event )
    local caster = event.caster
    if caster:GetHealth() / caster:GetMaxHealth() <= 0.4 and not caster.omni_revelation_procced then
        caster.omni_revelation_procced = true
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_omni_revelation_proc", {Duration = -1})
        EmitSoundOn("DOTA_Item.AbyssalBlade.Activate", caster)
        EmitGlobalSound("omniknight_omni_death_03")
        Timers:CreateTimer(2.5,function()
            AddAbilityToUnit({target = caster, abil = "pve_temple_bolt_aoe_shadow_bouncing"})
            AddAbilityToUnit({target = caster, abil = "pve_temple_spottheweak"})
            caster:SetModel("models/heroes/wraith_king/wraith_frost.vmdl")
            caster:SetOriginalModel("models/heroes/wraith_king/wraith_frost.vmdl")
            HideWearables( {caster = caster} )
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti7/blink_dagger_start_ti7_lvl2.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
        end)
        Timers:CreateTimer(5,function()
            EmitGlobalSound("omniknight_omni_death_05")
        end)
        PurgeUnit(event)
    end
end

function GlobalOnAbilityCriticalStrike(caster, target, ability, damageOrHeal, swordStorm)
    if caster.talents then
        if GetLevelOfAbility(caster, "Protect2") >= 2 and math.random(1,100) <= 25 then
            caster:GetAbilityByIndex(0):ApplyDataDrivenModifier(caster, caster, "modifier_ironshield", {Duration = 3})
        end
        if caster.talents[19] and caster.talents[19] > 0 and math.random(1,100) <= 10 * caster.talents[19] and caster:GetAbilityByIndex(2) == ability and not caster:HasModifier("modifier_path19cd") then
            Timers:CreateTimer(0.1,function()
                caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_path19cd", {Duration = 30 * GetInnerCooldownFactor(caster)})
                local myevent = {caster = caster, amount = 1000, ability = ability }
                ReduceCooldown(myevent)
            end)
        end
        if swordStorm and caster:HasModifier("modifier_npc_dota_hero_axe2") then
            AddSwordStormCrit(caster)
        end
    end
end

function HealCrit(caster, target, ability)
    GlobalOnAbilityCriticalStrike(caster, target, ability, false, nil)
    SavageryProc(caster, 1)
end

function OnKillEffects(hero, killedUnit)
    if hero and hero.talents then
        --if hero.talents[22] and hero.talents[22] >= 1 and hero:HasModifier("modifier_crit_moon_cd") then
        --    hero:RemoveModifierByName("modifier_crit_moon_cd")
        --    local particle = ParticleManager:CreateParticle("particles/econ/events/ti9/hero_levelup_ti9_godray.vpcf", PATTACH_POINT_FOLLOW, hero)
        --    ParticleManager:ReleaseParticleIndex(particle)
        --end
    end
end

function GlobalOnDealShadowDamage( caster, target )
    if GetLevelOfAbility(caster, "unholy_6") >= 3 then
        RestoreResource({caster = caster, amount = 5})
    end
    if GetLevelOfAbility(caster, "retri2") >= 2 and math.random(1,100) <= 50 then
        local myevent = {caster = caster, amount = 100, ability = nil, chooseabilityname = "Retri2" }
        ReduceCooldown(myevent)
    end
    if HeroHasNeutralItem(caster, "item_neutral_19") then
        ApplyBuff({caster = caster, target = target, ability = caster.combat_system_ability, dur = 5, buff = "modifier_nethervoid"})
    end
end

function GlobalOnDealFireDamage( caster, target )
    if caster.talents then
        if caster.talents[118] and caster.talents[118] > 0 then
            if not caster:HasModifier("modifier_moltengiant_cd") then
                local dur = 10
                local cdFactor = 3
                ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = dur, buff = "modifier_moltengiant"})
                ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = dur * cdFactor * GetInnerCooldownFactor(caster), buff = "modifier_moltengiant_cd"})
            end
        end
    end
    if HeroHasNeutralItem(caster, "item_neutral_2") and math.random(1,100) <= 10 then
        ApplyBuff({caster = caster, target = target, ability = caster.combat_system_ability, dur = 3, buff = "modifier_moltenarmor"})
    end
    if GetLevelOfAbility(caster, "destro2") >= 3 and math.random(1,100) <= 25 then
        DamageUnitDelayed({caster = caster, target = target, ability = caster:FindAbilityByName("destro2"), spelldamagefactor = 500, attributefactor = 500, shadowdmg = 1, delay = 0.1})
    end
end

function GlobalOnDealNatureDamage( caster )
    if caster.talents then
        if GetLevelOfAbility(caster, "wind3") >= 3 then
            RestoreResource({caster = caster, amount = 2, flat = 1})
        end
        if caster.talents[119] and caster.talents[119] > 0 then
            if not caster:HasModifier("modifier_stormgiant_cd") then
                local dur = 10
                local cdFactor = 3
                ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = dur, buff = "modifier_stormgiant"})
                ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = dur * cdFactor * GetInnerCooldownFactor(caster), buff = "modifier_stormgiant_cd"})
            end
        end
    end
end

function GlobalOnDealChaosDamage( caster, target )
    if caster.talents then
        if GetLevelOfAbility(caster, "terror1") >= 4 and math.random(1,100) <= 5 then
            ApplyBuff({caster = caster, target = target, ability = caster:GetAbilityByIndex(0), dur = 1, buff = "modifier_stunned"})
            local particle = ParticleManager:CreateParticle("particles/econ/items/natures_prophet/natures_prophet_ti9_immortal/natures_prophet_ti9_cast_lightray.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
        end
        if GetLevelOfAbility(caster, "dh4") >= 3 and math.random(1,100) <= 5 then
            FelBlast(caster, target)
        end
    end
end

function GlobalOnDealArcaneDamage( caster, was_crit, target )
    if caster.talents then
        if GetLevelOfAbility(caster, "Arcane4") >= 3 and math.random(1,100) <= 5 and not caster.arcaneResetCD then
            caster.arcaneResetCD = true
            local particle = ParticleManager:CreateParticle("particles/econ/items/dark_willow/dark_willow_ti8_immortal_head/dw_ti8_immortal_cursed_crown_marker_embers.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            Timers:CreateTimer(0.1,function()
                ReduceCooldown({caster = caster, chooseability = 4, amount = 5, ability = nil})
            end)
            Timers:CreateTimer(3,function()
                caster.arcaneResetCD = false
            end)
        end
        if was_crit and caster.talents[120] and caster.talents[120] > 0 then
            ArcaneExplosionPath(caster)
        end
        if HeroHasNeutralItem(caster, "item_neutral_19") then
            ApplyBuff({caster = caster, target = target, ability = caster.combat_system_ability, dur = 5, buff = "modifier_nethervoid"})
        end
    end
end

function GlobalOnDealAOEDamage( caster, target )
    if caster.talents then
        if GetLevelOfAbility(caster, "Feral5") >= 3 then
            RestoreResource({caster = caster, amount = 3})
        end
    end
end

function ArcaneExplosionPath(caster)
    if not caster:HasModifier("modifier_arcanegiant_cd") then
        local dur = 1.25
        local cd = 20 * GetInnerCooldownFactor(caster)
        ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = dur, buff = "modifier_arcanegiant"})
        ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = cd, buff = "modifier_arcanegiant_cd"})
    end
end

function DivineBlessingProc(caster)
    if GetLevelOfAbility(caster, "disc7") >= 4 and math.random(1,100) <= 5 then
        local target = MostWoundedTarget({range = 1500, caster = caster, target = caster, onlyhero = true})
        if target then
            caster:GetAbilityByIndex(3):ApplyDataDrivenModifier(caster, target, "modifier_divinebl", {Duration = 3})
        end
    end
end

function GlobalOnDealDamage( event )
    local caster = event.caster
    local target = event.unit
    caster.creepertarget = target
    if GetLevelOfAbility(caster, "glacier_crack_spell") >= 2 then
        RestoreResource({caster = caster, amount = 5, cap = 10})
    end
    if caster.talents then
        DivineBlessingProc(caster)
        if GetLevelOfAbility(caster, "fury5") >= 2 then
            RestoreResource({caster = caster, amount = 1})
        end
        if caster.talents[50] and caster.talents[50] > 0 then
            local threshold = 25
            if caster:HasModifier("modifier_coloss2") then
                threshold = 15
            elseif caster:HasModifier("modifier_coloss") then
                threshold = 20
            end
            local stackcount = caster:GetModifierStackCount("modifier_swipe_of_ursa", nil) + 1
            if stackcount >= threshold then
                stackcount = 0
                caster:RemoveModifierByName("modifier_swipe_of_ursa")
                SwipeOfUrsaTalent(caster, event.ability)
            else
                ApplyBuffStack({caster = caster, target = caster, ability = caster.combat_system_ability, dur = 30, buff = "modifier_swipe_of_ursa"})
            end
        end
        if caster.talents[44] and caster.talents[44] > 0 and not caster:HasModifier("modifier_backstab_cd") then
            local backstabcd = 45
            local stunextra = 0
            if caster:HasModifier("modifier_purecrit") or caster:HasModifier("modifier_purecrit2") then
                backstabcd = backstabcd - 5
                --stunextra = 2
            end
            backstabcd = backstabcd * GetInnerCooldownFactor(caster)
            ApplyBuff({caster = caster, target = target, ability = event.ability, dur = 1 + caster.talents[44] + stunextra, buff = "modifier_stunned"})
            ApplyBuff({caster = caster, target = caster, ability = caster.combat_system_ability, dur = backstabcd, buff = "modifier_backstab_cd"})
            BloodArcana({caster = caster, target = target, ignore_crit_effect_cooldown = true })
        end
        if caster.talents[102] and caster.talents[102] > 0 then
            local chance = 7
            if caster:HasModifier("modifier_pathbuff_068") then
                chance = chance + 3
            end
            if HeroHasNeutralItem(caster, "item_neutral_26") then
                chance = chance * 2
            end
            if math.random(1,100) <= chance then
                SummonBoneWarrior(caster, target)
            end
        end
        if caster.talents[96] and caster.talents[96] > 0 then
            EpidemicProc(caster, target, false)
        end
    end
end

function SummonBoneWarrior( caster, target )
    local maxWarriors = 2 + caster.talents[102]
    local dur = 10
    if not caster.bone_warrior_count then
        caster.bone_warrior_count = 0
    end
    if caster.bone_warrior_count < maxWarriors then
        caster.bone_warrior_count = caster.bone_warrior_count + 1
        caster.combat_system_ability:ApplyDataDrivenModifier(caster, target, "bonewarrior_summon_proc", nil)
        caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_lordofbones_aura", {Duration = 10})
        Timers:CreateTimer(dur,function()
            caster.bone_warrior_count = caster.bone_warrior_count - 1
        end)
    end
end

function SwipeOfUrsaTalent(caster, original_ability)
    EmitSoundOn("Ability.SandKing_SandStorm.start", caster)
    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_ursa/ursa_overpower_cast.vpcf", PATTACH_POINT_FOLLOW, caster)
    ParticleManager:ReleaseParticleIndex(particle)
    local particle = ParticleManager:CreateParticle("particles/econ/items/legion/legion_overwhelming_odds_ti7/legion_commander_odds_ti7_proj_chunk_glow.vpcf", PATTACH_POINT_FOLLOW, caster)
    ParticleManager:ReleaseParticleIndex(particle)
    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nevermore/nevermore_loadout_ember_swirl.vpcf", PATTACH_POINT_FOLLOW, caster)
    ParticleManager:ReleaseParticleIndex(particle)
    Timers:CreateTimer(1.25,function()
        local aoe = 300
        local event = {caster = caster, ability = caster.combat_system_ability, changedmgtypetophys = 1, damage_factor_single_target = 2, damage = 0, attributefactor = 200*caster.talents[50], attributechangestr = 1, aoe = aoe, max_targets = 5, targeteffect = "arcanablood", isaoe = 1, delay = delay, dontbreakcc = 1 }
        if caster:HasModifier("modifier_pathbuff_066") and caster:GetAbilityByIndex(1) == original_ability then
            event.shadowdmg = 1
            event.attributechangestr = nil
            event.attributefactor = event.attributefactor * 1.25
        end
        EmitSoundOn("DOTA_Item.Necronomicon.Activate", caster)
        local particle = ParticleManager:CreateParticle("particles/econ/items/axe/axe_weapon_bloodchaser/axe_attack_blur_counterhelix_bloodchaser.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        local buffevent = { caster = caster, target = caster, ability = caster.combat_system_ability, aoe = aoe, targetpos = 1, buff = "modifier_sou_minus", dur = caster.talents[50], maxAOEBuffTargets = 5}
        ApplyBuffAOE(buffevent)
        DamageAOE(event)
        if caster:HasModifier("modifier_pathbuff_042") and caster.combat_system_ability then
            --local mod = caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_ursa_prot", {Duration = 10})
            -- I have no idea why data driven modifier duration = 10 ignored and somewhere set to 6... Probably dota modifier internal name used or some weird data driven things
            caster:AddNewModifier(caster, nil, "modifier_swipe_of_ursa_proc", { Duration = 10})
        end
    end)
end

function SwipeOfUrsaItem( event )
    local caster = event.caster
    if caster and caster.talents and caster.talents[50] and caster.talents[50] > 0 and math.random(1,100) <= 100 then
        SwipeOfUrsaTalent(caster, original_ability)
    end
end

function SetBeastmasterItem( event )
    local caster = event.caster
    caster['item_beastmaster'..event.id] = event.ability
end

function GetClassRingPower( hero )
    local result = {0,0,0,0,0,0} -- 1st talent id, talent levels, 2nd ...
    local heroname = string.sub(hero:GetUnitName(), 15)
    if hero and hero.inventory and hero.inventory[3] and hero.inventory[3][1] and string.sub(hero.inventory[3][1], 12) == heroname then
        for i=1, 3 do
            result[-1 + i*2] = COverthrowGameMode:GetTalentIdByName(string.sub(hero.inventory[3][7+i], 8))
            result[0 + i*2] = hero.inventory[3][4+i]
        end
    end
    return result
end

function GetArtifactPathBonus( hero, slot )
    local result = {0,0,0,0,0,0} -- 1st talent id, talent levels, 2nd ...
    if hero and hero.inventory and hero.inventory[slot] and hero.inventory[slot][1] then
        for i=1, 3 do
            if hero.inventory[slot][7+i] and string.sub(hero.inventory[slot][7+i], 1, 6) == " Path:" then
                result[-1 + i*2] = COverthrowGameMode:GetTalentIdByName(string.sub(hero.inventory[slot][7+i], 8))
                result[0 + i*2] = hero.inventory[slot][4+i]
            end
        end
    end
    return result
end

function COverthrowGameMode:GetTalentIdByName( pathname )
    for i=1, #COverthrowGameMode.PathTalentNames do
        if pathname and pathname == COverthrowGameMode.PathTalentNames[i] then
            return i
        end
    end
    return 0
end

function COverthrowGameMode:GetTalentNameById( id )
    return COverthrowGameMode.PathTalentNames[id]
end

function COverthrowGameMode:DropClassQuestReward( hero, quality, slot )
    local weapon = quality .. slot .. "class_" .. string.sub(hero:GetUnitName(), 15)
    COverthrowGameMode:CreateMythicWeapon( hero, weapon, false, nil, nil, nil, false )
    Notifications:Bottom(hero:GetPlayerID(), {text="Hero Quest completed!", duration=10, style={color="lightgreen"}})
end

function PathAlphaBloodProc( caster, ability )
    if not caster.path_alpha_blood_cd then
        caster.path_alpha_blood_cd = true
        HealUnit({caster = caster, target = caster, ability = ability, heal = caster:GetMaxHealth()*0.1})
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_lycan/lycan_summon_wolves_spawn.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        Timers:CreateTimer(7 * GetInnerCooldownFactor(caster),function()
            caster.path_alpha_blood_cd = nil
        end)
    end
end

function PathRainOfStarsAA( event )
    local caster = event.caster
    if caster.talents[23] <= 0 then
        return
    end
    local target = event.target
    local chance = 15
    if event.rainOfStarsChance then
        chance = event.rainOfStarsChance
    end
    if math.random(1,100) <= chance then
        EmitSoundOn("Hero_Luna.Eclipse.Cast", target)
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_mirana/mirana_starfall_attack.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        DamageUnitDelayed({caster = caster, target = target, ability = event.ability, spelldamagefactor = 75, attributefactor = 75, includeauto = 75, naturedmg = 1, talentscale = 23, delay = 0.5, dontbreakcc = 1, starfallbonus = 1, changedmgtypetophys = 1 })
        PathRainOfStars(event)
        OnNaturalDisasterProcced( caster, target, 1 )
    end
end

function PathRainOfStars(event)
    local caster = event.caster
    if caster:HasModifier("modifier_pathbuff_023") then
        HealUnit({caster = caster, target = caster, ability = event.ability, heal = caster:GetMaxHealth()*0.01})
    end
end

function PathCounterattack(event)
    local caster = event.caster
    local attacker = event.attacker
    if event.barkskin then
        event.target = attacker
        DamageUnit(event)
    else
        if not HasDamageReflect(attacker) then
            local myevent = {}
            myevent.caster = caster
            myevent.target = attacker
            myevent.buff = "modifier_stunned"
            myevent.ability = event.ability
            myevent.dur = 1
            ApplyBuff(myevent)
            if not CheckForBreakableCC(attacker) then
                event.target = attacker
                HitFX( caster, attacker )
                DamageUnit(event)
            end
        end
    end
end

function WalkingLaserTrap( event )
    local caster = event.caster
    local ability = event.ability
    local bots = {}
    local directions = {}
    local heroes_to_chase = {}
    local movement_pattern = 3 --1 = straight, 2 = random, 3 = chase
    local delay = 2.5
    local ticks = 0.33
    local bot_count = 3
    local duration = 15
    local can_not_be_targeted = true
    EmitSoundOn("Item.LotusOrb.Activate", caster)
    for i=1, bot_count do
        heroes_to_chase[i] = COverthrowGameMode:PVERandomTargetNearTarget(caster, 3500, heroes_to_chase[i-1])
        directions[i] = Vector(0,0,0) + RandomVector(1)
        local unit = CreateUnitByName("temple_walking_bot", caster:GetAbsOrigin() + RandomVector(300), true, nil, nil, DOTA_TEAM_BADGUYS )
        bots[i] = unit
        unit.noexp = 1
        unit.damageimune = 1
        COverthrowGameMode:SetTempleStats(unit,COverthrowGameMode.jungledifficulty,100,1000,0,0)
        unit:SetForwardVector(directions[i])
        unit:SetModelScale(1.4)
        --ability:ApplyDataDrivenModifier(caster, unit, "modifier_stunned", {Duration = delay})
        if can_not_be_targeted then
            ability:ApplyDataDrivenModifier(caster, unit, "modifier_trap", {Duration = duration})
        end
    end
    Timers:CreateTimer(delay,function()
        Timers:CreateTimer(ticks,function()
            for i=1, bot_count do
                if bots[i] and not bots[i]:IsNull() and bots[i]:IsAlive() and caster and not caster:IsNull() then
                    --move patterns
                    --forward with slight curve
                    directions[i] = RotateVectorAroundAngle(directions[i], math.random(-10,10))
                    local move_pos = bots[i]:GetAbsOrigin() + directions[i] * 200
                    --random every 1.25 secs
                    if movement_pattern == 2 and math.random(1,100) <= ticks * 100 * 1.25 then
                        move_pos = bots[i]:GetAbsOrigin() + RandomVector(1) * 200
                    end
                    --follow hero
                    if movement_pattern == 3 and heroes_to_chase[i] then
                        move_pos = heroes_to_chase[i]:GetAbsOrigin() + (heroes_to_chase[i]:GetAbsOrigin() - bots[i]:GetAbsOrigin()):Normalized() * 200
                    end
                    local order = { UnitIndex = bots[i]:entindex(), OrderType = DOTA_UNIT_ORDER_MOVE_TO_POSITION, Position = move_pos }
                    ExecuteOrderFromTable(order)
                    if i ~= bot_count then --last does not shoot
                        --dmg and fx only once
                        local info = 
                        {
                            Ability = ability,
                            EffectName = "particles/econ/generic/generic_projectile_linear_1/generic_projectile_linear_1.vpcf",
                            vSpawnOrigin = bots[i]:GetAbsOrigin(),
                            fDistance = (bots[i]:GetAbsOrigin() - bots[i+1]:GetAbsOrigin()):Length(),
                            fStartRadius = 100,
                            fEndRadius = 100,
                            Source = caster,
                            bHasFrontalCone = false,
                            bReplaceExisting = false,
                            iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
                            iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                            iUnitTargetType = DOTA_UNIT_TARGET_HERO,
                            fExpireTime = GameRules:GetGameTime() + 60.0,
                            bDeleteOnHit = false,
                            vVelocity = 3000 * (bots[i+1]:GetAbsOrigin() - bots[i]:GetAbsOrigin()):Normalized(),
                            bProvidesVision = true,
                            iVisionRadius = 1000,
                            iVisionTeamNumber = caster:GetTeamNumber()
                        }
                        local projectile = ProjectileManager:CreateLinearProjectile(info)
                        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_zuus/zuus_arc_lightning.vpcf", PATTACH_POINT_FOLLOW, bots[i])
                        ParticleManager:SetParticleControl(particle, 0, bots[i]:GetAbsOrigin() + Vector(0,0,200))
                        ParticleManager:SetParticleControl(particle, 1, bots[i+1]:GetAbsOrigin() + Vector(0,0,200))
                        ParticleManager:ReleaseParticleIndex(particle)
                        particle = ParticleManager:CreateParticle("particles/units/heroes/hero_zuus/zuus_arc_lightning.vpcf", PATTACH_POINT_FOLLOW, bots[i+1])
                        ParticleManager:SetParticleControl(particle, 0, bots[i+1]:GetAbsOrigin() + Vector(0,0,200))
                        ParticleManager:SetParticleControl(particle, 1, bots[i]:GetAbsOrigin() + Vector(0,0,200))
                        ParticleManager:ReleaseParticleIndex(particle)
                    end
                    if i == bot_count then
                        --repeat
                        EmitSoundOn("DOTA_Item.Butterfly", caster)
                        return ticks
                    end
                end
            end
        end)
    end)
    Timers:CreateTimer(duration,function()
        for i=1, bot_count do
            bots[i]:ForceKill(false)
        end
    end)
end

function SpinningLaserTrap( event )
    local caster = event.caster
    local ability = event.ability
    local bots = {}
    local directions = {}
    local laser_every = 0.09
    local laser_time_counter = {}
    local turnrate = 1.35 * 2
    if math.random(1,100) <= 50 then
        turnrate = - turnrate
    end
    local delay = 2.5
    local ticks = 0.05
    local bot_count = 1
    local duration = 15
    local can_not_be_targeted = true
    EmitSoundOn("Item.LotusOrb.Activate", caster)
    for i=1, bot_count do
        laser_time_counter[i] = 0
        directions[i] = Vector(0,0,0) + RandomVector(1)
        local unit = CreateUnitByName("temple_walking_bot2", caster:GetAbsOrigin() + RandomVector(250), true, nil, nil, DOTA_TEAM_BADGUYS )
        bots[i] = unit
        unit.noexp = 1
        unit.damageimune = 1
        COverthrowGameMode:SetTempleStats(unit,COverthrowGameMode.jungledifficulty,100,1000,0,0)
        unit:SetForwardVector(directions[i])
        unit:SetModelScale(1.8)
        --unit:SetRenderColor(255, 100, 100)
        --ability:ApplyDataDrivenModifier(caster, unit, "modifier_stunned", {Duration = delay})
        if can_not_be_targeted then
            ability:ApplyDataDrivenModifier(caster, unit, "modifier_trap", {Duration = duration})
        end
    end
    Timers:CreateTimer(delay,function()
        Timers:CreateTimer(ticks,function()
            for i=1, bot_count do
                if bots[i] and not bots[i]:IsNull() and bots[i]:IsAlive() and caster and not caster:IsNull() and caster:IsAlive() then
                    laser_time_counter[i] = laser_time_counter[i] + ticks
                    directions[i] = RotateVectorAroundAngle(directions[i], turnrate)
                    bots[i]:SetForwardVector(directions[i])
                    if laser_time_counter[i] >= laser_every then
                        laser_time_counter[i] = 0
                        local info = 
                        {
                            Ability = ability,
                            EffectName = "particles/econ/generic/generic_projectile_linear_1/generic_projectile_linear_1.vpcf",
                            vSpawnOrigin = bots[i]:GetAbsOrigin(),
                            fDistance = 2000,
                            fStartRadius = 100,
                            fEndRadius = 100,
                            Source = caster,
                            bHasFrontalCone = false,
                            bReplaceExisting = false,
                            iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
                            iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
                            iUnitTargetType = DOTA_UNIT_TARGET_HERO,
                            fExpireTime = GameRules:GetGameTime() + 60.0,
                            bDeleteOnHit = false,
                            vVelocity = 3000 * bots[i]:GetForwardVector(),
                            bProvidesVision = true,
                            iVisionRadius = 1000,
                            iVisionTeamNumber = caster:GetTeamNumber()
                        }
                        local projectile = ProjectileManager:CreateLinearProjectile(info)
                        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, bots[i])
                        ParticleManager:SetParticleControl(particle, 5, bots[i]:GetAbsOrigin() + Vector(0,0,235))
                        ParticleManager:SetParticleControl(particle, 4, bots[i]:GetAbsOrigin() + 2000 * bots[i]:GetForwardVector() + Vector(0,0,100))
                        ParticleManager:ReleaseParticleIndex(particle)
                    end
                    if i == bot_count then
                        --repeat
                        EmitSoundOn("DOTA_Item.Butterfly", caster)
                        return ticks
                    end
                end
            end
        end)
    end)
    Timers:CreateTimer(duration,function()
        for i=1, bot_count do
            bots[i]:ForceKill(false)
        end
    end)
end

function CountBuffs( unit, buff )
    local count = 0
    local mods = unit:GetModifierCount()-1
    for i=0, mods do
        local name = unit:GetModifierNameByIndex(i)
        if name == buff then
            count = count + 1
        end
    end
    return count
end

function SinkUnitInGroundOverTime( event )
    local unit = event.target
    local pos = unit:GetAbsOrigin()
    local time_passed = 0
    local stepsize = event.depth / (30 * event.duration)
    Timers:CreateTimer(0.03,function()
        if unit and not unit:IsNull() then
            time_passed = time_passed + 0.03
            if time_passed < event.duration then
                unit:SetAbsOrigin(unit:GetAbsOrigin() + Vector(0,0,stepsize))
            end
            if time_passed < event.resetafter then
                return 0.03
            else
                unit:SetAbsOrigin(pos)
            end
        end
    end)
end

function AffixStunNearbyChickens( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if target and target:HasModifier("modifier_chicken_affix_abil") and caster ~= target then
        ability:ApplyDataDrivenModifier(caster, target, "modifier_stunned", {Duration = 5})
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 5, caster:GetAbsOrigin() + Vector(0,0,100))
        ParticleManager:SetParticleControl(particle, 4, target:GetAbsOrigin() + Vector(0,0,100))
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function AffixStarboy( event )
    local caster = event.caster
    local ability = event.ability
    local duration = 20
    local stars_per_sec = 4
    local ticks = duration * stars_per_sec
    local tick_interval = 1 / stars_per_sec
    local fly_time = 3.5
    local aoe = 150
    for i=0, ticks - 1 do
        Timers:CreateTimer(tick_interval * i,function()
            if caster and (caster:IsNull() or not caster:IsAlive()) then
                return
            end
            local target_point = caster:GetAbsOrigin() + RandomVector(math.random(1, 1750))
            FXStarfall(caster, target_point, Vector(600,600,1200), fly_time, aoe, true)
            Timers:CreateTimer(fly_time,function()
                local tab = {}
                tab.caster = caster
                tab.damage = 0.0
                tab.spelldamagefactor = 0.0
                tab.attributefactor = 0.0
                tab.includeauto = 500
                tab.ability = ability
                tab.aoe = aoe
                tab.targeteffect = "blood"
                tab.onlyhero = 1
                tab.target_points = {}
                tab.target_points[1] = target_point
                DamageAOE(tab)
            end)
        end)
    end
end

function FXStarfall(caster, target_point, offset, time, aoe, shadowfx)
    local particle = ParticleManager:CreateParticle("particles/invoker_chaos_meteor_fly_blue_slow2.5.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, target_point + offset)
    ParticleManager:SetParticleControl(particle, 1, target_point + Vector(0,0,50))
    ParticleManager:SetParticleControl(particle, 2, Vector(time,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
    EmitSoundOn("Hero_Luna.Eclipse.Cast", caster)
    local particle2
    if shadowfx then
        particle2 = ParticleManager:CreateParticle("particles/units/heroes/hero_shadow_demon/shadow_demon_soul_catcher_v2_ground01.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle2, 0, target_point)
        ParticleManager:SetParticleControl(particle2, 1, target_point)
        ParticleManager:SetParticleControl(particle2, 2, target_point)
        
    end
    Timers:CreateTimer(time,function()
        particle = ParticleManager:CreateParticle("particles/econ/items/wisp/wisp_death_ti7_model.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 1, target_point)
        ParticleManager:ReleaseParticleIndex(particle)
        particle = ParticleManager:CreateParticle("particles/items2_fx/veil_of_discord.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, target_point)
        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,aoe,aoe))
        ParticleManager:ReleaseParticleIndex(particle)
        if shadowfx and particle2 then
            ParticleManager:DestroyParticle(particle2,false)
            ParticleManager:ReleaseParticleIndex(particle2)
        end
    end)
end

function AffixGreedySaw( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local target_point = Vector(0,0,0)
    local all = HeroList:GetAllHeroes()
    local enemy_count = 0
    if target and (target:IsNull() or not target:IsAlive()) then
        UTIL_Remove(target)
        return
    end
    for i=1, #all do
        if all[i] and (all[i]:GetAbsOrigin() - target:GetAbsOrigin()):Length() <= 2500 then
            target_point = target_point + all[i]:GetAbsOrigin()
            enemy_count = enemy_count + 1
        end
    end
    if enemy_count > 0 then
        target_point = target_point / enemy_count
        local order = 
        {
            UnitIndex = target:entindex(),
            OrderType = DOTA_UNIT_ORDER_MOVE_TO_POSITION,
            Position = target_point
        }
        ExecuteOrderFromTable(order)
    end
end

function CheckForAutoAttackCriticalStrikeProcs(caster, target)
    if caster:HasModifier("modifier_fanatism") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 200, aacrit_chance = 10})
    end
    if caster:HasModifier("modifier_mythic_aacrit") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 300, aacrit_chance = caster:GetModifierStackCount("modifier_mythic_aacrit", nil)})
    end
    if caster:HasModifier("modifier_talent_crit") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 300, aacrit_chance = caster:GetModifierStackCount("modifier_talent_crit", nil)})
    end
    if caster:HasModifier("modifier_aa_crit_1000") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 1000, aacrit_chance = 100})
    end
    if caster:HasModifier("modifier_item_crit_pure_immortal_3") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 750, aacrit_chance = 15})
    end
    if caster:HasModifier("modifier_item_crit_pure_immortal_2") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 500, aacrit_chance = 5})
    end
    if caster:HasModifier("modifier_item_set_agi_set_crit_t1") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 275, aacrit_chance = 5})
    end
    if caster:HasModifier("modifier_item_set_agi_set_crit_t1_2") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 1000, aacrit_chance = 5})
    end
    if caster:HasModifier("modifier_item_set_str_dmg_full_t1") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 750, aacrit_chance = 15})
    end
    if caster:HasModifier("modifier_item_set_str_dmg_full_t12") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 1000, aacrit_chance = 15})
    end
    if caster:HasModifier("modifier_item_set_str_dmg_full_t13") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 500, aacrit_chance = 10})
    end
    if caster:HasModifier("modifier_item_bootsblood3") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 400, aacrit_chance = 15})
    end
    local armageddon = caster:FindModifierByName("modifier_item_crit_pure_immortal")
    if armageddon then
        local armageddonAbility = armageddon:GetAbility()
        if(armageddonAbility) then
            AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = armageddonAbility:GetSpecialValueFor("bonus_stat2"), aacrit_chance = armageddonAbility:GetSpecialValueFor("bonus_stat1")})
        end
    end
    if caster:HasModifier("modifier_item_set_agi_set_crit_2") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 275, aacrit_chance = 3})
    end
    if caster:HasModifier("modifier_item_set_str_dmg_3") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 450, aacrit_chance = 10})
    end
    if caster:HasModifier("modifier_item_endgame3") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 300, aacrit_chance = 10})
    end
    if caster:HasModifier("modifier_item_endgame32") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 250, aacrit_chance = 20})
    end
    if caster:HasModifier("modifier_item_weapon6") then
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 200, aacrit_chance = 20})
    end
    if caster.passiveAACrit then
        caster.passiveAACrit = false
        AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 250, aacrit_chance = 100})
    end
end

function GetFlatAutoAttackCritChance(caster)
    local value = 0
    if caster.talents[43] and caster.talents[43] > 0 then
        value = value + caster.talents[43]
    end
    return value
end

function AutoAttackCriticalStrike( event )
    local caster = event.attacker
    local target = event.target
    local crit_factor = event.aacrit_factor
    local crit_factor_bonus = 1
    local crit_chance = event.aacrit_chance
    if event.buffcondition then
        if not caster:HasModifier(event.buffcondition) then
            return
        else
            caster:RemoveModifierByName(event.buffcondition)
        end
    end
    if event.aacrit_chance_buff_based then
        crit_chance = caster:GetModifierStackCount(event.aacrit_chance_buff_based, nil)
    end
    local buff = "system_aacrit"
    local ability = event.ability
    --bonuses
    if caster:HasModifier("modifier_item_item_set_t4_aad_4") then
        crit_factor_bonus = crit_factor_bonus + 0.25
    end
    if caster:HasModifier("modifier_item_item_set_t4_aad_5") then
        crit_factor_bonus = crit_factor_bonus + 0.5
    end
    if caster.fragileAACrit then
        crit_factor_bonus = crit_factor_bonus + caster.fragileAACrit
    end
    if caster:HasModifier("modifier_item_set_agi_dmg_full_t1_2") then
        crit_factor_bonus = crit_factor_bonus + 0.25
    end
    if caster:HasModifier("modifier_special_bonus_gold_income") then
        crit_factor_bonus = crit_factor_bonus + 0.25
    end
    if caster:HasModifier("modifier_aaa2") then
        crit_factor_bonus = crit_factor_bonus + 0.25
    end
    if caster:HasModifier("modifier_pathbuff_049") then
        crit_factor_bonus = crit_factor_bonus + 0.25
    end
    if caster.talents and caster.talents[116] > 0 then
        local extra = 0.0001 * caster.talents[116]
        crit_factor_bonus = crit_factor_bonus + extra * GetAgilityCustom(caster)
    end
    if caster.lifeblood and caster.lifeblood > 1 and caster.talents and caster.talents[74] and caster.talents[74] > 0 and caster.path_sacrifice_souls_paid and caster:HasModifier("modifier_pathbuff_074") then
        crit_factor_bonus = crit_factor_bonus + 0.25
    end
    if caster:HasModifier("modifier_heartbreaker") and caster.talents and caster.talents[103] and caster.talents[103] > 0 then
        local dmgfactor = 0.0001
        if caster:HasModifier("modifier_path_shadowform") and caster:HasModifier("modifier_pathbuff_103") then
            dmgfactor = dmgfactor * 1.5
        end
        crit_factor_bonus = crit_factor_bonus + dmgfactor * caster.talents[103] * GetStrengthCustom(caster)
    end
    if caster:HasModifier("modifier_special_bonus_vision") then
        crit_factor_bonus = crit_factor_bonus + 0.1
    end
    if HeroHasNeutralItem(caster, "item_neutral_39") then
        crit_factor_bonus = crit_factor_bonus + 0.1
    end
    if caster:HasModifier("modifier_pathbuff_043") then
        crit_factor_bonus = crit_factor_bonus + 0.01 * caster:GetPhysicalArmorValue(false)
    end
    
    if caster.holyaaa_bonus then
        crit_factor_bonus = crit_factor_bonus + 0.5
        caster.holyaaa_bonus = false
        local particle = ParticleManager:CreateParticle("particles/econ/items/phantom_assassin/pa_ti8_immortal_head/pa_ti8_immortal_stifling_dagger_explosion.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if caster.holyaaa2_bonus then
        crit_factor_bonus = crit_factor_bonus + 2
        caster.holyaaa2_bonus = false
        local particle = ParticleManager:CreateParticle("particles/econ/items/phantom_assassin/pa_ti8_immortal_head/pa_ti8_immortal_stifling_dagger_explosion.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControl(particle, 3, target:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    --if caster.talents[48] and caster.talents[48] > 0 and (target:GetPhysicalArmorValue(false) < 15 or target:GetMagicalArmorValue() < 45 or target:GetHealth() / target:GetMaxHealth() < 0.3) then
    --    crit_factor_bonus = crit_factor_bonus + 0.1 * caster.talents[48]
    --end
    if caster.talents and caster.talents[73] and caster:HasModifier("modifier_path_shadowform") then
        crit_factor_bonus = crit_factor_bonus + 0.25 * caster.talents[73]
    end
    if caster.talents and caster.talents[158] then
        crit_factor_bonus = crit_factor_bonus + 0.1 * caster.talents[158]
    end
    if caster:HasModifier("modifier_berserker") then
        crit_factor_bonus = crit_factor_bonus + 0.01 * GetBerserkerStat(caster)
    end
    if caster.ab_crit_counter_last_5_secs and caster.ab_crit_counter_last_5_secs > 0 then
    	local sniper_ability = caster:FindAbilityByName("Bear")
    	if sniper_ability and sniper_ability:GetLevel() >= 4 then
    		crit_factor_bonus = crit_factor_bonus + 1
    	end
    end
    local flatCritChance = GetFlatCritChance(caster) + GetFlatAutoAttackCritChance(caster)
    crit_chance = crit_chance + flatCritChance
    if caster.windfury_proc_crit_bonus then
        crit_chance = crit_chance * 2
    end
    if caster and caster.talents then
        if caster.talents[82] and caster.talents[82] > 0 and math.random(1,100) <= 25 then
            crit_factor_bonus = crit_factor_bonus + 0.3333 * caster.talents[82]
        end
        SavageryProc(caster, 3)
    end
    if event.moonglaive_shield and caster:HasModifier("modifier_pathbuff_018") then
    	crit_factor_bonus = crit_factor_bonus * 3
    end
    if math.random(1,100) <= crit_chance and not caster:HasModifier(buff) then
        caster.fragileAACrit = 0
        if caster:HasModifier("modifier_item_myth_aad") then
            if caster.aa_crit_counter then
                caster.aa_crit_counter = caster.aa_crit_counter + 1
                if caster.aa_crit_counter % 10 == 0 then
                    crit_factor = crit_factor * 10
                end
                if caster.aa_crit_counter > 10000000 then
                    caster.aa_crit_counter = 1
                end
            else
                caster.aa_crit_counter = 1
            end
        end
        caster:RemoveModifierByName(buff)
        ability:ApplyDataDrivenModifier(caster, caster, buff, nil)
        caster:SetModifierStackCount(buff, ability, crit_factor * crit_factor_bonus)
        --on crit procs
        if caster and caster.talents then
            if caster.talents[123] and caster.talents[123] > 0 then
                ApplyBuffStack({caster = caster, target = caster, ability = caster.combat_system_ability, dur = 3, addstacks = caster.talents[123], max = 100 * caster.talents[123], buff = "modifier_growingpainsdd"})
            end
            GlobalOnDamagingCritLanded(caster, target)
            if caster.talents[78] and caster.talents[78] > 0 then
                local stacks = 1 + caster.talents[78]
                ApplyBuffStack({caster = caster, target = target, ability = caster.combat_system_ability, dur = 3, addstacks = stacks, max = stacks, buff = "modifier_stormclaws_armor"})
            end
            if caster.talents[120] and caster.talents[120] > 0 then
                ArcaneExplosionPath(caster)
            end
        end
        if caster:HasModifier("modifier_pathbuff_094") then
            caster.deadfury_crit_chance_factor = 3
        end
        if caster:HasModifier("modifier_catform") then
        	local feral_ability = caster:FindAbilityByName("ShapeshiftFeral")
        	if feral_ability and feral_ability:GetLevel() >= 4 then
        		feral_ability:ApplyDataDrivenModifier(caster, caster, "modifier_bat_1_wildg", {Duration = 3})
        	end
        end
        --aa crit in last 10 secs counter
        if not caster.aa_crit_counter_last_10_secs then
        	caster.aa_crit_counter_last_10_secs = 0
        end
        caster.aa_crit_counter_last_10_secs = caster.aa_crit_counter_last_10_secs + 1
        if caster.aa_crit_counter_last_10_secs == 1 and caster.talents[58] and caster.talents[58] > 0 then
        	caster.true_blood_particle = ParticleManager:CreateParticle("particles/items4_fx/spirit_vessel_damage_ring_detail.vpcf", PATTACH_POINT_FOLLOW, caster)
        end
        if GetLevelOfAbility(caster, "Retri6") >= 2 then
            --if caster.retri_aa_crit_target ~= target then
            --    caster:RemoveModifierByName("modifier_dfury")
            --end
            --caster.retri_aa_crit_target = target
            ApplyBuffStack({caster = caster, target = caster, ability = caster:GetAbilityByIndex(5), dur = 8, max = 100, buff = "modifier_dfury"})
        end
        Timers:CreateTimer(5, function()
        	caster.aa_crit_counter_last_10_secs = caster.aa_crit_counter_last_10_secs - 1
        	if caster.aa_crit_counter_last_10_secs == 0 and caster.true_blood_particle then
        		ParticleManager:DestroyParticle(caster.true_blood_particle,false)
        		ParticleManager:ReleaseParticleIndex(caster.true_blood_particle)
        	end
        end)
    end
end

function GetHighestAbilityScaling(event)
    local scaling = 0
    if event.attributefactor then
        scaling = event.attributefactor
    end
    local value = event.spelldamagefactor
    if value and value > scaling then
        scaling = value
    end
    value = event.includeauto
    if value and value > scaling then
        scaling = value
    end
    value = event.includefullauto
    if value and value > scaling then
        scaling = value
    end
    return scaling
end

--[[
function GetPathSynergyID( pathID ) --which path does the given path improve?
    if pathID >= 10 and pathID <= 12 then
        return pathID + 39
    end
    if pathID >= 22 and pathID <= 24 then
        return pathID + 30
    end
    if pathID >= 34 and pathID <= 36 then
        return pathID + 21
    end
    if pathID >= 46 and pathID <= 48 then
        return pathID + 12
    end
    if pathID >= 49 and pathID <= 51 then
        return pathID - 48
    end
    if pathID >= 52 and pathID <= 54 then
        return pathID - 39
    end
    if pathID >= 55 and pathID <= 57 then
        return pathID - 30
    end
    if pathID >= 58 and pathID <= 60 then
        return pathID - 21
    end
    if (pathID >= 73 and pathID <= 75) or (pathID >= 88 and pathID <= 90) or (pathID >= 103 and pathID <= 105) or (pathID >= 118 and pathID <= 120) then --new ulti row to first
        return pathID - 12
    end
    if (pathID >= 49 and pathID <= 60) or (pathID >= 73 and pathID <= 75) or (pathID >= 88 and pathID <= 90) or (pathID >= 103 and pathID <= 105) or pathID == 62 or pathID == 85 or pathID == 107 or pathID == 112 or (pathID >= 118 and pathID <= 120) then -- last row ultimates dont apply synergies
        return -1
    end
    --some paths were swapped
    --if pathID == 33 then
    --    return 31
    --end
    return pathID + 3
end]]

function GetPathSynergyID( pathID ) --which path does the given path improve?
    if pathID >= 10 and pathID <= 12 then
        return pathID + 39
    end
    if pathID >= 22 and pathID <= 24 then
        return pathID + 30
    end
    if pathID >= 34 and pathID <= 36 then
        return pathID + 21
    end
    if pathID >= 46 and pathID <= 48 then
        return pathID + 12
    end
    if pathID >= 49 and pathID <= 60 then
        return -1
    end
    --if pathID >= 49 and pathID <= 51 then
    --    return pathID - 48
    --end
    --if pathID >= 52 and pathID <= 54 then
    --    return pathID - 39
    --end
    --if pathID >= 55 and pathID <= 57 then
    --    return pathID - 30
    --end
    --if pathID >= 58 and pathID <= 60 then
    --    return pathID - 21
    --end
    if (pathID >= 73 and pathID <= 75) or (pathID >= 88 and pathID <= 90) or (pathID >= 103 and pathID <= 105) or (pathID >= 118 and pathID <= 120) then --new ulti row to first
        return -1 --pathID - 12
    end
    if (pathID >= 121 and pathID <= 144) or (pathID >= 49 and pathID <= 60) or (pathID >= 73 and pathID <= 75) or (pathID >= 88 and pathID <= 90) or (pathID >= 103 and pathID <= 105) or pathID >= 160 or pathID == 62 or pathID == 85 or pathID == 107 or pathID == 112 or (pathID >= 118 and pathID <= 120) then -- last row ultimates dont apply synergies
        return -1
    end
    --some paths were swapped
    --if pathID == 33 then
    --    return 31
    --end
    return pathID + 3
end

function GetPathSynergyBonuses(hero) --down propagation of path levels
    if not hero.talents_without_pathwords then
        return nil
    end
    local pathSynergies = {}
    for i=1, COverthrowGameMode.maxtalents do
        pathSynergies[i] = 0
    end
    local propagationRatio = 5 --how many levels required for propagating down 1 level
    local maxBonus = 2
    for i=1, COverthrowGameMode.maxtalents do
        local pathSynergyID = GetPathSynergyID(i) --which path does this path affect?
        if pathSynergyID >= 1 and hero.talents[i] and hero.talents[i] >= propagationRatio then
            if pathSynergyID ~= 88 and pathSynergyID ~= 105 then --hard exceptions
                if (pathSynergyID ~= 6 and pathSynergyID ~= 21 and pathSynergyID ~= 28 and pathSynergyID ~= 33 and pathSynergyID ~= 58 and pathSynergyID ~= 72 and pathSynergyID ~= 74 and pathSynergyID ~= 96 and pathSynergyID ~= 99) or (hero.talents_without_pathwords[pathSynergyID] and hero.talents_without_pathwords[pathSynergyID] >= 1) then --path synergy exceptions (negative side effects), require 1 non-synergy point
                    local bonus = math.floor(hero.talents[i] / propagationRatio)
                    if bonus > maxBonus then
                        bonus = maxBonus
                    end
                    pathSynergies[pathSynergyID] = bonus
                end
            end
        end
    end
    return pathSynergies
end


function GetPathBonusesFromPathWords(hero)
    if not hero.talents_without_pathwords then
        return nil
    end
    local pathwords = {}
    for i=1, COverthrowGameMode.maxtalents do
        pathwords[i] = {0, nil}
    end
    local proc_threshold = 6
    local bonus_on_proc = 1
    local offset = 60 --30
    local max_path_words = 12
    local path_words_found = 0
    if not hero.disablePathWordBonuses then
        for i=1, COverthrowGameMode.maxtalents do
            if hero.talents_without_pathwords[i] and hero.talents_without_pathwords[i] >= proc_threshold then
                local first_tree = COverthrowGameMode:GetTalentTreeByTalentPoint(i)
                for j=i+1, COverthrowGameMode.maxtalents do
                    local second_tree = COverthrowGameMode:GetTalentTreeByTalentPoint(j)
                    if hero.talents_without_pathwords[j] and hero.talents_without_pathwords[j] >= proc_threshold and first_tree ~= second_tree and path_words_found <= max_path_words then
                        local bonus_index = 1 + ((i * j + offset) % (90 - 1)) --fixate old pathwords, independant of new additions
                        if j >= 91 then
                            bonus_index = 1 + ((i * j + offset) % (COverthrowGameMode.maxtalents + 1)) --new pathwords can be anything
                        end
                        if bonus_index ~= 58 and bonus_index ~= 74 and bonus_index ~= 105 then --some pathwords have too strong drawbacks
                            --if bonus_index == 51 or bonus_index == 54 or bonus_index == 57 or bonus_index == 60 or bonus_index == 75 then --those paths do exist now!
                            --    bonus_index = bonus_index - 1
                            --end
                            local name1 = GetFirstPathName(i)
                            local name2 = GetLastPathName(j)
                            --local name3 = GetLastPathName(bonus_index)
                            if name1 and name2 and COverthrowGameMode.PathTalentNames[bonus_index] then --name3
                                local new_bonus = pathwords[bonus_index][1] + bonus_on_proc
                                --local bonus_name = name1 .. " " .. name2 .. " " .. name3 .. ": +" .. new_bonus .. " " .. COverthrowGameMode.PathTalentNames[bonus_index]
                                local bonus_name = name1 .. " " .. name2 .. " " .. ": +" .. new_bonus .. " " .. COverthrowGameMode.PathTalentNames[bonus_index]
                                pathwords[bonus_index] = {new_bonus, bonus_name}
                                path_words_found = path_words_found + 1
                            end
                        end
                    end
                end
            end
        end
    end
    --DeepPrintTable(pathwords)
    return pathwords
end

function GetFirstPathName( id )
    local pieces = COverthrowGameMode.PathTalentNames[id]
    local words = {}
    for w in pieces:gmatch("%S+") do 
        table.insert(words, w) 
    end
    return words[1]
end

function GetLastPathName( id )
    local pieces = COverthrowGameMode.PathTalentNames[id]
    local words = {}
    for w in pieces:gmatch("%S+") do 
        table.insert(words, w) 
    end
    return words[#words]
end

function SendPathWordsToUI(hero, pathwords)
    local bonuses = ""
    for i=1, COverthrowGameMode.maxtalents do
        if pathwords and pathwords[i] and pathwords[i][1] > 0 then
            bonuses = bonuses .. pathwords[i][2] .. "," .. i .. ","
        end
    end
    --local player = PlayerResource:GetPlayer(hero:GetPlayerID())
    --print(bonuses)
    CustomGameEventManager:Send_ServerToAllClients("pathword", { playerid = hero:GetPlayerID(), pathword = bonuses } )
end

function ApplyBuffDataDriven( event )
    local caster = event.caster
    local ability = event.ability
    local target = event.target
    if event.only_when_damaged and caster:GetHealth() / caster:GetMaxHealth() >= 1 then
        return
    end
    ability:ApplyDataDrivenModifier(caster, target, event.buff, {Duration = event.dur})
end

function WingedGrave( event )
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	if not target:HasModifier("modifier_winged_grave_cd") then
		ApplyBuff(event)

		--event.buff = "modifier_guaranteed_crit"
		--event.dur = event.dur2
		--ApplyBuff(event)
		ability:ApplyDataDrivenModifier(caster, target, "modifier_winged_grave_cd", {Duration = 45})
        if event.taunt and event.taunt > 0 then
            event.buff = "modifier_taunt123"
            ApplyBuff(event)
        end
	end
end

function CainSetGiveLife( event )
	local caster = event.caster
	local target = event.target
	local max_lives = event.count
	if not caster.cain_lives_given then
		caster.cain_lives_given = 0
	end
	if caster.cain_lives_given < max_lives and target and target.ArenaControl and target.pvelives then
		local lives = target:GetModifierStackCount("modifier_pvelives", nil)
		target.ArenaControl:GetAbilityByIndex(0):ApplyDataDrivenModifier(target.ArenaControl, target, "modifier_pvelives", nil)
		target:SetModifierStackCount("modifier_pvelives", target.ArenaControl:GetAbilityByIndex(0), lives + 1)
		target.pvelives = target.pvelives + 1
		caster.cain_lives_given = caster.cain_lives_given + 1
		EmitGlobalSound("treant_treant_spawn_04")
	end
end

function AddLivesToHero( target, extraLives )
    if target.ArenaControl and target.pvelives then
        local lives = target:GetModifierStackCount("modifier_pvelives", nil)
        target.ArenaControl:GetAbilityByIndex(0):ApplyDataDrivenModifier(target.ArenaControl, target, "modifier_pvelives", nil)
        target:SetModifierStackCount("modifier_pvelives", target.ArenaControl:GetAbilityByIndex(0), lives + extraLives)
        target.pvelives = target.pvelives + extraLives
        if target.pvelives <= 0 then
            target:RemoveModifierByName("modifier_pvelives")
        end
        return true
    end
    return false
end

function SetInstanCasts( event )
	local caster = event.caster
	local ability = event.ability
	--if not caster.book_of_runes_instants then
	--	caster.book_of_runes_instants = 0
	--end
	caster.book_of_runes_ability = ability
	caster.book_of_runes_instants = event.amount
	ability:ApplyDataDrivenModifier(caster, caster, "modifier_book_instant_casts", {Duration = 5})
	caster:SetModifierStackCount("modifier_book_instant_casts", ability, caster.book_of_runes_instants)
end

function AstralProcDamage200( event )
    if event.ability:GetLevel() >= 4 then
        event.caster.astral_ability_200 = true
    end
end

function GetAbilitiesOnCooldown( caster )
    if not caster then
        return 0
    end
    local count = 0

    for i=0, COverthrowGameMode.heroAbilityCount do
        local ab = caster:GetAbilityByIndex(i)
        if ab and not ab:IsPassive() and ab:GetCooldownTimeRemaining() > 0.1 then
            count = count + 1
        end
    end
    return count
end

function GetTotalAbilityCooldowns( caster )
    if not caster then
        return 0
    end
    local count = 0
    for i=0, COverthrowGameMode.heroAbilityCount do
        local ab = caster:GetAbilityByIndex(i)
        if ab and not ab:IsPassive() and ab:GetCooldownTimeRemaining() >= 0.1 then
            count = count + ab:GetCooldownTimeRemaining()
        end
    end
    return math.floor(count)
end

function GetHighestRemainingCooldownAbility( caster )
    if not caster then
        return
    end
    local cd = 0
    local ability = nil
    for i=0, COverthrowGameMode.heroAbilityCount do
        local ab = caster:GetAbilityByIndex(i)
        if ab and not ab:IsPassive() and ab:GetCooldownTimeRemaining() > cd then
            cd = ab:GetCooldownTimeRemaining()
            ability = ab
        end
    end
    return ability
end

function GetHighestCooldownAbility( caster )
    if not caster then
        return
    end
    local cd = 0
    local ability = nil
    for i=0, COverthrowGameMode.heroAbilityCount do
        local ab = caster:GetAbilityByIndex(i)
        if ab and not ab:IsPassive() then
            local baseCD = ab:GetCooldown(ab:GetLevel())
            if ab:GetLevel() >= 1 and baseCD >= 1 and baseCD > cd then
                cd = baseCD
                ability = ab
            end
        end
    end
    return ability
end

--new stash extension

function SaveItemIntoStashTable( hero, target_stash_id, slot, itemname, item_shareable )
    if hero and target_stash_id and itemname and slot and hero.stash then
        if not hero.stash[target_stash_id] then
            hero.stash[target_stash_id] = {}
        end
        hero.stash[target_stash_id][slot] = {}
        hero.stash[target_stash_id][slot][1] = itemname
        hero.stash[target_stash_id][slot][2] = item_shareable
    end
end

function GetStashTableItem( hero, target_stash_id, slot)
    if hero and target_stash_id and slot and hero.stash and hero.stash[target_stash_id] and hero.stash[target_stash_id][slot] and hero.stash[target_stash_id][slot][1] then
        return hero.stash[target_stash_id][slot][1]
    end
    return "no"
end

function GetStashTableItemShareStatus( hero, target_stash_id, slot)
    if hero and target_stash_id and slot and hero.stash and hero.stash[target_stash_id] and hero.stash[target_stash_id][slot] and hero.stash[target_stash_id][slot][2] then
        return true
    end
    return false
end

function SaveCurrentStashItemsToStashTable( hero, target_stash_id )
    if hero and target_stash_id then
        for i=9,14 do
            if not hero.stash[target_stash_id] then
                hero.stash[target_stash_id] = {}
            end
            if not hero.stash[target_stash_id][i-8] then
                hero.stash[target_stash_id][i-8] = {}
            end
            local item = hero:GetItemInSlot(i)
            if item and not item:IsMuted() then
                hero.stash[target_stash_id][i-8][1] = item:GetName()
                hero.stash[target_stash_id][i-8][2] = item.droppedthisgame
            else
                hero.stash[target_stash_id][i-8][1] = "no"
                hero.stash[target_stash_id][i-8][2] = false
            end
        end
    end
    --DeepPrintTable(hero.stash)
end

function LoadStashTableItemsIntoStash( hero, stash_id )
    ClearItemsInStash(hero)
    if hero and stash_id then
        for i=1,6 do
            if hero.stash and hero.stash[stash_id] and hero.stash[stash_id][i] and hero.stash[stash_id][i][1] and hero.stash[stash_id][i][1] ~= "no" then
                --inventory gets filled first, then backpack, then stash
                local filler_item_count = 8 + i - COverthrowGameMode:GetNumberItemsInInventory(hero) - COverthrowGameMode:GetNumberItemsInBackpack(hero) - COverthrowGameMode:GetNumberItemsInStash(hero)
                local itemname = hero.stash[stash_id][i][1]
                local shareable = hero.stash[stash_id][i][2]
                local filler = {}
                for k=1, filler_item_count do
                   filler[k] = hero:AddItemByName( "item_dmg1" )
                end
                local newitem = hero:AddItemByName( itemname )
                if shareable and newitem then
                   newitem.droppedthisgame = true
                end
                --Timers:CreateTimer(10,function()
                for k=1, filler_item_count do
                   UTIL_Remove( filler[k] )
                end
                EmitSoundOn("DOTA_Item.Hand_Of_Midas", hero)
            end
        end
    end
    --DeepPrintTable(hero.stash)
end

function ClearItemsInStash( hero )
    for i=9,14 do
        local item = hero:GetItemInSlot(i)
        if item then
            UTIL_Remove( item )
        end
    end
end

function ToggleStash( hero )
    if hero.bought_stash_count and hero.current_stash_id then
        SaveCurrentStashItemsToStashTable( hero, hero.current_stash_id )
        hero.current_stash_id = hero.current_stash_id + 1
        if hero.current_stash_id > hero.bought_stash_count then
            hero.current_stash_id = 1
        end
        LoadStashTableItemsIntoStash( hero, hero.current_stash_id )
    end
end

function TryToggleStash(event, args)
    local player = PlayerResource:GetPlayer(args['nr'])
    local hero = player:GetAssignedHero()
    if hero and hero.auto_loaded and hero.bought_stash_count and hero.bought_stash_count > 1 and player then
        ToggleStash( hero )
        local text = "Toggle Stash: [" .. hero.current_stash_id .. "/" .. hero.bought_stash_count .. "]"
        if not hero.premium then
            text = "Stash not unlocked";
        end
        CustomGameEventManager:Send_ServerToPlayer(player, "toggle_stash_set_number", {nr = text})
    end
end

function SoulPact( event )
    local caster = event.caster
    local target = event.target
    caster.soul_pact_heal = nil
    if caster == target then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_dh_tank_res", {Duration = event.dur})
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_dh_soulpact", {Duration = event.dur})
        if event.heal and event.heal == 1 then
            event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_dh_soulpact_chaos", {Duration = event.dur})
        end
    else
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_dh_tank_armor", {Duration = event.dur})
        event.ability:ApplyDataDrivenModifier(caster, target, "modifier_dh_soulpact", {Duration = event.dur})
        if event.heal and event.heal == 1 then
            event.ability:ApplyDataDrivenModifier(caster, target, "modifier_dh_soulpact_heal", {Duration = event.dur})
            caster.soul_pact_heal = target
        end
    end
end

function PathStormStrikeProc( caster, target, is_aa, is_channel, ignoreInnerCD, alwaysProc)
    if caster.talents[87] <= 0 then
        return
    end
    local storm_harpy_chance = 15
    if is_channel then
        storm_harpy_chance = 25
    end
    if caster:HasModifier("modifier_pathbuff_007") then
        local extraChance = caster:GetModifierStackCount("modifier_talent_maul", nil) / 10
        storm_harpy_chance = storm_harpy_chance + extraChance
    end
    if is_aa and caster.storm_harpy_non_proc_counter and caster.storm_harpy_non_proc_counter >= 10 then
        storm_harpy_chance = 100
    end
    if (alwaysProc or math.random(1,100) <= storm_harpy_chance) and (ignoreInnerCD or not caster.storm_harpy_inner_cooldown) then
        if not ignoreInnerCD then
            caster.storm_harpy_inner_cooldown = true
        end
        caster.storm_harpy_non_proc_counter = 0
        storm_strike_procs = 1
        if caster:HasModifier("modifier_pathbuff_016") and math.random(1,100) <= 50 then
            storm_strike_procs = 2
        end
        for i=1, storm_strike_procs do
            Timers:CreateTimer(i - 0.9, function()
                ApplyBuffStack({caster = caster, target = caster, ability = caster.combat_system_ability, dur = 5, addstacks = caster.talents[87], max = 25, buff = "modifier_stormharpy"})
                if target and not target:IsNull() then
                    PathChainLightning({caster = caster, target = target, ability = caster.combat_system_ability})
                end
            end)
        end
        if not ignoreInnerCD then
            Timers:CreateTimer(0.1 * GetInnerCooldownFactor(caster), function()
                caster.storm_harpy_inner_cooldown = false
            end)
        end
        OnNaturalDisasterProcced(caster, target, 4)
    else
        if caster:HasModifier("modifier_item_helmthunder2") and is_aa then
            if caster.storm_harpy_non_proc_counter then
                caster.storm_harpy_non_proc_counter = caster.storm_harpy_non_proc_counter + 1
            else
                caster.storm_harpy_non_proc_counter = 1
            end
        end
    end
end

function HealProcs(caster, target, isdot)
    if caster and caster.talents then
        DivineBlessingProc(caster)
        if caster.talents[16] and caster.talents[16] > 0 and caster == target and caster.combat_system_ability then
            caster.combat_system_ability:ApplyDataDrivenModifier(caster, caster, "modifier_fairy", {Duration = 15})
        end
    end
    if caster == target and GetLevelOfAbility(caster, "mars4") >= 4 then
        local myevent = {}
        myevent.caster = caster
        myevent.energy = 10
        AddEnergy(myevent)
    end
    if caster == target and GetLevelOfAbility(caster, "Infested_Wound") >= 4 then
        caster:GetAbilityByIndex(2):ApplyDataDrivenModifier(caster, caster, "modifier_dkres", {Duration = 3})
    end
    if (not isdot) and target and target.talents then
        if target:HasModifier("modifier_rotting") then
            caster:RemoveModifierByName("modifier_rotting")
        end
    end
    if HeroHasNeutralItem(caster, "item_neutral_32") then
        ApplyBuff({ caster = caster, target = target, dur = 5, buff = "modifier_eyeaegis", ability = caster.combat_system_ability})
    end
end

function OnSummonedUnit( summon, hero )
    print("summon")
    if hero.talents then
        if hero.talents[69] and hero.talents[69] > 0 and ((not hero.talent69_buffs) or (hero.talent69_buffs and hero.talent69_buffs < 5)) then
            local duration = 10
            AddSpellhaste(hero, 30 * hero.talents[69], duration)
            AddAttackSpeed(hero, 30 * hero.talents[69], duration)
            if not hero.talent69_buffs then
                hero.talent69_buffs = 0
            end
            hero.talent69_buffs = hero.talent69_buffs + 1
            Timers:CreateTimer(duration, function()
                hero.talent69_buffs = hero.talent69_buffs - 1
            end)
        end
        if hero:HasModifier("modifier_pathbuff_092") and hero.frostmourne_item_ability then
            hero.frostmourne_item_ability:ApplyDataDrivenModifier(hero, hero, "modifier_frostmourne_dmg", {Duration = 5})
        end
        if hero.talents[46] and hero.talents[46] > 0 then
            hero.combat_system_ability:ApplyDataDrivenModifier(hero, hero, "modifier_bloodwolf_buff", {Duration = 5})
        end
        if HeroHasNeutralItem(hero, "item_neutral_26") then
            hero.bookofdeadCrit = 1
        end
    end
end

function FrostmourneItemSet( event )
    event.caster.frostmourne_item_ability = event.ability
end

function AddSpellhasteScript( event )
    local caster = event.caster
    AddSpellhaste( caster, event.amount, event.dur )
end

function AddSpellhasteConditional( event )
    local caster = event.caster
    if caster:HasModifier(event.buff) then
        AddSpellhaste( caster, event.amount, 10 )
        local particle = ParticleManager:CreateParticle("particles/econ/items/zeus/zeus_ti8_immortal_arms/zeus_ti8_immortal_arc_flash.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function AddSpellhaste( hero, amount, duration )
    if not hero.spellhaste_system_bonus then
        hero.spellhaste_system_bonus = 0
    end
    if hero.spellhaste_system_bonus <= 0 then
        hero.spellhaste_system_particle = ParticleManager:CreateParticle("particles/econ/items/lina/lina_ti6/lina_ti6_ambient_ground_aura.vpcf", PATTACH_POINT_FOLLOW, hero)
    end
    hero.spellhaste_system_bonus = hero.spellhaste_system_bonus + amount
    Timers:CreateTimer(duration, function()
        hero.spellhaste_system_bonus = hero.spellhaste_system_bonus - amount
        if hero.spellhaste_system_bonus <= 0 and hero.spellhaste_system_particle then
            ParticleManager:DestroyParticle(hero.spellhaste_system_particle,false)
            ParticleManager:ReleaseParticleIndex(hero.spellhaste_system_particle)
        end
    end)
end

function AddPrimaryAttribute( hero, amount, duration )
    if not hero.primary_bonus_system then
        hero.primary_bonus_system = 0
    end
    hero.primary_bonus_system = hero.primary_bonus_system + amount
    Timers:CreateTimer(duration, function()
        hero.primary_bonus_system = hero.primary_bonus_system - amount
    end)
end

function AddAttackSpeed( hero, amount, duration )
    if not hero.attackspeed_system_bonus then
        hero.attackspeed_system_bonus = 0
    end
    if hero.attackspeed_system_bonus <= 0 then
        hero.attackspeed_system_particle = ParticleManager:CreateParticle("particles/econ/items/lina/lina_ti6/lina_ti6_ambient_ground_aura.vpcf", PATTACH_POINT_FOLLOW, hero)
    end
    hero.attackspeed_system_bonus = hero.attackspeed_system_bonus + amount
    Timers:CreateTimer(duration, function()
        hero.attackspeed_system_bonus = hero.attackspeed_system_bonus - amount
        if hero.attackspeed_system_bonus <= 0 and hero.attackspeed_system_particle then
            ParticleManager:DestroyParticle(hero.attackspeed_system_particle,false)
            ParticleManager:ReleaseParticleIndex(hero.attackspeed_system_particle)
        end
    end)
end

function SetRuneItemAbility( event )
    event.caster.rune_item_ability = event.ability
end

function SetRuneItemAbility2( event )
    event.caster.rune_item_ability2 = event.ability
end

function SetSnowlItemAbility2( event )
    event.caster.snowl_item_ability2 = event.ability
end

function SetSnowlItemAbility( event )
    event.caster.snowl_item_ability = event.ability
end

function GetTotalDamageTakenFactor(caster, attacker)
    local factor = 1
    if caster:HasModifier("modifier_class_demo") then
        factor = 1 - 0.1 * GetDemonCount(caster)
    end
    if caster:HasModifier("modifier_talent_genesis") and caster.talents and caster.talents[135] > 0 then
        factor = factor * 0.7
    end
    if caster:HasModifier("modifier_savagery") and HeroHasNeutralItem(caster, "item_neutral_13") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_symbiosos_fur") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_divinedef") then
        factor = factor * 0.85
    end
    if caster.phoenixReduction then
        factor = factor * 0.01
    end
    if caster:HasModifier("modifier_class_mars2") and caster:GetName() == "npc_dota_hero_mars" then
        local reduc = 0.0005 * GetAgilityCustom(caster)
        if reduc > 0.5 then
            reduc = 0.5
        end
        factor = factor * (1 - reduc)
    end
    if caster:HasModifier("modifier_equilibrium") then
        factor = factor * 0.55
    end
    if caster:HasModifier("modifier_killdance_imunity") then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_killdance") then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_rrod") then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_mol") then
        factor = factor * 0.9
    end
    if caster:HasModifier("modifier_bloodmoon") then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_bloodflow_cd") and caster:HasModifier("modifier_pathbuff_097") then
        factor = factor * 0.85
    end
    if caster:HasModifier("modifier_rond") then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_156_active") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_phantomShade") then
        factor = factor * 0.25
    end
    if caster.talents then
        if attacker and caster and caster.talents and caster.talents[106] and caster.talents[106] > 0 and caster:HasModifier("modifier_guardianshield") then
            local distance = (caster:GetAbsOrigin() - attacker:GetAbsOrigin()):Length()
            if distance <= 450 then
                factor = factor * (1 - 0.03 * caster.talents[106])
            end
        end
        if caster.talents[143] > 0 and GiantsOnCooldown(caster) then
            factor = factor * (1 - 0.1 * caster.talents[143])
        end
    end
    if caster:HasModifier("modifier_chaosshield2") then
        factor = factor * (1 - 0.05 * GetAbilitiesOnCooldown(caster))
    end
    if GetLevelOfAbility(caster, "Ice_Armor") >= 3 then
        local redu = 1 - caster:GetPhysicalArmorValue(false) * 0.004
        if redu < 0.5 then
            redu = 0.5
        end
        factor = factor * redu
    end
    if caster:HasModifier("modifier_taunt123") and GetLevelOfAbility(caster, "mars6") >= 4 then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_invul_ally") then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_bop") then
        factor = factor * 0.7
    end
    if caster:HasModifier("modifier_feraldef") then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_divinebl") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_stealthdef") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_dazzredu") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_totem_life_buff") then
        factor = factor * 0.05
    end
    if caster:HasModifier("modifier_ironshield") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_holydef") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_iron_heart") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_talent_invul") then
        factor = factor * 0.25
    end
    if caster:HasModifier("consecrationarmor") then
        factor = factor * 0.75
    end
    local necroMark = caster:GetModifierStackCount("modifier_necrotic_mark", nil)
    if necroMark > 0 then
        factor = factor * (1 - 0.01 * necroMark)
    end
    if caster:HasModifier("modifier_shaolin_sanctum") then
        factor = factor * 0.2
    end
    if caster:HasModifier("modifier_boneshield") then
        factor = factor * 0.65
    end
    if caster:HasModifier("modifier_holy3_def") then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_eternallife") then
        factor = factor * 0.05
    end
    if caster:HasModifier("modifier_destro_def") then
        factor = factor * 0.35
    end
    if caster:HasModifier("modifier_warlockrage") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_shamandef") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_firefly_mage") then
        if caster:FindAbilityByName("fire6"):GetLevel() >= 2 then
            factor = factor * 0.4
        else
            factor = factor * 0.7
        end
    end
    if caster:HasModifier("modifier_ranger_def") then
        if GetLevelOfAbility(caster, "wind3") >= 2 then
            factor = factor * 0.2
        else
            factor = factor * 0.6
        end
    end
    if caster:HasModifier("modifier_shadow_stance_def") then
        if caster:FindAbilityByName("shadow6"):GetLevel() >= 2 then
            factor = factor * 0.25
        else
            factor = factor * 0.5
        end
    end
    if caster:HasModifier("modifier_slaught_def") then
        if caster:FindAbilityByName("fury4"):GetLevel() >= 2 then
            factor = factor * 0.6
        else
            factor = factor * 0.75
        end
    end
    if caster:HasModifier("modifier_storm_shield") then
        if caster:FindAbilityByName("Ghost4"):GetLevel() >= 3 then
            factor = factor * 0.1
        else
            factor = factor * 0.55
        end
    end
    if caster:HasModifier("modifier_kingsguard") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_beastheal_reduction") then
        if caster:FindAbilityByName("Beastheal"):GetLevel() >= 3 then
            factor = factor * 0.25
        else
            --factor = factor * 0.7
        end
    end
    if caster:HasModifier("modifier_shapeshifttravel_mana") then
        local shapeShiftAbility = caster:FindAbilityByName("Shapeshift")
        if shapeShiftAbility and shapeShiftAbility:GetLevel() >= 3 then
            factor = factor * 0.65
        else
            --factor = factor * 0.7
        end
    end
    if caster:HasModifier("modifier_temple_guard_active") then
        if caster:FindAbilityByName("ShapeshiftTemple"):GetLevel() >= 3 then
            factor = factor * 0.5
        else
            --factor = factor * 0.7
        end
    end
    if caster:HasModifier("lakearmor") then
        if caster:FindAbilityByName("frost_lake"):GetLevel() >= 2 then
            factor = factor * 0.1
        else
            factor = factor * 0.5
        end
    end
    if caster:HasModifier("modifier_shaman_resistance") then
        factor = factor * 0.85
    end
    if caster:HasModifier("modifier_WarriorCharge") then
        local bearAbility = caster:FindAbilityByName("bear3")
        if bearAbility and bearAbility:GetLevel() >= 4 then
            factor = factor * 0.1
        else
            --factor = factor * 0.5
        end
    end
    
    if caster:HasModifier("modifier_pain_supression") then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_blurblend") and caster:FindAbilityByName("dh5") and caster:FindAbilityByName("dh5"):GetLevel() >= 2 then
        factor = factor * 0.5
    end
    if (caster:HasModifier("modifier_eyebeam") or caster:HasModifier("modifier_eyebeam_res")) and caster:FindAbilityByName("dh4") and caster:FindAbilityByName("dh4"):GetLevel() >= 4 then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_tranq") and caster:FindAbilityByName("moon5") and caster:FindAbilityByName("moon5"):GetLevel() >= 3 then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_blizzard2") and caster:FindAbilityByName("frostdk5") and caster:FindAbilityByName("frostdk5"):GetLevel() >= 2 then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_astralarmor") and caster:FindAbilityByName("Ghost6") and caster:FindAbilityByName("Ghost6"):GetLevel() >= 4 then
        factor = factor * 0.5
    end
    
    if caster:HasModifier("modifier_water_shield") then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_reduction_50") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_meditation_reduction") then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_arcanebarrier") then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_retri_boost") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_stealthcat") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_root_shield") then
        factor = factor * 0.2
    end
    if caster:HasModifier("modifier_wl_shield") then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_interruptimune") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_deathwish_def") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_dk_tank_def") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_disc_shadowshield") then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_lava_shield") then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_ice_armor_2") then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_holy_ring") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_guardian") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_barkskin") then
        factor = factor * 0.4
    end
    if caster:HasModifier("modifier_voodooshield") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_item_item_set_t4_new_4") then
        factor = factor * 0.9
    end
    if caster:HasModifier("modifier_item_item_set_t4_new_4") then
        factor = factor * 0.9
    end
    if caster:HasModifier("modifier_activedruid") then
        factor = factor * 0.5
    end
    if caster:HasModifier("modifier_t3_str") then
        factor = factor * 0.75
    end
    if caster:HasModifier("modifier_last_stand") then
        factor = factor * 0.05
    end
    if caster:HasModifier("modifier_activemage") then
        factor = factor * 0.25
    end
    if caster:HasModifier("modifier_activepriest") then
        factor = factor * 0.1
    end
    if caster:HasModifier("modifier_active2") then
        factor = factor * 0.25
    end
    local stacksSwordBoard = caster:GetModifierStackCount("modifier_swordboard", caster)
    if stacksSwordBoard > 0 then
        if stacksSwordBoard > 15 then
            stacksSwordBoard = 15
        end
        factor = factor * (1 - 0.05 * stacksSwordBoard)
    end
    return factor
end

function TideOfDarkness( event )
    local caster = event.caster
    if caster:HasModifier("modifier_dh_aa_heal") or caster:HasModifier("modifier_denial_aura") then
        event.ability:ApplyDataDrivenModifier(caster, caster, event.buff, {Duration = event.dur})
    end
end

function FindClosestHero( caster )
    local all = HeroList:GetAllHeroes()
    local dst = 10000000
    local hero = nil
    for i=1, #all do
        if all[i] and (all[i]:GetAbsOrigin() - caster:GetAbsOrigin()):Length() < dst then
            hero = all[i]
            dst = (all[i]:GetAbsOrigin() - caster:GetAbsOrigin()):Length()
        end
    end
    return hero
end

function GetProjectileFXByTheme( theme )
    if theme == "fire" then
        return "particles/fireball_linear_2.vpcf"
    end
    if theme == "shadow" then
        return "particles/magnataur_shockwave_shadow.vpcf"
    end
    if theme == "chaos" then
        return "particles/units/heroes/hero_vengeful/vengeful_wave_of_terror.vpcf"
    end
    if theme == "poison" then
        return "particles/econ/items/venomancer/veno_ti8_immortal_head/veno_ti8_immortal_gale.vpcf"
    end
    if theme == "poison2" then
        return "particles/venomancer_venomous_gale_viper.vpcf"
    end
    if theme == "earth" then
        return "particles/econ/items/nyx_assassin/nyx_assassin_ti6/nyx_assassin_impale_ti6_gold.vpcf"
    end
    if theme == "holy" then
        return "particles/econ/items/magnataur/shock_of_the_anvil/magnataur_shockanvil.vpcf"
    end
    if theme == "frost" then
        return "particles/econ/items/nyx_assassin/nyx_assassin_ti6/nyx_assassin_impale_ti6.vpcf"
    end
    if theme == "physical" then
        return "particles/units/heroes/hero_nyx_assassin/nyx_assassin_impale.vpcf"
    end
    if theme == "water" then
        return "particles/units/heroes/hero_tidehunter/tidehunter_arm_of_the_deep_projectile.vpcf"
    end
    if theme == "thunder" then
        return "particles/units/heroes/hero_zuus/zuus_thunder_trail_projectile.vpcf"
    end
    if theme == "arrow" then
        return "particles/econ/items/mirana/mirana_persona/mirana_dark_moon_spell_arrow.vpcf"
    end
    if theme == "arrow2" then
        return "particles/units/heroes/hero_hoodwink/hoodwink_sharpshooter_projectile.vpcf"
    end
    if theme == "chaos2" then
        return "particles/units/heroes/hero_dark_willow/dark_willow_bramble_projectile.vpcf"
    end
    if theme == "ice" then
        return "particles/units/heroes/hero_drow/drow_ranger_glacier_projectile.vpcf"
    end
    if theme == "blood" then
        return "particles/econ/items/grimstroke/ti9_immortal/gs_ti9_artistry_proj.vpcf"
    end
    
    
end

function GetFollowProjectileFXByTheme( theme )
    if theme == "fire" then
        return "particles/econ/items/wraith_king/wraith_king_ti6_bracer/wraith_king_ti6_hellfireblast.vpcf"
    end
    if theme == "shadow" then
        return "particles/econ/items/vengeful/vs_ti8_immortal_shoulder/vs_ti8_immortal_magic_missle.vpcf"
    end
    if theme == "chaos" then
        return "particles/chaosbolt.vpcf"
    end 
    if theme == "poison" then
        return "particles/units/heroes/hero_treant/treant_leech_seed_projectile.vpcf"
    end
    if theme == "poison2" then
        return "particles/econ/items/viper/viper_ti7_immortal/viper_poison_crimson_attack_ti7.vpcf"
    end
    if theme == "earth" then
        return "particles/neutral_fx/mud_golem_hurl_boulder.vpcf"
    end
    if theme == "holy" then
        return "particles/units/heroes/hero_skywrath_mage/skywrath_mage_arcane_bolt.vpcf"
    end
    if theme == "frost" then
        return "particles/econ/items/lich/lich_ti8_immortal_arms/lich_ti8_chain_frost.vpcf" --"particles/units/heroes/hero_lich/lich_chain_frost.vpcf"
    end
    if theme == "physical" then
        return "particles/econ/items/queen_of_pain/qop_ti8_immortal/queen_ti8_shadow_strike.vpcf"
    end
    if theme == "hook" then
        return "particles/items_fx/harpoon_projectile.vpcf"
    end
end

function GetDamageFXByTheme( theme )
    if theme == "fire" or theme == "fire2" or theme == "chaosfire" or theme == "death" then
        return "particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze.vpcf"
    end
    if theme == "poison" or theme == "poison2" then
        return "particles/econ/items/venomancer/veno_ti8_immortal_head/veno_ti8_immortal_gale_explosion_venom.vpcf"
    end
    return "particles/units/heroes/hero_bloodseeker/bloodseeker_rupture_nuke.vpcf"
end

function GetAOERadiusByTheme( theme )
    if theme == "fire" then
        return 200
    end
    if theme == "shadow" then
        return 350
    end
    if theme == "chaos" then
        return 200
    end 
    if theme == "poison" or theme == "poison2" then
        return 250
    end
    if theme == "earth" then
        return 225
    end
    if theme == "holy" then
        return 350
    end
    if theme == "frost" then
        return 300
    end
    if theme == "physical" then
        return 175
    end
    return 200
end

function FireAOEFXByTheme( caster, pos, aoe, theme )
    if theme == "fire" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/wraith_king/wraith_king_ti6_bracer/wraith_king_ti6_hellfireblast_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 3, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "fire2" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/gyrocopter/gyro_ti10_immortal_missile/gyro_ti10_immortal_crimson_missile_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "shadow" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5/antimage_manavoid_ti_5.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 3, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "shadow2" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/gyrocopter/gyro_ti10_immortal_missile/gyro_ti10_immortal_missile_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "chaos" then
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_skeletonking/skeletonking_hellfireblast_explosion.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 3, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end 
    if theme == "poison" then
        local particle = ParticleManager:CreateParticle("particles/econ/events/ti8/blink_dagger_ti8_start_lvl2.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "blood" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/queen_of_pain/qop_ti8_immortal/queen_ti8_shadow_strike_body.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 2, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "earth" then
        local particle = ParticleManager:CreateParticle("particles/econ/events/fall_major_2016/cyclone_fm06_rock_a.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "holy" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/antimage/antimage_weapon_basher_ti5_gold/antimage_manavoid_ti_5_gold.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "frost" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/crystal_maiden/crystal_maiden_cowl_of_ice/maiden_crystal_nova_cowlofice.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 1, Vector(aoe,1,aoe))
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "ice" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/lich/lich_ti8_immortal_arms/lich_ti8_chain_frost_explode.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:SetParticleControl(particle, 3, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
    if theme == "physical" then
        local particle = ParticleManager:CreateParticle("particles/econ/items/dark_willow/dark_willow_ti8_immortal_head/dw_crimson_ti8_immortal_cursed_crownmarker_steam.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, pos)
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function FireHealFX( caster, target )
    local particle = ParticleManager:CreateParticle("particles/dazzle_shadow_wave_green.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
    ParticleManager:ReleaseParticleIndex(particle)
    EmitSoundOn("DOTA_Item.HealingSalve.Activate", target)
end

function FireBuffFX( caster, target )
    local particle = ParticleManager:CreateParticle("particles/dazzle_holy_wave_b.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
    ParticleManager:ReleaseParticleIndex(particle)
    EmitSoundOn("DOTA_Item.DustOfAppearance.Activate", target)
end

function GetExplosionSoundByTheme( theme )
    if theme == "fire" then
        --return "Hero_OgreMagi.Fireblast.Cast"
    end
    if theme == "shadow" then
        return "Hero_Magnataur.ShockWave.Cast"
    end
    if theme == "chaos" then
        return "Hero_Magnataur.ShockWave.Cast"
    end 
    if theme == "poison" then
        return "Hero_Magnataur.ShockWave.Cast"
    end
    if theme == "earth" then
        return "Hero_Magnataur.ShockWave.Cast"
    end
    if theme == "holy" then
        return "Hero_Magnataur.ShockWave.Cast"
    end
    if theme == "frost" then
        return "Hero_Crystal.CrystalNova.Yulsaria"
    end
    if theme == "physical" then
        return "Hero_Magnataur.ShockWave.Cast"
    end
    return "Hero_Magnataur.ShockWave.Cast"
end

function ShowDamageFXByTheme( target, theme )
    local fxPath = GetDamageFXByTheme(theme)
    local particle = ParticleManager:CreateParticle(fxPath, PATTACH_POINT_FOLLOW, target)
    ParticleManager:ReleaseParticleIndex(particle)
    EmitSoundOn("Hero_Lina.DragonSlave", target)
end

function ShootLinearProjectile(caster, ability, origin, targetPos, speed, duration, theme, distance)
    local direction = (targetPos - origin):Normalized()
    local info = 
    {
        Ability = ability,
        EffectName = GetProjectileFXByTheme(theme),
        vSpawnOrigin = origin,--caster:GetAbsOrigin(),--origin,
        fDistance = distance,
        fStartRadius = 100,
        fEndRadius = 100,
        Source = caster,
        bHasFrontalCone = false,
        bReplaceExisting = false,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
        iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
        iUnitTargetType = DOTA_UNIT_TARGET_HERO,
        fExpireTime = GameRules:GetGameTime() + duration,
        bDeleteOnHit = false,
        vVelocity = direction * speed,
        bProvidesVision = true,
        iVisionRadius = 1000,
        iVisionTeamNumber = caster:GetTeamNumber()
    }
    local projectile = ProjectileManager:CreateLinearProjectile(info)
end

function ShootCurveProjectile(caster, ability, origin, targetPos, speed, curve, duration, theme, curveFactorOverTime, curveprojectileanglechange)
    local originalCurveAngle = curve
    if not curveFactorOverTime then
        curveFactorOverTime = 1
    end
    if not curveprojectileanglechange then
        curveprojectileanglechange = 0
    end
    local zigZagBehavior = false
    if curveFactorOverTime < 0 then
        zigZagBehavior = true
    end
    for missile=1, duration do
        local missileCount = missile
        Timers:CreateTimer(0.1 + missile, function()
            ShootLinearProjectile(caster, ability, origin, targetPos, speed, 1, theme, speed)
            --new missiles data
            local direction = (targetPos - origin):Normalized()
            origin = origin + direction * speed
            local directionChange = curve
            if zigZagBehavior and missileCount == 1 then
                directionChange = directionChange * 0.5
            end
            targetPos = origin + RotateVectorAroundAngle(direction, directionChange) * speed
            curve = curve * curveFactorOverTime + curveprojectileanglechange
        end)
    end
end

function ShootSplitProjectile(caster, ability, origin, targetPos, speed, duration, theme, remainingSplitCount, splitAngle, splitEveryXIterations, iteration)
    ShootLinearProjectile(caster, ability, origin, targetPos, speed, 1, theme, speed)

    if iteration > duration then
        return
    end

    local direction = (targetPos - origin):Normalized()
    local splitProjectile = remainingSplitCount > 0 and iteration % splitEveryXIterations == 0
    iteration = iteration + 1
    if splitProjectile then
        remainingSplitCount = remainingSplitCount - 1
        for missile=1, 2 do
            local missileCount = missile
            Timers:CreateTimer(1, function()
                local newOrigin = origin + direction * speed
                local angleChange = splitAngle
                if missileCount == 2 then
                    angleChange = -splitAngle
                end
                targetPos = newOrigin + RotateVectorAroundAngle(direction, angleChange) * speed
                ShootSplitProjectile(caster, ability, newOrigin, targetPos, speed, duration, theme, remainingSplitCount, splitAngle, splitEveryXIterations, iteration)
            end)
        end
    else
        Timers:CreateTimer(1, function()
            local newOrigin = origin + direction * speed
            targetPos = newOrigin + direction * speed
            ShootSplitProjectile(caster, ability, newOrigin, targetPos, speed, duration, theme, remainingSplitCount, splitAngle, splitEveryXIterations, iteration)
        end)
    end

end

function ShootFollowProjectile(caster, ability, target, speed, theme)
    local info = {
        Target = target,
        Source = caster,
        Ability = ability,
        EffectName = GetFollowProjectileFXByTheme(theme), --"particles/units/heroes/hero_winter_wyvern/wyvern_splinter.vpcf",
        bDodgeable = true,
        bProvidesVision = true,
        iMoveSpeed = speed,
        iVisionRadius = 300,
        iVisionTeamNumber = caster:GetTeamNumber(),
        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_HITLOCATION
    }
    ProjectileManager:CreateTrackingProjectile( info )
end

function ShootChainFollowProjectile(caster, ability, target, theme)
    --find nearby heroes
    local targets = FindNearbyHeroes(target:GetAbsOrigin(), 300, target)
    if targets and #targets > 0 then
        local newTarget = targets[math.random(1,#targets)]
        ShootFollowProjectile(target, ability, newTarget, 750, theme)
    end
end

function SpawnGroundAOE( caster, ability, startPosition, speed, curve, duration, tick_frequency, theme )
    if tick_frequency == 0 then
        tick_frequency = 1
    end
    local currentPosition = startPosition
    local velocity = RandomVector(speed):Normalized() * speed
    local lifetimeinticks = duration * tick_frequency
    local tickdelay = 1 / tick_frequency
    local sound = GetExplosionSoundByTheme(theme)
    local aoe = GetAOERadiusByTheme(theme)
    for i=1, lifetimeinticks do
        Timers:CreateTimer(0.1 + tickdelay*(i-1), function()
            if caster and not caster:IsNull() and caster:IsAlive() then
                FireAOEFXByTheme(caster, currentPosition, aoe, theme)
                EmitSoundOn(sound, caster)
                local targets = FindNearbyHeroes( currentPosition, aoe, nil )
                if targets and #targets > 0 then
                    for k=1, #targets do
                        GeneratedSpellOnHitEvent(caster, targets[k], ability, ability.spelldata)
                    end
                end
                velocity = RotateVectorAroundAngle(velocity, curve)
                currentPosition = currentPosition + velocity
            end
        end)
    end
end

function FindNearbyHeroes( center, radius, exclude )
    local all = HeroList:GetAllHeroes()
    local hero
    local heroes = {}
    for i=1, #all do
        hero = all[i]
        if (hero:GetAbsOrigin() - center):Length() <= radius and (not exclude or hero ~= exclude) then
            table.insert(heroes, hero)
        end
    end
    return heroes
end

function GetRandomElementFromTable( hTable )
    return hTable[math.random(1,#hTable)]
end

function GenerateRandomSpell()
    local spell = {}
    spell.BossSpellCastType = GetRandomElementFromTable(COverthrowGameMode.BossSpellCastType)
    DeepPrintTable(spell)
end

function CastGeneratedSpell( event )
    local caster = event.caster
    local ability = event.ability
    --calculate spell damage (should be based on )
    --save this spell's data in the ability itself, to grab values later
    ability.spelldata = event
    local spelldata = event
    local particle
    local delay = 0.1
    if event.delay then
        delay = event.delay
    end
    if event.delayfx then
        if event.harmful then
            particle = ParticleManager:CreateParticle("particles/ring_fire_spike.vpcf", PATTACH_POINT_FOLLOW, caster)
        else
            particle = ParticleManager:CreateParticle("particles/ring_green.vpcf", PATTACH_POINT_FOLLOW, caster)
        end
        delay = event.delay
    end
    --set random summon types
    if not event.summonname and event.summononcast then
        spelldata.summonname = GetRandomMonsterNameByAct(event.summonacttheme)
    end
    if event.rootwhilecasting then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_rooted", {Duration = event.triggercount * event.triggercountdelay + delay + 0.5})
    end
    if event.stunselfwhencast then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_stun_self", {Duration = event.stunselfwhencast})
    end
    Timers:CreateTimer(delay, function()
        if particle then
            ParticleManager:DestroyParticle(particle,false)
            ParticleManager:ReleaseParticleIndex(particle)
        end
        if caster and not caster:IsNull() and caster:IsAlive() then
            for i=1, event.triggercount do
                Timers:CreateTimer(0.1 + event.triggercountdelay * (i - 1), function()
                    --find targets
                    local targets = {}
                    if event.allenemies or event.allenemiesclose or event.allenemiesfar then
                        targets = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, 2500, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, 0, 0, false )
                        if event.allenemiesclose then
                            local newTargets = {}
                            for j=1, #targets do
                                if targets[j] and (targets[j]:GetAbsOrigin() - caster:GetAbsOrigin()):Length() <= event.allenemiesclose then
                                    table.insert(newTargets, targets[j])
                                end
                            end
                            targets = newTargets
                        end
                        if event.allenemiesfar then
                            local newTargets = {}
                            for j=1, #targets do
                                if targets[j] and (targets[j]:GetAbsOrigin() - caster:GetAbsOrigin()):Length() >= event.allenemiesfar then
                                    table.insert(newTargets, targets[j])
                                end
                            end
                            targets = newTargets
                        end
                    end
                    if event.random3 then
                        targets = PVERandomXTargets({caster = caster, numbertargets = 3, stillbuffifless = 1})
                    end
                    if event.closest then
                        targets = {FindClosestHero(caster)}
                    end
                    if event.furthest then
                        targets = {PVEFurthestTarget({caster = caster})}
                    end
                    if event.highestaggro then
                        targets = {COverthrowGameMode:AggroHighest(caster)}
                    end
                    if event.lowestaggro then
                        targets = {COverthrowGameMode:AggroLowest(caster)}
                    end
                    --find supportive target 
                    if event.self then
                        table.insert(targets, caster)
                    end
                    if event.allallies then
                        local allies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetAbsOrigin(), caster, 900, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BASIC, 0, 0, false )
                        if #allies > 0 then
                            for _,ally in pairs(allies) do
                                if ally ~= nil then
                                    table.insert(targets, ally)
                                end
                            end
                        end
                    end
                    --fire spatial effects, if targets exist
                    if targets and #targets > 0 and targets[1] ~= nil then
                        for k=1, #targets do
                            if event.linearprojectiletargeted then
                                ShootLinearProjectile(caster, ability, caster:GetAbsOrigin(), targets[k]:GetAbsOrigin(), 500, 60, spelldata.SpellThemes, 3000)
                            end
                            if event.curveprojectiletargeted then
                                ShootCurveProjectile(caster, ability, caster:GetAbsOrigin(), targets[k]:GetAbsOrigin(), 500, event.curveprojectiletargeted, 15, spelldata.SpellThemes, event.curveprojectilecurvefactor, event.curveprojectileanglechange)
                            end
                            if event.linearprojectiletargetedsplit then
                                ShootSplitProjectile(caster, ability, caster:GetAbsOrigin(), targets[k]:GetAbsOrigin(), 500, 10, spelldata.SpellThemes, event.linearprojectilesplitcount, event.linearprojectilesplitangle, event.linearprojectiletargetedsplit, 0)
                            end
                            if event.followprojectile then
                                ShootFollowProjectile(caster, ability, targets[k], 750, spelldata.SpellThemes)
                            end
                            if event.groundaoe then
                                SpawnGroundAOE( caster, ability, targets[k]:GetAbsOrigin(), event.groundaoespeed, event.groundaoecurve, event.groundaoeduration, event.groundaoetickfrequency, spelldata.SpellThemes )
                            end
                            if event.summononcast then
                                GeneratedSpellSpawnSummon( caster, targets[k], ability, spelldata, spelldata.summonduration, spelldata.summonacttheme, spelldata.summonname, spelldata.summondamage, spelldata.summonhp, 2 )
                            end
                            if event.healpercent then
                                HealUnit({caster = caster, target = targets[k], ability = ability, heal = 0, percenthp = event.healpercent })
                                FireHealFX(caster, targets[k])
                            end
                            if event.attackdamagebuff then
                                ability:ApplyDataDrivenModifier(caster, targets[k], "modifier_attackdamagebuff", {Duration = event.attackdamagebuffdur})
                                FireBuffFX(caster, targets[k])
                            end
                            if event.attackspeedbuff then
                                ability:ApplyDataDrivenModifier(caster, targets[k], "modifier_attackspeedbuff", {Duration = event.attackspeedbuffdur})
                                FireBuffFX(caster, targets[k])
                            end
                            if event.movementbuff then
                                ability:ApplyDataDrivenModifier(caster, targets[k], "modifier_movementbuff", {Duration = event.movementbuffdur})
                                FireBuffFX(caster, targets[k])
                            end
                            if event.aggrochangetolowestbuffdur then
                                ability:ApplyDataDrivenModifier(caster, targets[k], "modifier_lowest_aggro_hunt", {Duration = event.aggrochangetolowestbuffdur})
                                FireBuffFX(caster, targets[k])
                            end
                            if event.reflectbuffdur then
                                PurgeUnit({target = targets[k], nopenalty = 1})
                                ability:ApplyDataDrivenModifier(caster, targets[k], "modifier_shieldreflect", {Duration = event.reflectbuffdur})
                                FireBuffFX(caster, targets[k])
                            end
                            if event.purge then
                                PurgeUnit({target = targets[k], nopenalty = 1})
                            end
                        end
                    end
                    if event.linearprojectilefan then
                        for k=1, event.linearprojectilefan do
                            local fanIndex = k - (event.linearprojectilefan + 1) / 2
                            local fanAngle = 30
                            ShootLinearProjectile(caster, ability, caster:GetAbsOrigin(), caster:GetAbsOrigin() + RotateVectorAroundAngle(caster:GetForwardVector(), fanAngle * fanIndex), 500, 60, spelldata.SpellThemes, 3000)
                        end
                    end
                    if event.linearprojectilerandom then
                        ShootLinearProjectile(caster, ability, caster:GetAbsOrigin(), caster:GetAbsOrigin() + RandomVector(300), 500, 15, spelldata.SpellThemes, speed)
                    end
                    if event.linearprojectilerandomsplit then
                        ShootSplitProjectile(caster, ability, caster:GetAbsOrigin(), caster:GetAbsOrigin() + RandomVector(300), 500, 10, spelldata.SpellThemes, event.linearprojectilesplitcount, event.linearprojectilesplitangle, event.linearprojectilerandomsplit, 0)
                    end
                    if event.curveprojectilefan then
                        local curveprojectilefancount = event.curveprojectilefancount
                        if not curveprojectilefancount then
                            curveprojectilefancount = 5
                        end
                        for k=1, curveprojectilefancount do
                            local fanIndex = k - (curveprojectilefancount + 1) / 2
                            local fanAngle = 30
                            local curveAngle = event.curveprojectilefan
                            ShootCurveProjectile(caster, ability, caster:GetAbsOrigin(), caster:GetAbsOrigin() + RotateVectorAroundAngle(caster:GetForwardVector(), fanAngle * fanIndex), 500, curveAngle, 5, spelldata.SpellThemes, event.curveprojectilecurvefactor, event.curveprojectileanglechange)
                        end
                    end
                    if event.curveprojectilerandom then
                        ShootCurveProjectile(caster, ability, caster:GetAbsOrigin(), caster:GetAbsOrigin() + RandomVector(300), 500, event.curveprojectilerandom, 15, spelldata.SpellThemes, event.curveprojectilecurvefactor, event.curveprojectileanglechange)
                    end
                    if event.groundaoerandom then
                        for k=1, event.groundaoerandom do
                            SpawnGroundAOE( caster, ability, caster:GetAbsOrigin() + RandomVector(1) * math.random(100, 1050), event.groundaoespeed, event.groundaoecurve, event.groundaoeduration, event.groundaoetickfrequency, spelldata.SpellThemes )
                        end 
                    end
                end)
            end
        end
    end)
end

function GeneratedSpellOnProjectileHit( event )
    if event.ability and event.ability.spelldata then
        GeneratedSpellOnHitEvent(event.caster, event.target, event.ability, event.ability.spelldata)
    end
end

function GeneratedSpellOnHitEvent(caster, target, ability, spelldata)
    if spelldata.damage then
        ShowDamageFXByTheme(target, spelldata.SpellThemes)
        if spelldata.hppercentpure then
            DamageUnit({caster = caster, target = target, ability = ability, damage = 0, currenthp = spelldata.hppercentpure, puredmg = true})
        else
            DamageUnit({caster = caster, target = target, ability = ability, damage = 0, difficultyscalelinear = spelldata.damage})
        end
    end
    if spelldata.healonhit then
        HealUnit({caster = caster, target = caster, ability = ability, heal = 0, percenthp = spelldata.healonhit})
    end
    if spelldata.slow then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_slow50", dur = spelldata.slow})
    end
    if spelldata.dotduration then
        ApplyBuffStack({caster = caster, target = target, ability = ability, buff = "modifier_dot_gen", dur = spelldata.dotduration})
    end
    if spelldata.minusmagicaldur then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_polybonusdamage_enemy", dur = spelldata.minusmagicaldur})
    end
    if spelldata.minusarmordur then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_armor_crush", dur = spelldata.minusarmordur})
    end
    if spelldata.healdebuff then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_heal_curse", dur = spelldata.healdebuff})
    end
    if spelldata.stun then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_stunned", dur = spelldata.stun})
    end
    if spelldata.silence then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_silence", dur = spelldata.silence})
    end
    if spelldata.disarm then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_disarmed", dur = spelldata.disarm})
    end
    if spelldata.root then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_rooted", dur = spelldata.root})
    end
    if spelldata.summononhit and spelldata.summonname then
        GeneratedSpellSpawnSummon( caster, target, ability, spelldata, spelldata.summonduration, spelldata.summonacttheme, spelldata.summonname, spelldata.summondamage, spelldata.summonhp, 2 )
    end
    if spelldata.followprojectile and spelldata.followprojectilebouncing then
        ShootChainFollowProjectile(caster, ability, target, theme)
    end
    if spelldata.pulltargetsin then
        ApplyBuff({caster = caster, target = target, ability = ability, buff = "modifier_phased", dur = 0.5})
        local position = caster:GetAbsOrigin() + (target:GetAbsOrigin() - caster:GetAbsOrigin()):Normalized() * 100
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_magnataur/magnataur_reverse_polarity_pull.vpcf", PATTACH_WORLDORIGIN, target)
        ParticleManager:SetParticleControl(particle, 0, position)
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
        target:SetAbsOrigin(position)
    end
end

function GeneratedSpellSpawnSummon( caster, target, ability, spelldata, duration, act, unitname, summondamage, summonhp, stunduration )
    local name = GetRandomMonsterNameByAct(act)
    if unitname then
        name = unitname
    end
    if not name then
        GetRandomMonsterNameByAct(2)
    end
    local unit = CreateUnitByName(name, target:GetAbsOrigin() + RandomVector(150), true, nil, nil, DOTA_TEAM_BADGUYS )
    if stunduration and stunduration > 0 then
        ability:ApplyDataDrivenModifier(caster, unit, "modifier_stunned", {Duration = stunduration})
    end
    ability:ApplyDataDrivenModifier(caster, unit, "modifier_phased", {Duration = 0.1})
    COverthrowGameMode:SetSummonPVEStats({caster = caster, target = unit, dmg = summondamage, hp = summonhp, noexp = 1})
    if spelldata and spelldata.summonaggrorandominitial then
        if spelldata.summonaggrolowest then
            unit:AddAbility("pve_temple_spottheweak"):SetLevel(1)
        elseif spelldata.summonaggrorandominitialranged then
            PVEAggroAddRandomHero({target = unit, amount = 999999999, aggro_prefer_ranged = 1})
        else
            PVEAggroAddRandomHero({target = unit, amount = 999999999})
        end
    end
    local particle = ParticleManager:CreateParticle("particles/items_fx/necronomicon_spawn_warrior.vpcf", PATTACH_POINT_FOLLOW, target)
    ParticleManager:ReleaseParticleIndex(particle)
    EmitSoundOn("Hero_Tidehunter.Taunt.BackStroke", target)
    if duration and duration > 0 then
        Timers:CreateTimer(duration, function()
            if unit and not unit:IsNull() and unit:IsAlive() then
                UTIL_Remove(unit)
            end
        end)
    end
end

function GeneratedSpellDoTDamage( event )
    local ability = event.ability
    if ability.spelldata then
        if ability.spelldata.dotdamage then
            event.difficultyscalelinear = ability.spelldata.dotdamage
            event.buffstackbasedbuff = "modifier_dot_gen"
            DamageUnit(event)
        end
    end
end

COverthrowGameMode.SpellCastType = { --set by the ability itself, as well as cooldown
    "instant", --
    "casttime",
    "channeling",
    "onattackchance",
    "ontakedamagechance",
    "passive",
    "passiveperiodic",
    "onnotattack"
}

COverthrowGameMode.SpellBaseType = {
    "harmful",--
    "supportive"
}

COverthrowGameMode.SpellHarmfulTargets = {
    "allenemies",
    "allenemiesclose",
    "allenemiesfar",
    "random3",
    "closest",
    "furthest",
    "highestaggro",
    "lowestaggro"
}

COverthrowGameMode.SpellSupportiveTargets = {
    "allallies",
    "self"
}

COverthrowGameMode.SpellSpatialTypes = {
    "linearprojectiletargeted", --origin, target, speed
    "linearprojectilerandom",
    "curveprojectiletargeted", --origin, target, count, speed, rotation, rotationchange
    "curveprojectilerandom",
    "followprojectile",
    "followprojectilebouncing",
    "groundaoe", --position, speed, curve, size
    "groundaoerandom",
    "summon"
}

COverthrowGameMode.SpellOnHitEnemyEvents = {
    "damage",
    "dot", --dispelable?
    "slow", -- dot/root/slow/stun/disarm/silence
    "stun",
    "root",
    "silence",
    "disarm",
    "minusmagicaldur",
    "minusarmordur",
    "summon" --killable?, ability?, movement / stationary, spawnpoint
}

COverthrowGameMode.SpellOnHitAllyEvents = {
    "heal",
    "attackdamagebuff", --aa, as, ms, reflect, reduction, aggrochange
    "attackspeedbuff",
    "movementbuff",
    "reflectbuff",
    "reductionbuff",
    "aggrochangetolowestbuff",
    "purge",
    "summon"
}

COverthrowGameMode.SummonAggroBehavior = {
    "summonaggronormal",
    "summonaggrolowest",
    "summonaggrorandominitial",
    "summonaggrorandominitialranged"
}

COverthrowGameMode.SpellDamageTypes = { --set by ability?
    "magical",
    "physical",
    "pure",
    "hppercentpure"
}

COverthrowGameMode.SpellThemes = {
    "fire",
    "poison",
    "frost",
    "shadow",
    "earth",
    "holy",
    "physical",
    "chaos"
}

function CyclingAggro( event )
    local caster = event.caster
    if caster:GetHealth() / caster:GetMaxHealth() >= 1 then
        return
    end
    local allHeroes = HeroList:GetAllHeroes()
    local heroCount = #allHeroes
    if heroCount <= 0 then
        return
    end
    if not caster.cycling_aggro then
        caster.cycling_aggro = math.random(1, heroCount)
    end
    caster.cycling_aggro = caster.cycling_aggro + 1
    if caster.cycling_aggro > heroCount then
        caster.cycling_aggro = 1
    end
    local target = allHeroes[caster.cycling_aggro]
    if (target:GetAbsOrigin() - caster:GetAbsOrigin()):Length() < 2500 then
        caster.cycling_aggro_target = target
    end
end

function GlobalOnConsumeSoul( caster )
    local ability = caster:FindAbilityByName("demo1")
    if ability and ability:GetLevel() >= 4 then
        HealUnit({caster = caster, target = caster, ability = ability, heal = 0, percenthp = 3 })
        FireHealFX(caster, caster)
        RestoreMana({caster = caster, percent = 1, amount = 3})
    end
end

function GetDemonCount( caster )
    local demons = 0
    if caster.voidhunter and not caster.voidhunter:IsNull() and caster.voidhunter:IsAlive() then
        demons = demons + 1
    end
    if caster.shadowimp and not caster.shadowimp:IsNull() and caster.shadowimp:IsAlive() then
        demons = demons + 1
    end
    if caster.hellguard and not caster.hellguard:IsNull() and caster.hellguard:IsAlive() then
        demons = demons + 1
    end
    return demons
end

function HealDemons( event )
    local caster = event.caster
    if caster.voidhunter and not caster.voidhunter:IsNull() and caster.voidhunter:IsAlive() then
        local pet = caster.voidhunter
        pet:SetHealth(pet:GetHealth() + pet:GetMaxHealth() * event.amount / 100)
        FireHealFX(caster, pet)
    end
    if caster.shadowimp and not caster.shadowimp:IsNull() and caster.shadowimp:IsAlive() then
        local pet = caster.shadowimp
        pet:SetHealth(pet:GetHealth() + pet:GetMaxHealth() * event.amount / 100)
        FireHealFX(caster, pet)
    end
    if caster.hellguard and not caster.hellguard:IsNull() and caster.hellguard:IsAlive() then
        local pet = caster.hellguard
        pet:SetHealth(pet:GetHealth() + pet:GetMaxHealth() * event.amount / 100)
        FireHealFX(caster, pet)
    end
end

function ConsumeSouls( event )
    local caster = event.caster
    local removeBuff = false
    if caster.souls then
        if caster.souls >= event.amount then
            caster.souls = caster.souls - event.amount
            caster:SetModifierStackCount("modifier_souls", nil, caster.souls)
            if caster.souls <= 0 then
                caster:RemoveModifierByName("modifier_souls")
            end
            GlobalOnConsumeSoul(caster)
        else
            removeBuff = true
        end
    else
        removeBuff = true
    end
    if removeBuff then
        caster:RemoveModifierByName(event.buff)
    end
end

function Hellguard (event)
    local caster = event.caster
    if caster.hellguard and not caster.hellguard:IsNull() and caster.hellguard:IsAlive() then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_soullink", {Duration = event.link})
        event.ability:ApplyDataDrivenModifier(caster, caster.hellguard, "modifier_soullink", {Duration = event.link})
        if event.taunt > 0 then
            event.ability:ApplyDataDrivenModifier(caster, caster.hellguard, "modifier_taunt123", {Duration = event.taunt})
        end
        return
    end
    if caster.hellguard and not caster.hellguard:IsNull() then
        --make sure its really dead
        caster.hellguard:Kill(caster.combat_system_ability, caster)
    end
    local owner = caster:GetOwner()
    local teamid = caster:GetTeamNumber()
    local origin = caster:GetAbsOrigin() + RandomVector(100)
    caster.hellguard = CreateUnitByName("npc_dota_creature_hellguard", origin, true, owner, nil, teamid)
    caster.hellguard:SetControllableByPlayer(-1, true) --(caster:GetPlayerID(), true)
    caster.hellguard:CreatureLevelUp(event.ability:GetLevel()-1)
    caster.hellguard.owner = caster
    local table = {}
    table.Duration = 0.5
    event.ability:ApplyDataDrivenModifier(event.caster, caster.hellguard, "modifier_phased", table)
    event.ability:ApplyDataDrivenModifier(caster, caster.hellguard, "modifier_pet_system", nil)
    event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_soullink", {Duration = event.link})
    event.ability:ApplyDataDrivenModifier(caster, caster.hellguard, "modifier_soullink", {Duration = event.link})
    if event.taunt > 0 then
        event.ability:ApplyDataDrivenModifier(caster, caster.hellguard, "modifier_taunt123", {Duration = event.taunt})
    end
end

function Shadowimp (event)
    local caster = event.caster
    if caster.shadowimp and not caster.shadowimp:IsNull() and caster.shadowimp:IsAlive() then
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_shadow_rage", {Duration = event.haste})
        event.ability:ApplyDataDrivenModifier(caster, caster.shadowimp, "modifier_shadow_rage", {Duration = event.haste})
        return
    end

    if caster.shadowimp and not caster.shadowimp:IsNull() then
        --make sure its really dead
        caster.shadowimp:Kill(caster.combat_system_ability, caster)
    end
    local owner = caster:GetOwner()
    local teamid = caster:GetTeamNumber()
    local origin = caster:GetAbsOrigin() + RandomVector(100)
    caster.shadowimp = CreateUnitByName("npc_dota_creature_shadowimp", origin, true, owner, nil, teamid)
    caster.shadowimp:SetControllableByPlayer(-1, true) --(caster:GetPlayerID(), true)
    caster.shadowimp:CreatureLevelUp(event.ability:GetLevel()-1)
    caster.shadowimp.owner = caster
    local table = {}
    table.Duration = 0.5
    event.ability:ApplyDataDrivenModifier(event.caster, caster.shadowimp, "modifier_phased", table)
    event.ability:ApplyDataDrivenModifier(caster, caster.shadowimp, "modifier_pet_system", nil)
    event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_shadow_imp", {Duration = -1})
    event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_shadow_rage", {Duration = event.haste})
    event.ability:ApplyDataDrivenModifier(caster, caster.shadowimp, "modifier_shadow_rage", {Duration = event.haste})
end

function ShadowImpDamage( event )
    local caster = event.caster
    local attacker = event.attacker
    local lifeCost = 0.05
    local hellguardHP = attacker:GetHealth()
    local hellguardMaxHP = attacker:GetMaxHealth()
    if hellguardMaxHP > 0 then
        if hellguardHP / hellguardMaxHP > lifeCost then
            attacker:SetHealth(attacker:GetHealth() - attacker:GetMaxHealth() * lifeCost)
        else
            local particle = ParticleManager:CreateParticle("particles/econ/items/doom/doom_ti8_immortal_arms/doom_ti8_immortal_devour_smoke_b.vpcf", PATTACH_WORLDORIGIN, caster)
            ParticleManager:SetParticleControl(particle, 0, attacker:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
            attacker:Kill(caster.combat_system_ability, caster)
            caster.shadowimp = nil
        end
    end
end

function Demo6End(event)
    local caster = event.caster
    -- to human
    --model change
    if COverthrowGameMode.EnableShapeshift == 1 then
        --local model = "models/heroes/antimage/antimage.vmdl"
        caster:SetOriginalModel(caster.old_model)
        caster:SetModelScale(0.66)
        ShowWearables(event)
        StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_nevermore/nevermore_wings_dust_hit.vpcf", PATTACH_ABSORIGIN, caster)
        ParticleManager:ReleaseParticleIndex(particle)
        COverthrowGameMode:EquipArtifactCosmeticRewardsGlobal(caster)
        caster.has_shapeshift_effect = nil
    end
end

function Demo6(event)
    local caster = event.caster
    --to meta
    --model change, only when synced
    if COverthrowGameMode.EnableShapeshift == 1 and not caster.has_shapeshift_effect then
        COverthrowGameMode:RemoveAllCosmeticsGlobal(caster)
        local model = "models/items/warlock/golem/hellsworn_golem/hellsworn_golem.vmdl"
        local scale = 0.85
        caster.old_model = caster:GetModelName()
        caster:SetOriginalModel(model)
        caster:SetModelScale(scale)
        HideWearables(event)
        StartAnimation(caster, {activity=ACT_DOTA_RUN, duration=0.1, rate=1.0})
        caster.has_shapeshift_effect = true
    end
end

function Demo2( event )
    local caster = event.caster
    if caster.voidhunter and not caster.voidhunter:IsNull() and caster.voidhunter:IsAlive() then
        caster.voidhunter_crit = event.crit
    end
    if caster.shadowimp and not caster.shadowimp:IsNull() and caster.shadowimp:IsAlive() then
        caster.shadowimp_crit = event.crit
    end
    if caster.hellguard and not caster.hellguard:IsNull() and caster.hellguard:IsAlive() then
        caster.hellguard_crit = event.crit
    end
end

function FireBloodRopeFX( from, to )
    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, from)
    ParticleManager:SetParticleControl(particle, 4, to:GetAbsOrigin()+Vector(0,0,75))
    ParticleManager:SetParticleControl(particle, 5, from:GetAbsOrigin()+Vector(0,0,75))
    ParticleManager:ReleaseParticleIndex(particle)
end

function GenerateSouls( event )
    local caster = event.caster
    local maxSouls = 3
    local abil = caster:FindAbilityByName("destro1")
    if not abil then
        abil = caster:FindAbilityByName("demo1")
    end
    if event.maxsouls then
        maxSouls = event.maxsouls
    else
        if abil and abil:GetLevel() >= 4 then
            maxSouls = 4
        end
    end
    if event.souls and event.souls >= 1 then
        if caster.souls then
            caster.souls = caster.souls + event.souls
            if caster.souls > maxSouls then
                caster.souls = maxSouls
            end
        else
            caster.souls = event.souls
        end
        abil:ApplyDataDrivenModifier(caster, caster, "modifier_souls", nil)
        caster:SetModifierStackCount("modifier_souls", abil, caster.souls)
    end
end

function GetHealingMultiplier(event, caster, ability, target, process_procs, isaoe, wascrit)
    local healing_bonus = 1
    if caster.talents then
        if caster:HasModifier("modifier_taunt123") and GetLevelOfAbility(caster, "mars6") >= 4 then
            healing_bonus = healing_bonus + 1
        end
        if event.isdot and caster.talents[49] and caster.talents[49] > 0 then
            healing_bonus = healing_bonus + 0.25 * caster.talents[49]
        end
        if caster.talents[111] and caster.talents[111] > 0 and isaoe then
            local healPerStack = 0.05
            if caster:HasModifier("modifier_pathbuff_111") and caster:HasModifier("modifier_path_overwhelm") then
                healPerStack = healPerStack * 1.5
            end
            healing_bonus = healing_bonus + healPerStack * caster.talents[111]
        end
        if caster.talents[111] and caster.talents[111] > 0 then
            local healPerStack = 0.02
            if caster:HasModifier("modifier_pathbuff_111") and caster:HasModifier("modifier_path_overwhelm") then
                healPerStack = healPerStack * 1.5
            end
            local talent111_buff = caster:GetModifierStackCount("modifier_overgrowth", nil)
            healing_bonus = healing_bonus + healPerStack * talent111_buff
        end
        if caster.talents[7] and caster.talents[7] > 0 then
            local talent7_buff = caster:GetModifierStackCount("modifier_talent_maul", nil)
            healing_bonus = healing_bonus + 0.005 * talent7_buff
        end
        if caster.talents[16] and caster.talents[16] > 0 then
            healing_bonus = healing_bonus + 0.05 * caster.talents[16]
        end
        if caster.talents[67] and caster.talents[67] > 0 and isaoe then
            healing_bonus = healing_bonus + 0.07 * caster.talents[67]
        end
        if caster.talents[39] and caster.talents[39] > 0 and ability and ability:GetAbilityIndex() == 0 then
            healing_bonus = healing_bonus + 0.1 * caster.talents[39]
        end
        if caster.talents[99] and caster.talents[99] > 0 and process_procs then
            local cost = 0.05
            if caster:HasModifier("modifier_path_from_shadows") then
                cost = cost * 0.5
            end
            if not caster.resourcesystem then --mana
                if caster:GetMana() / caster:GetMaxMana() > 0.5 then
                    healing_bonus = healing_bonus + 0.25 * caster.talents[99]
                    caster:SetMana(caster:GetMana() - caster:GetMaxMana() * cost)
                end
            else --energy
                local maxEnergy = GetMaxEnergy({caster = caster})
                if caster:GetMana() / maxEnergy > 0.5 then
                    healing_bonus = healing_bonus + 0.25 * caster.talents[99]
                    EnergyCost({caster = caster, cost = maxEnergy * cost, pay = true})
                end
            end
        end
        if was_crit and caster.talents[17] and caster.talents[17] > 0 then
            healing_bonus = healing_bonus + 0.05 + 0.05 * caster.talents[17]
        end
        if event.bloodwolf and caster.talents[32] then
            healing_bonus = healing_bonus + 0.15 * caster.talents[32]
        end
        if caster.standsstill and caster.talents[20] and caster.talents[20] > 0 then
            local standsstill = caster.standsstill
            if standsstill > 5 then
                standsstill = 5
            end
            healing_bonus = healing_bonus + 0.05 * caster.talents[20] * standsstill
        end
        if caster.talents[66] and caster.talents[66] > 0 and ability == caster:GetAbilityByIndex(1) then
            healing_bonus = healing_bonus + 0.15 * caster.talents[66]
            if math.random(1,100) <= 25 and caster.combat_system_ability and process_procs then
                AutoAttackCriticalStrike({attacker = caster, target = target, ability = caster.combat_system_ability, aacrit_factor = 300 + 100 * caster.talents[66], aacrit_chance = 100})
            end
        end
        if caster.talents[68] and caster.talents[68] > 0 and ability then
            if caster.path_dark_ritual and caster.path_dark_ritual > 0 then
                healing_bonus = healing_bonus + 0.05 * caster.talents[68]
            end
            if ability:GetAbilityIndex() == 5 then
                healing_bonus = healing_bonus + 0.1 * caster.talents[68]
            end
        end
        if caster.talents[107] and caster.talents[107] > 0 and caster:HasModifier("modifier_lonedruid") then
            healing_bonus = healing_bonus + 0.07 * caster.talents[107]
        end
        if caster.talents[86] and caster.talents[86] > 0 and target then
            local point_of_damaging_unit = caster:GetAbsOrigin()
            local distance = (point_of_damaging_unit - target:GetAbsOrigin()):Length()
            if distance > 600 then
                local max_distance_cap = 1200
                if caster:HasModifier("modifier_pathbuff_052") then
                    max_distance_cap = 1350
                end
                if distance > max_distance_cap then
                    distance = max_distance_cap
                end
                distance = (distance - 600) / 100
                healing_bonus = healing_bonus + 0.05 * caster.talents[86] * distance
            end
        end
    end
    local wog = caster:GetModifierStackCount("modifier_wog", nil)
    if wog >= 1 then
         healing_bonus = healing_bonus + 0.01 * wog
    end
    if GetNaturesHarmonyStat(caster) >= 1 and not wascrit then
        healing_bonus = healing_bonus + 0.01 * GetNaturesHarmonyStat(caster)
    end
    if GetNetherfusionStat(caster) >= 1 and ability and ability:GetManaCost(ability:GetLevel()) >= 30 then
        healing_bonus = healing_bonus + 0.01 * GetNetherfusionStat(caster)
    end
    if GetSwiftMendingStat(caster) >= 1 then
        local bonusAS = caster:GetIncreasedAttackSpeed(false) - 1
        if bonusAS > 0 then
            healing_bonus = healing_bonus + 0.01 * GetSwiftMendingStat(caster) * bonusAS
        end
    end
    --multi healing
    if event.bloodwolf and caster:HasModifier("modifier_item_shadowstrike") then
        healing_bonus = healing_bonus + 0.5
    end
    if caster:HasModifier("modifier_activepaladin") then
        healing_bonus = healing_bonus + 0.1
    end
    if caster:HasModifier("modifier_activepaladin_2") then
        healing_bonus = healing_bonus + 0.15
    end
    if caster:HasModifier("modifier_item_int_set_t3_active") then
        healing_bonus = healing_bonus + 0.3
    end
    if caster:HasModifier("modifier_101_heal") then
        healing_bonus = healing_bonus + 0.1
    end
    
    if caster.channel_item_bonus then
        if caster:HasModifier("modifier_item_channel_2") then
            healing_bonus = healing_bonus + 0.75
        else
            healing_bonus = healing_bonus + 0.4
        end
    end
    if caster.ability_combo_6_bonus then
        healing_bonus = healing_bonus + 2
    end
    if caster:HasModifier("modifier_element_chaos") and isaoe then
        healing_bonus = healing_bonus + 0.3
    end
    if caster:HasModifier("modifier_resaura") then
        healing_bonus = healing_bonus + 0.05
    end
    if caster:HasModifier("modifier_resaura2") then
        healing_bonus = healing_bonus + 0.1
    end
    if caster:HasModifier("modifier_item_winterbreeze4") and isaoe then
        healing_bonus = healing_bonus + 0.25
    end
    local kingcharge = caster:GetModifierStackCount("modifier_elemental_kings", caster)*0.03
    if kingcharge > 0 then
        healing_bonus = healing_bonus + kingcharge
    end
    local heavencharge = caster:GetModifierStackCount("modifier_heaven_charge", caster)
    if event.heavencharge and heavencharge > 0 and process_procs then
        healing_bonus = healing_bonus + heavencharge
        caster:RemoveModifierByName("modifier_heaven_charge")
    end
    if caster:HasModifier("modifier_shapeshifttravel") and caster:GetAbilityByIndex(5):GetLevel() >= 4 then
        healing_bonus = healing_bonus + 0.75
    end
    if caster:HasModifier("modifier_special_bonus_lifesteal") then
        healing_bonus = healing_bonus + 0.1
    end
    if caster:HasModifier("modifier_invul") then
        healing_bonus = healing_bonus + 0.25
    end
    if target then
        if target:HasModifier("modifier_special_bonus_lifesteal") then
            healing_bonus = healing_bonus + 0.1
        end
        if target:HasModifier("modifier_deathwish") then
            healing_bonus = healing_bonus + 0.25
        end
        if target:HasModifier("modifier_holyaaa") then
            healing_bonus = healing_bonus + 0.25
        end
        if target:HasModifier("modifier_holyaaa2") then
            healing_bonus = healing_bonus + 0.5
        end
        if target:HasModifier("modifier_item_lifesteal_10") then
            healing_bonus = healing_bonus + 0.1
        end
        if target:HasModifier("modifier_item_crit_pure_2") then
            healing_bonus = healing_bonus + 0.05
        end
        local boneCollectorModifier = target:FindModifierByName("modifier_item_crit_pure_3")
        if boneCollectorModifier then
            local boneCollectorAbility = boneCollectorModifier:GetAbility()
            if(boneCollectorAbility) then
                healing_bonus = healing_bonus + boneCollectorAbility:GetSpecialValueFor("bonus_stat3") / 100
            end
        end
        local legionBannerModifier = target:FindModifierByName("modifier_item_crit_pure_4")
        if legionBannerModifier then
            local legionBannerAbility = legionBannerModifier:GetAbility()
            if(legionBannerAbility) then
                healing_bonus = healing_bonus + legionBannerAbility:GetSpecialValueFor("bonus_stat3") / 100
            end
        end
        if target:HasModifier("modifier_item_set_str_tank_full_t1") then
            healing_bonus = healing_bonus + 0.1
        end
        if target:HasModifier("modifier_item_set_str_tank_full_t1_dream") then
            healing_bonus = healing_bonus + 0.15
        end
        if target:HasModifier("modifier_lifesteal_double") then
            healing_bonus = healing_bonus + 0.1
        end
        if target:HasModifier("modifier_deathknight") then
            healing_bonus = healing_bonus + 0.25
        end
        if target:HasModifier("modifier_master_elements") then
            healing_bonus = healing_bonus + 0.5
        end
        if target:HasModifier("modifier_voidhp") then
            healing_bonus = healing_bonus + 0.2
        end
        if event.druidlowbonus and event.druidlowbonus > 0 and target:GetHealth()/target:GetMaxHealth() < 0.5 then
            healing_bonus = healing_bonus + event.druidlowbonus/100
        end
        if target:HasModifier("modifier_item_shieldluna") then
            healing_bonus=healing_bonus + 0.05
        end
        if target:HasModifier("modifier_earth_shield") and event.eshieldbonus then
            healing_bonus=healing_bonus + event.eshieldbonus - 1
        end
        if target:HasModifier("modifier_eternallife") then
            healing_bonus = healing_bonus + 1
        end
        if target:HasModifier("modifier_fanatism_2") and target:HasModifier("modifier_class_sanctified") then
            healing_bonus = healing_bonus + 2
        end
        if caster:HasModifier("modifier_guardian_self") and target:HasModifier("modifier_guardian") and event.FromGuardian ~= 1 then
            healing_bonus=healing_bonus + 0.25
        end
        if target.talents and target.talents[51] and target.talents[51] > 0 and target:Script_GetMagicalArmorValue(false, nil) >= 0.7 and target:GetPhysicalArmorValue(false) >= 35 then
            healing_bonus = healing_bonus + 0.1 * target.talents[51]
        end
        local protpalatalent = target:FindAbilityByName("pala6")
        if protpalatalent and protpalatalent:GetLevel() >= 3 then
            healing_bonus=healing_bonus + 0.5
        end
        if target.talents and target.talents[3] then
            healing_bonus = healing_bonus + 0.03*target.talents[3]
        end
    end
    if caster:HasModifier("modifier_item_straxe3") and event.commandershout then
        healing_bonus = healing_bonus + 1
    end
    
    if caster:HasModifier("modifier_element_holy") then
        healing_bonus = healing_bonus + 0.2
    end
    if caster:HasModifier("modifier_demon_form3") then
        healing_bonus = healing_bonus + 1
    end
    if caster:HasModifier("modifier_mythic_heal") then
        healing_bonus = healing_bonus + caster:GetModifierStackCount("modifier_mythic_heal", nil)/100
    end
    local priest_heal_talent = caster:FindAbilityByName("holy6")
    if priest_heal_talent and priest_heal_talent:GetLevel() >= 3 then
        healing_bonus = healing_bonus + 0.25
    end
    priest_heal_talent = caster:FindAbilityByName("terror3")
    if priest_heal_talent and priest_heal_talent:GetLevel() >= 4 then
        healing_bonus = healing_bonus + GetAgilityCustom(caster) * 0.001
    end
    if caster:GetName() == "npc_dota_hero_dazzle" and caster:GetAbilityByIndex(5):GetLevel() >= 4 then
        healing_bonus = healing_bonus + 0.25
    end
    if caster:HasModifier("item_mother_of_dragons") then
        healing_bonus = healing_bonus + 0.15
    end
    if event.innercdbonus and event.innercdbonus > 0 and not caster:HasModifier("modifier_inner_cd_bonus") and process_procs then
        healing_bonus = healing_bonus + event.innercdbonus/100 - 1
        event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_inner_cd_bonus", nil)
    end
    
    if caster:HasModifier("modifier_crusader_mount") then
        healing_bonus = healing_bonus + 0.25
    end
    
    if caster:HasModifier("modifier_item_eternallife") then
        healing_bonus=healing_bonus + 0.15
    end
    
    if caster:HasModifier("modifier_active9") then
        healing_bonus = healing_bonus + 0.3
    end
    
    if ability and caster:HasModifier("modifier_new8") then
        healing_bonus = healing_bonus + 0.005 * ability:GetManaCost(ability:GetLevel())
    end
    if ability and caster:HasModifier("modifier_new82") then
        healing_bonus = healing_bonus + 0.01 * ability:GetManaCost(ability:GetLevel())
    end
    
    if event.alwaysself ~= nil then
        if caster == target then
            healing_bonus = healing_bonus + event.alwaysself
        end
    end
    
    if caster.talents and caster.talents[72] and caster.talents[72] > 0 then
        healing_bonus = healing_bonus + 0.07 * caster.talents[72]
    end
    if caster.talents and caster.talents[91] and caster.talents[91] > 0 and caster:IsMoving() then
        healing_bonus = healing_bonus + 0.1 * caster.talents[91]
    end
    if caster.talents and caster.talents[3] then
        healing_bonus = healing_bonus + 0.03*caster.talents[3]
    end
    
    if caster.talents and caster.talents[74] and caster.talents[74] > 0 and caster.path_sacrifice_souls_paid then
        healing_bonus = healing_bonus + 0.15 * caster.talents[74]
    end
    if caster and caster:IsRealHero() and caster.temple_class and not event.ignore_temple_class_penalty then
        healing_bonus = healing_bonus * 0.5
    end
    return healing_bonus
end

function PerformAutoAttackWithDelay( caster, target, delay )
    Timers:CreateTimer(delay, function()
        CheckForAutoAttackCriticalStrikeProcs(caster, target)
        caster:PerformAttack(target, true, true, true, true, true, false, false)
    end)
end

function PerformAutoAttack( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if event.requires_and_starts_cooldown and ability then
        if ability:GetCooldownTimeRemaining() > 0 then
            return
        else
            ability:StartCooldown(event.requires_and_starts_cooldown)
        end
    end
    if event.onattacked then
        target = event.attacker
    end
    if event.delayaa then
        PerformAutoAttackWithDelay(caster, target, event.delayaa)
    else
        CheckForAutoAttackCriticalStrikeProcs(caster, target)
        caster:PerformAttack(target, true, true, true, true, true, false, false)
    end
    if event.showFX then
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, caster)
        ParticleManager:SetParticleControl(particle, 4, caster:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:SetParticleControl(particle, 5, target:GetAbsOrigin()+Vector(0,0,75))
        ParticleManager:ReleaseParticleIndex(particle)
        EmitSoundOn("Hero_LegionCommander.Overwhelming.Hero", caster)
    end
end

function PVEBossToughness( event )
    --local caster = event.caster
    --if (not caster.pve_toughness_active) and caster:HasModifier("modifier_pve_boss_toughness") then
    --    caster.pve_toughness_active = true
    --    caster:RemoveModifierByName("modifier_pve_boss_toughness")
    --    event.ability:ApplyDataDrivenModifier(caster, caster, "modifier_pve_boss_toughness", {Duration = 10}) --30 before
    --end
end

function ClosestBuff( event )
    local caster = event.caster
    local target = FindClosestEnemy({caster = caster, radius = event.range})
    if target then
        event.ability:ApplyDataDrivenModifier(caster, target, event.buff, {Duration = event.dur})
    end
end

function SetToughnessHealth( event )
    local caster = event.caster
    if caster.pve_toughness_active then
        caster:SetHealth(caster:GetHealth() + caster:GetMaxHealth() * 0.02)
    end
end

function FrostFireChains( event )
    local caster = event.caster
    local ability = event.ability
    local target = COverthrowGameMode:RandomXHeroes({caster = caster, numbertargets = 3, stillbuffifless = 1})
    if target then
        local tickDelay = 0.3333
        local duration = 25
        local ticks = duration / tickDelay
        local frostChainActive = true
        local fireChainActive = true
        local frostBreakDistance = 200
        local fireBreakDistance = 2000
        --smart swap based on distance
        if TargetIsAliveAndExists(target[1]) and TargetIsAliveAndExists(target[2]) and TargetIsAliveAndExists(target[3]) and (target[1]:GetAbsOrigin() - target[2]:GetAbsOrigin()):Length() > (target[2]:GetAbsOrigin() - target[3]:GetAbsOrigin()):Length() then
            local target1 = target[1]
            target[1] = target[3]
            target[3] = target1
        end
        for i=1, ticks do
            local damageMult = i
            Timers:CreateTimer(0.05 + i * tickDelay, function()
                if fireChainActive and TargetIsAliveAndExists(target[1]) and TargetIsAliveAndExists(target[2]) and TargetIsAliveAndExists(caster) and (target[1]:GetAbsOrigin() - target[2]:GetAbsOrigin()):Length() < fireBreakDistance then
                    
                    DamageUnit({caster = caster, target = target[1], ability = ability, damage = 0, difficultyscale = damageMult * 10})
                    DamageUnit({caster = caster, target = target[2], ability = ability, damage = 0, difficultyscale = damageMult * 10})
                    EmitSoundOn("Hero_Lina.Attack", target[1])
                    EmitSoundOn("Hero_Lina.Attack", target[2])
                    local particle = ParticleManager:CreateParticle("particles/items_fx/dagon.vpcf", PATTACH_WORLDORIGIN, target[1])
                    ParticleManager:SetParticleControl(particle, 0, target[1]:GetAbsOrigin()+Vector(0,0,80))
                    ParticleManager:SetParticleControl(particle, 1, target[2]:GetAbsOrigin()+Vector(0,0,80))
                    ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
                    ParticleManager:ReleaseParticleIndex(particle)
                else
                    fireChainActive = false
                end
                if #target >= 3 and frostChainActive and TargetIsAliveAndExists(target[2]) and TargetIsAliveAndExists(target[3]) and TargetIsAliveAndExists(caster) and (target[2]:GetAbsOrigin() - target[3]:GetAbsOrigin()):Length() > frostBreakDistance then
                    DamageUnit({caster = caster, target = target[2], ability = ability, damage = 0, difficultyscale = damageMult * 10})
                    DamageUnit({caster = caster, target = target[3], ability = ability, damage = 0, difficultyscale = damageMult * 10})
                    EmitSoundOn("Hero_Lina.Attack", target[2])
                    EmitSoundOn("Hero_Lina.Attack", target[3])
                    local particle = ParticleManager:CreateParticle("particles/econ/events/ti7/dagon_ti7.vpcf", PATTACH_WORLDORIGIN, target[2])
                    ParticleManager:SetParticleControl(particle, 0, target[2]:GetAbsOrigin()+Vector(0,0,80))
                    ParticleManager:SetParticleControl(particle, 1, target[3]:GetAbsOrigin()+Vector(0,0,80))
                    ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
                    ParticleManager:ReleaseParticleIndex(particle)
                else
                    frostChainActive = false
                end
            end)
        end
    end
end

function TargetIsAliveAndExists( hero )
    if hero and not hero:IsNull() and hero:IsAlive() then
        return true
    end
    return false
end

function Hellgate(event)
    local caster = event.caster
    local target = event.target
    target.hellgate_target = caster
    target:AddAbility("pve_hellgate_missiles"):SetLevel(1)
end

function HellgateMissile(event)
    local caster = event.caster
    local target = caster.hellgate_target
    if target then
        event.ability:ApplyDataDrivenModifier(caster, target, event.buff, {Duration = 0.1})
    end
end

function HellgateDamage(event) 
    local caster = event.caster
    local target = event.target
    if caster:GetTeamNumber() == target:GetTeamNumber() then
        if caster ~= target then
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_oracle/oracle_false_promise_heal_core.vpcf", PATTACH_POINT_FOLLOW, target)
            ParticleManager:ReleaseParticleIndex(particle)
            HealUnit({caster = caster, target = target, ability = event.ability, heal = 0, percenthp = 30 })
        end
    else
        DamageUnit(event)
    end
end

function ChannelTickSystem( event )
    local caster = event.caster
    local target = event.target
    if not target then
        target = caster
    end
    local ability = event.ability
    if not caster.channelCasts then
        caster.channelCasts = {}
    end
    if not caster.channelCastID then
        caster.channelCastID = 0
    else
        caster.channelCasts[caster.channelCastID] = false
    end
    caster.channelCastID = caster.channelCastID + 1
    if caster.channelCastID > 20 then
        caster.channelCastID = 1
    end
    local channelCastID = caster.channelCastID
    
    caster.channelCasts[channelCastID] = true
    local castNumber = caster.channelCastNumber
    if not castNumber then
        caster.channelCastNumber = 1
        castNumber = 1
    else
        caster.channelCastNumber = 2
        castNumber = 2
    end
    
    caster.is_channeling = true
    --local tickcount = 1
    local tickinterval = event.tickinterval
    --local channelintervalcheck = event.channelintervalcheck
    --local channeltime = channelintervalcheck
    local duration = event.duration
    local haste = GetChannelSpellhaste(caster, event)
    tickinterval = tickinterval / haste
    if tickinterval < 0.05 then --minimum cap
        tickinterval = 0.05
    end
    --if channelintervalcheck <= 0 then
    --    channelintervalcheck = 0.1
    --end
    local maxtotalticks = duration / tickinterval
    --proc first tick instantly
    if event.instantfirsttick then
        ability:ApplyDataDrivenModifier(caster, target, "modifier_channel_proc", {Duration = 0.05})
    end
    local count = 1
    for count=1, maxtotalticks do
        Timers:CreateTimer(tickinterval * count, function()
            if caster.is_channeling and caster.channelCasts[channelCastID] then
                --channeltime = channeltime + channelintervalcheck
                --if channeltime >= tickinterval * tickcount then
                    --tick!
                    --tickcount = tickcount + 1
                    ability:ApplyDataDrivenModifier(caster, target, "modifier_channel_proc", {Duration = 0.05})
                --end
            end
        end)
    end
end

function GetChannelSpellhasteCap( caster )
    local cap = 3 --2
    --if caster:HasModifier("modifier_wing") or caster:HasModifier("modifier_wing2") then
    --    cap = 2.5
    --end
    --if GetSonicWallStat(caster) >= 1 then
    --    cap = 1 + (cap - 1) * (1 + GetSonicWallStat(caster) * 0.01)
    --end
    return cap
end

function GetChannelSpellhaste( caster, event )
    local haste = GetSpellhaste(caster, event) * 0.5
    if caster:HasModifier("modifier_wing") or caster:HasModifier("modifier_wing2") then
        haste = haste + 0.25
    end
    if GetSonicWallStat(caster) >= 1 then
        local bonus = GetSonicWallStat(caster) * GetStrengthCustom(caster) / 10000
        if bonus > 0.5 then
            bonus = 0.5
        end
        haste = haste + bonus
    end
    haste = haste + 1 --make it a multiply factor
    local cap = GetChannelSpellhasteCap( caster )
    if haste > cap then --max cap
        haste = cap
    end
    if haste <= 0.5 then
        haste = 0.5
    end
    return haste
end

function GetDoTSpellhaste( caster, event )
    local haste = 0 --GetSpellhaste(caster, event)
    --if not haste then
    --    haste = 0
    --end
    if caster.talents then
        if caster.talents[97] then
            local bonus = 0.1 * caster.talents[97]
            if bonus > 0.5 then
                bonus = 0.5
            end
            haste = haste + bonus
        end
        if caster.talents[114] then
            local bonus = 0.1 * caster.talents[114] * GetSpellhaste(caster, event)
            if bonus > 0.5 then
                bonus = 0.5
            end
            haste = haste + bonus
        end
        if caster.talents[151] then
            local bonus = 0.0003 * caster.talents[151] * GetAgilityCustom(caster)
            if bonus > 0.5 then
                bonus = 0.5
            end
            haste = haste + bonus
        end
        if GetSonicWallStat(caster) >= 1 then
            local bonus = GetSonicWallStat(caster) * GetStrengthCustom(caster) / 10000
            if bonus > 0.5 then
                bonus = 0.5
            end
            haste = haste + bonus
        end
    end
    if caster:HasModifier("modifier_firefly_mage") then
        haste = haste + 0.5
    end
    if caster:HasModifier("modifier_wing") or caster:HasModifier("modifier_wing2") then
        haste = haste + 0.25
    end
    haste = haste + 1 --make it a multiply factor
    --if haste > 2.5 then --max cap
    --    haste = 2.5
    --end
    if haste <= 0.5 then
        haste = 0.5
    end
    return haste
end

function SetManaRegeneration( hero, regen )
    hero:SetBaseManaRegen(regen)
end

function GetManaRegenerationPerSec( hero )
    local regen = 0
    local regenFactor = 1
    if hero.talents and hero.talents[75] > 0 then
        regen = regen + hero.talents[75]
    end
    if not hero.resourcesystem then
        regenFactor = GetManaRegenerationFactor(hero)
        regen = regen + 1
        if hero.talents and hero.talents[113] > 0 then
            regen = regen + 0.002 * hero:GetMaxMana() * hero.talents[113]
        end
        if hero:HasModifier("modifier_inttohp2") then
            regen = regen + 5
        end
        if hero:HasModifier("modifier_pathbuff_033") then
            regen = regen + 2
        end
        if hero:HasModifier("modifier_inttohp") then
            regen = regen + 3
        end
        if hero:HasModifier("modifier_element_arcane") then
            regen = regen + 2
        end
        if hero:HasModifier("modifier_item_standard") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_standard_aura") then
            regen = regen + 2
        end
        if hero:HasModifier("modifier_item_standard_aura_3") then
            regen = regen + 2
        end
        if hero:HasModifier("modifier_aura1") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_aura1") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_ringofflames") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_ringofflames") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_bootsmana") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_bootsmana2") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_bootsmana_2_libram") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_endgame13") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_bootsmana_2_libram_2") then
            regen = regen + 2
        end
        if hero:HasModifier("modifier_item_bootsmana3") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_cooldown") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_reg1") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_item_reg2") then
            regen = regen + 1
        end
        if hero:HasModifier("modifier_intreg") then
            regen = regen + 0.5
        end
        if hero:HasModifier("manatotemregen") then
            regen = regen + 5
        end
        if hero:HasModifier("modifier_arcane_armor_mage") then
            regen = regen + 3
        end
    else
        regenFactor = GetEnergyRegenerationFactor(hero)
        if hero.resourcesystem == 1 then --warrior
            regen = regen - 0.3
        end
        if hero.resourcesystem == 2 or hero.resourcesystem == 4 then --rogue dazzle
            regen = regen + 15
        end
        if hero.resourcesystem == 3 then --dk (none per sec)
            
        end
        if hero.resourcesystem == 5 then --hunter
            regen = regen + 10
        end
    end
    return regen * regenFactor - GetNegativeManaRegenerationPerSec(hero)
end

function GetNegativeManaRegenerationPerSec( hero )
    local regen = 0
    if hero:HasModifier("modifier_mage_1") and not hero:HasModifier("modifier_oocmana") then
        regen = regen + 15
    end
    return regen
end

function GetManaRegenerationFactor(hero)
    local factor = 1
    if hero.talents and hero.talents[157] > 0 then
        factor = factor + 0.1 * hero.talents[157]
    end
    if hero:HasModifier("modifier_windbreaker") then
        factor = factor + 0.1 * hero.talents[83]
    end
    return factor
end

function GetEnergyRegenerationFactor(hero)
    return GetEnergyBonusFactor({caster = hero})
end

function CheckForMaxManaCap( hero )
    local buff = "modifier_mana_penalty"
    if hero:HasModifier(buff) then
        hero:RemoveModifierByName(buff)
    end
    if not IsManaHero(hero) then
        local maxAllowed = GetMaxEnergy( {caster = hero} )
        local max = hero:GetMaxMana()
        if max > maxAllowed then
            if hero.combat_system_ability then
                hero.combat_system_ability:ApplyDataDrivenModifier(hero, hero, buff, {Duration = -1})
                hero:SetModifierStackCount(buff, hero.combat_system_ability, max - maxAllowed)
            end
        end
    end
end

function IsManaHero( hero )
    if hero.resourcesystem then
        return false
    end
    return true
end

function GetSpellCleaveChance( hero )
    local chance = GetSpellCleaveStat(hero)
    local ability = hero:FindAbilityByName("hawk7")
    if ability and ability:GetLevel() >= 2 then
        chance = chance + 10
    end
    ability = hero:FindAbilityByName("Feral4")
    if ability and ability:GetLevel() >= 4 and hero:HasModifier("modifier_wild_swipe") then
        chance = chance + 15
    end
    return chance
end

function SpellCleaveProc( damageTable )
    local caster = damageTable.attacker
    local originalTarget = damageTable.victim
    local aoe = 250
    local enemies = FindUnitsInRadius( caster:GetTeamNumber(), originalTarget:GetAbsOrigin(), caster, aoe, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_BASIC, 0, 0, false )
    if #enemies > 0 then
        EmitSoundOn("Hero_LegionCommander.Overwhelming.Hero", originalTarget)
        for _,enemy in pairs(enemies) do
            if enemy and (enemy == originalTarget or (enemy ~= originalTarget and not HasDamageReflect(enemy))) then
                damageTable.victim = enemy
                ApplyDamage(damageTable)
                local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_centaur/centaur_double_edge_tgt_rope.vpcf", PATTACH_POINT_FOLLOW, originalTarget)
                ParticleManager:SetParticleControl(particle, 5, originalTarget:GetAbsOrigin() + Vector(0,0,100))
                ParticleManager:SetParticleControl(particle, 4, enemy:GetAbsOrigin() + Vector(0,0,75))
                ParticleManager:ReleaseParticleIndex(particle)
            end
        end
    end
end

function PVEMeteorCrash( event )
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    RockFall(caster, target, target:GetAbsOrigin(), ability, 2, 650, 200)
end

function RockFall( caster, target, position, ability, delay, height, aoe )
    EmitSoundOn("DOTA_Item.Butterfly", target)
    event = {caster = caster, target = target, ability = ability, target_points = {position}, damage = 0, difficultyscalelinear = 2500, aoe = aoe, targeteffect = "blood", delay = delay }
    DamageAOEDelayed( event )
    local particle = ParticleManager:CreateParticle("particles/meteor_hammer_spell_2secs.vpcf", PATTACH_WORLDORIGIN, target)
    ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + Vector(0,0,height))
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin() + Vector(0,0,25))
    ParticleManager:SetParticleControl(particle, 2, Vector(2,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
    Timers:CreateTimer(delay, function()
        EmitSoundOn("Ability.TossImpact", target)
    end)
end

function WaveVForm( event )
    local caster = event.caster
    local target = COverthrowGameMode:AggroHighest(caster)
    if target then
        EmitSoundOn("Ability.TossImpact", caster)
        local origin = caster:GetAbsOrigin()
        local direction = (target:GetAbsOrigin() - origin):Normalized()
        local speed = 500
        local info = 
        {
            Ability = event.ability,
            EffectName = "particles/econ/items/magnataur/shock_of_the_anvil/magnataur_shockanvil.vpcf",
            vSpawnOrigin = origin,--caster:GetAbsOrigin(),--origin,
            fDistance = 3000,
            fStartRadius = 75,
            fEndRadius = 75,
            Source = caster,
            bHasFrontalCone = false,
            bReplaceExisting = false,
            iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
            iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
            iUnitTargetType = DOTA_UNIT_TARGET_HERO,
            fExpireTime = GameRules:GetGameTime() + 60.0,
            bDeleteOnHit = false,
            vVelocity = direction * speed,
            bProvidesVision = true,
            iVisionRadius = 1000,
            iVisionTeamNumber = caster:GetTeamNumber()
        }
        ProjectileManager:CreateLinearProjectile(info)
        info.vVelocity = RotateVectorAroundAngle(direction * speed, 30)
        ProjectileManager:CreateLinearProjectile(info)
        info.vVelocity = RotateVectorAroundAngle(direction * speed, -30)
        ProjectileManager:CreateLinearProjectile(info)
    end
end

function ReignOfChaosFX( caster, target )
    if not caster.roc_cd then
        local particle = ParticleManager:CreateParticle("particles/units/heroes/heroes_underlord/abyssal_underlord_firestorm_wave.vpcf", PATTACH_ABSORIGIN, target)
        ParticleManager:ReleaseParticleIndex(particle)
        caster.roc_cd = true
        Timers:CreateTimer(1, function()
            caster.roc_cd = false
        end)
    end
end

function GetDifficultyModeDamageFactor()
    if COverthrowGameMode.difficultyMode == 0 then
        return 0.5
    end
    return 1
end

function GetDifficultyModeHealthFactor()
    if COverthrowGameMode.difficultyMode == 2 then
        return 3
    end
    return 1
end

function GetDifficultyModeChampionChanceFactor()
    if COverthrowGameMode.difficultyMode == 2 then
        return 2
    end
    return 1
end

function GetDifficultyModeExperienceFactor()
    if COverthrowGameMode.difficultyMode == 0 then
        return 0.5
    end
    if COverthrowGameMode.difficultyMode == 2 then
        return 2
    end
    return 1
end

function GetDifficultyModeExtraLives()
    if COverthrowGameMode.difficultyMode == 0 then
        return 5
    end
    return 0
end

function GetDifficultyModeDropChanceFactor()
    if COverthrowGameMode.difficultyMode == 0 then
        return 0.5
    end
    return 1
end

function GetDifficultyModeBossScoreFactor()
    if COverthrowGameMode.difficultyMode == 0 then
        return 0.5
    end
    if COverthrowGameMode.difficultyMode == 2 then
        return 2
    end
    return 1
end

function GetDifficultyModeExtraBossAffix()
    if COverthrowGameMode.difficultyMode == 2 then
        return true
    end
    return false
end

function GetDifficultyModeUniqueArtifactDropable()
    if COverthrowGameMode.difficultyMode == 2 then
        return true
    end
    return false
end

function GetDifficultyModeActScalingDynamic()
    if COverthrowGameMode.difficultyMode == 2 then
        return false
    end
    return true
end

function GetFirstBloodStat( hero )
    local stat = 0
    if hero.fis then
        stat = hero.fis
    end
    return stat
end

function GetEchoStat( hero )
    local stat = 0
    if hero.ech then
        stat = hero.ech
    end
    if stat > 50 then
        stat = 50
    end
    return stat
end

function GetSpellCleaveStat( hero )
    local stat = 0
    if hero.scl then
        stat = hero.scl
    end
    return stat
end

function GetSonicWallStat( hero )
    local stat = 0
    if hero.swa then
        stat = hero.swa
    end
    return stat
end

function GetPrimalFearStat( hero )
    local stat = 0
    if hero.fea then
        stat = hero.fea
    end
    return stat
end

function GetCorrosiveSkinStat( hero )
    local stat = 0
    if hero.csk then
        stat = hero.csk
    end
    return stat
end

function GetWarLeaderStat( hero )
    local stat = 0
    if hero.war then
        stat = hero.war
    end
    return stat
end

function GetLeaderOfThePackStat( hero )
    local stat = 0
    if hero.pac then
        stat = hero.pac
    end
    return stat
end

function GetArchmageStat( hero )
    local stat = 0
    if hero.mag then
        stat = hero.mag
    end
    return stat
end

function GetGlobalStrengthAuraStat()
    local stat = 0
    local all = HeroList:GetAllHeroes()
    for i=1, #all do
        stat = stat + GetWarLeaderStat(all[i])
    end
    return stat
end

function GetGlobalAgilityAuraStat()
    local stat = 0
    local all = HeroList:GetAllHeroes()
    for i=1, #all do
        stat = stat + GetLeaderOfThePackStat(all[i])
    end
    return stat
end

function GetGlobalIntellectAuraStat()
    local stat = 0
    local all = HeroList:GetAllHeroes()
    for i=1, #all do
        stat = stat + GetArchmageStat(all[i])
    end
    return stat
end

function GetGlobalHPAuraStat() --percentage
    local stat = GetGlobalTreeOfLifeBonus() * 0.05
    local all = HeroList:GetAllHeroes()
    for i=1, #all do
        if HeroHasNeutralItem(all[i], "item_neutral_15") then
            stat = stat + 0.1
        end
    end
    return stat
end

function GetGlobalTreeOfLifeBonus()
    local stat = 0
    local all = HeroList:GetAllHeroes()
    for i=1, #all do
        stat = stat + all[i].talents[142]
    end
    return stat
end

function GetCrusaderStat( hero )
    local stat = 0
    if hero.cru then
        stat = hero.cru
    end
    return stat
end

function GetWrathOfGodStat( hero )
    local stat = 0
    if hero.wra then
        stat = hero.wra
    end
    return stat
end

function GetInterstellarStat( hero )
    local stat = 0
    if hero.ins then
        stat = hero.ins
    end
    return stat
end

function GetShapeshifterStat( hero )
    local stat = 0
    if hero.shs then
        stat = hero.shs
    end
    return stat
end

function GetBerserkerStat( hero )
    local stat = 0
    if hero.ber then
        stat = hero.ber
    end
    return stat
end

function GetEyeOfTheTigerStat( hero )
    local stat = 0
    if hero.eot then
        stat = hero.eot
    end
    return stat
end

function GetTitanSorcererStat( hero )
    local stat = 0
    if hero.tsc then
        stat = hero.tsc
    end
    return stat
end

function GetFortressOfPainStat( hero )
    local stat = 0
    if hero.frt then
        stat = hero.frt
    end
    return stat
end

function GetInnerFireStat( hero )
    local stat = 0
    if hero.ifi then
        stat = hero.ifi
    end
    return stat
end

function GetMultistrikeStat( hero )
    local stat = 0
    if hero.mul then
        stat = hero.mul
    end
    return stat
end

function GetFlamewalkerStat( hero )
    local stat = 0--100
    if hero.fla then
        stat = hero.fla
    end
    return stat
end

function GetTidesOfTimeStat( hero )
    local stat = 0
    if hero.tid then
        stat = hero.tid
    end
    return stat
end

function GetAfterburnStat( hero )
    local stat = 0
    if hero.aft then
        stat = hero.aft
    end
    return stat
end

function GetFrostbiteStat( hero )
    local stat = 0
    if hero.fbi then
        stat = hero.fbi
    end
    return stat
end

function GetTwinStormStat( hero )
    local stat = 0
    if hero.twi then
        stat = hero.twi
    end
    return stat
end

function GetBlackMirrorStat( hero )
    local stat = 0
    if hero.bla then
        stat = hero.bla
    end
    return stat
end

function GetStarCollapseStat( hero )
    local stat = 0
    if hero.stc then
        stat = hero.stc
    end
    return stat
end

function GetHemorrhageStat( hero )
    local stat = 0
    if hero.hem then
        stat = hero.hem
    end
    return stat
end

function GetRadianceStat( hero )
    local stat = 0
    if hero.rad then
        stat = hero.rad
    end
    return stat
end

function GetNaturesHarmonyStat( hero )
    local stat = 0
    if hero.har then
        stat = hero.har
    end
    return stat
end

function GetForceOfNatureStat( hero )
    local stat = 0
    if hero.fon then
        stat = hero.fon
    end
    return stat
end

function GetTowerOfChaosStat( hero )
    local stat = 0
    if hero.tow then
        stat = hero.tow
    end
    return stat
end

function GetNetherfusionStat( hero )
    local stat = 0
    if hero.mig then
        stat = hero.mig
    end
    return stat
end

function GetSwiftMendingStat( hero )
    local stat = 0
    if hero.swi then
        stat = hero.swi
    end
    return stat
end

function GetDivineShieldStat( hero )
    local stat = 0
    if hero.div then
        stat = hero.div
    end
    return stat
end

function GetChivalryStat( hero )
    local stat = 0
    if hero.chi then
        stat = hero.chi
    end
    return stat
end

function GetMountainGiantStat( hero )
    local stat = 0
    if hero.mou then
        stat = hero.mou
    end
    return stat
end

function GetThunderGiantStat( hero )
    local stat = 0
    if hero.thu then
        stat = hero.thu
    end
    return stat
end

function GetAlchemistStat( hero )
    local stat = 0
    if hero.alc then
        stat = hero.alc
    end
    return stat
end

function GetBeastWithinStat( hero )
    local stat = 0
    if hero.bwi then
        stat = hero.bwi
    end
    return stat
end

function GetShiveringColdStat( hero )
    local stat = 0
    if hero.shc then
        stat = hero.shc
    end
    return stat
end

function GetManawormStat( hero )
    local stat = 0
    if hero.mwo then
        stat = hero.mwo
    end
    return stat
end

function GetMassiveMassacreStat( hero )
    local stat = 0
    if hero.mma then
        stat = hero.mma
    end
    return stat
end

function GetMetamorphosisStat( hero )
    local stat = 0
    if hero.met then
        stat = hero.met
    end
    return stat
end

function Mars2( event )
    local caster = event.caster
    caster.mars2reduction = event.redu
end

function Mars5( event )
    local caster = event.caster
end

function Mars4( event )
    local caster = event.caster
    local target = FindClosestAlly(caster, caster:GetAbsOrigin(), 900, false)
    if target then
        HealUnit({caster = caster, target = target, ability = event.ability, heal = 0, percenthp = 50 })
        local particle = ParticleManager:CreateParticle("particles/items_fx/dagon.vpcf", PATTACH_WORLDORIGIN, caster)
        ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,80))
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin()+Vector(0,0,80))
        ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
        ParticleManager:ReleaseParticleIndex(particle)
    end
end

function Mars5FX( event )
    local target = event.target
    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_mars/mars_arena_of_blood_colosseum_columns.vpcf", PATTACH_WORLDORIGIN, target)
    ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
    ParticleManager:SetParticleControl(particle, 1, Vector(450,1,1))
    ParticleManager:SetParticleControl(particle, 2, target:GetAbsOrigin())
    Timers:CreateTimer(event.dur, function()
        ParticleManager:DestroyParticle(particle,false)
        ParticleManager:ReleaseParticleIndex(particle)
    end)
end

function Mars6( event )
    local caster = event.caster
    local ability = event.ability
    local cds = GetAbilitiesOnCooldown(caster)
    if ability:GetLevel() >= 2 then
        local cds = GetAbilitiesOnCooldown(caster)
        if cds >= 1 then
            local myevent = {}
            myevent.caster = caster
            myevent.percenthp = 10 * cds
            myevent.heal = 0.0
            myevent.ability = ability
            HealUnit(myevent)
        end
    end
end

function Holy2( event )
    local caster = event.caster
    local target = FindClosestAlly(caster, caster:GetAbsOrigin(), 600, false)
    if not target then
        target = caster
    end
    HealUnit({caster = caster, target = target, ability = event.ability, heal = 0, percenthp = 10, oncritbuff = "modifier_holydef", oncritbuffnotself = 1 })
    local particle = ParticleManager:CreateParticle("particles/dazzle_holy_wave_b.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin()+Vector(0,0,80))
    ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin()+Vector(0,0,80))
    ParticleManager:SetParticleControl(particle, 2, Vector(1,0,0))
    ParticleManager:ReleaseParticleIndex(particle)
    --local ev = {caster = caster, target = caster, firedmg = 1, ability = caster.combat_system_ability, damage = 10000000000, attributefactor = 10000000, aoe = 2500, isaoe = 1, dontdamagereflect = true }
    --DamageAOE(ev)
end

function ReduceCooldownLastCastAbility( event )
    local caster = event.caster
    if caster.last_cast_ability_with_cd then
        local myevent = {caster = caster, amount = event.amount, ability = caster.last_cast_ability_with_cd }
        ReduceCooldown(myevent)
    end
end

function GetLevelOfAbility( hero, abilityName )
    local ability = hero:FindAbilityByName(abilityName)
    if ability then
        return ability:GetLevel()
    end
    return 0
end

function SpiritHealCrit( event )
    if event.ability:GetLevel() >= 3 then
        event.caster.spiritHealCrit = 2
    end
end

function FelBlast( caster, target )
    local range = 250
    local particle = ParticleManager:CreateParticle("particles/econ/items/pugna/pugna_ti9_immortal/pugna_ti9_immortal_netherblast.vpcf", PATTACH_WORLDORIGIN, caster)
    ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin())
    ParticleManager:SetParticleControl(particle, 1, Vector(range,1,1))
    ParticleManager:ReleaseParticleIndex(particle)
    local tab = {}
    tab.caster = caster
    tab.target = target
    tab.damage = 0.0
    tab.spelldamagefactor = 0.0
    tab.attributefactor = 250
    tab.attributechangestragi = 250
    tab.ability = caster:GetAbilityByIndex(2)
    tab.aoe = range
    --tab.targeteffect = "blood"
    tab.targetpos = 1
    tab.dontbreakcc = 1
    tab.max_targets = 5
    tab.chaosdmg = 1
    DamageAOE(tab)
end

function TryPayGold( hero, cost )
    if GetGold(hero) < cost then
        return false
    else
        SetGold(hero, GetGold(hero) - cost)
        return true
    end
end

function AddGold( hero, gold )
    local newGold = GetGold(hero) + gold
    if newGold > 999999 then
        newGold = 999999
    end
    SetGold(hero, newGold)
end

function SetGold( hero, gold )
    hero.gold = gold
    CustomGameEventManager:Send_ServerToAllClients("set_gold", {id = hero:GetPlayerID(), gold = hero.gold})
end

function GetGold( hero )
    return hero.gold
end

function BuyNormalItem(event, args)
    local player = PlayerResource:GetPlayer(args['player_id'])
    local hero = player:GetAssignedHero()
    local itemname = args['item']
    local rarity = args['rarity']
    if hero and hero:IsHero() and hero:IsAlive() and itemname and rarity then
        local cost = GetCostByItemLevel(rarity)
        if TryPayGold(hero, cost) then
            local spot = hero:GetAbsOrigin() + Vector(0,-65,0)
            local item = CreateItem(itemname, hero, hero)
            local item2 = CreateItemOnPositionSync(spot, item)
            local particle3 = ParticleManager:CreateParticle( "particles/econ/items/alchemist/alchemist_midas_knuckles/alch_knuckles_lasthit_coins.vpcf", PATTACH_CUSTOMORIGIN, hero)
            ParticleManager:SetParticleControl(particle3, 1, spot)
            ParticleManager:ReleaseParticleIndex(particle3)
            EmitSoundOn("DOTA_Item.Hand_Of_Midas", hero)
            Notifications:Top(hero:GetPlayerID(), {text="Item Purchased!", duration=5, style={color="yellow"}})
        else
            Notifications:Top(hero:GetPlayerID(), {text="Not enough Gold!", duration=5, style={color="red"}})
        end
    end
end

function GetHealingFactorFromHealerCount()
    local factor = 1
    if COverthrowGameMode.healersInGame == 2 then
        factor = 0.2
    end
    if COverthrowGameMode.healersInGame >= 3 then
        factor = 0.1
    end
    return factor
end

function GetHeroLevel( hero )
    return hero.level
end

function LunarEclipseProc( hero )
    local critdmgbonus = 0
    if hero.talents and hero.talents[124] > 0 then
        local stacks = hero:GetModifierStackCount("modifier_lunarecl", nil)
        if stacks >= 1 then
            critdmgbonus = 0.35 * hero.talents[124]
            stacks = stacks - 1
            if stacks <= 0 then
                hero:RemoveModifierByName("modifier_lunarecl")
            else
                hero:SetModifierStackCount("modifier_lunarecl", hero.combat_system_ability, stacks)
            end
        end
    end
    return critdmgbonus
end

function GetButterflyDamageFactor( hero, ability )
    local abilityIndex = -1
    for i=0, COverthrowGameMode.heroAbilityCount do
        if ability == hero:GetAbilityByIndex(i) then
            abilityIndex = i
            break
        end
    end
    local bonus = 0
    if abilityIndex >= 0 then
        if not hero.butterflyExpectedAbility then
            hero.butterflyExpectedAbility = 0
        end
        if abilityIndex == 0 then
            hero.butterflyExpectedAbility = 1
            ApplyBuffStack({caster = hero, target = hero, ability = hero.combat_system_ability, buff = "modifier_butterflyeff", dur = -1, setstacks = hero.butterflyExpectedAbility + 1})
            return 1
        end
        if hero.butterflyExpectedAbility == abilityIndex then
            bonus = 0.3 * math.pow(2, abilityIndex-1)
            hero.butterflyExpectedAbility = hero.butterflyExpectedAbility + 1
            if hero.butterflyExpectedAbility >= 6 then
                hero.butterflyExpectedAbility = 0
            end
        end
        ApplyBuffStack({caster = hero, target = hero, ability = hero.combat_system_ability, buff = "modifier_butterflyeff", dur = -1, setstacks = hero.butterflyExpectedAbility + 1})
    end
    return 1 + bonus
end

function SavageryProc(caster, dmgType)
    if caster.savagery and caster.talents[131] > 0 and not caster:HasModifier("modifier_savagery") then
        caster.savagery[dmgType] = true
        if caster.savagery[1] and caster.savagery[2] and caster.savagery[3] then
            ApplyBuff({ caster = caster, target = caster, dur = 10, buff = "modifier_savagery", ability = caster.combat_system_ability})
            caster.savagery[1] = false
            caster.savagery[2] = false
            caster.savagery[3] = false
        end
    end
end

function ConsumeComboPoints( caster, target )
    if caster.talents and caster.talents[134] > 0 then
        if not caster.consumeComboPointsCounter then
            caster.consumeComboPointsCounter = 0
        end
        if caster.lastComboPointTarget == target then
            caster.consumeComboPointsCounter = caster.consumeComboPointsCounter + 1
        else
            caster.consumeComboPointsCounter = 1
            caster.lastComboPointTarget = target
        end
        if caster.consumeComboPointsCounter >= 5 - caster.talents[134] then
            caster.consumeComboPointsCounter = 0
            local particle = ParticleManager:CreateParticle("particles/econ/events/ti9/mekanism_recipient_b_ti9.vpcf", PATTACH_POINT_FOLLOW, caster)
            ParticleManager:ReleaseParticleIndex(particle)
            return false
        end
    end
    return true
end

function ClubOfThunder( event )
    if math.random(1,100) <= 50 then
        local caster = event.caster
        local attacker = event.attacker
        TyphoonProc( caster, attacker, true )
    end
end

function TyphoonProc( caster, target, alwaysProc )
    if caster.talents[136] <= 0 or not target or HasDamageReflect(target) then
        return
    end
    local stacks = caster:GetModifierStackCount("modifier_typhoon", nil)
    if alwaysProc or stacks >= 1 then
        if not alwaysProc then
            local myevent = {caster = caster, target = caster, buff = "modifier_typhoon", ability = caster.combat_system_ability }
            DecreaseBuffStack(myevent)
        end
        local particle = ParticleManager:CreateParticle("particles/econ/items/arc_warden/arc_warden_ti9_immortal/arc_warden_ti9_wraith_cast_lightning.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:SetParticleControl(particle, 1, target:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
        DamageUnit({caster = caster, target = target, ability = caster.combat_system_ability, damage = 0, attributefactor = 250 * caster.talents[136], attributechangeall = 1, naturedmg = 1})
        RestoreResource({caster = caster, amount = 3 * caster.talents[136]})
        EmitSoundOn("Ability.GushCast", target)
        OnNaturalDisasterProcced( caster, target, 7 )
    end
end

function GetMaxDebuffStackBonus( hero )
    local value = 0
    if hero.talents then
        value = value + hero.talents[141]
    end
    return value
end

function GetMaxBuffStackBonus( hero )
    local value = 0
    if hero.talents then
        value = value + hero.talents[144]
    end
    return value
end

function GetAbilityChargesBonus( hero )
    local value = 0
    if hero.talents then
        value = value + hero.talents[137]
    end
    return value
end

function OnNaturalDisasterProcced( caster, target, originalDisaster )
    if caster.talents[138] > 0 and math.random(1,100) <= caster.talents[138] * 5 and not caster.naturalDisasterCD then
        caster.naturalDisasterCD = true
        local count = 1
        for i=1, 6 do
            if i ~= originalDisaster then
                Timers:CreateTimer(0.3 * count, function()
                    if not HasDamageReflect(target) then
                        ProcNaturalDisaster(caster, target, i)
                    end
                end)
                count = count + 1
            end
        end
        Timers:CreateTimer(3 * GetInnerCooldownFactor(caster), function()
            caster.naturalDisasterCD = false
        end)
    end
end

function ProcNaturalDisaster( caster, target, disaster )
    if disaster == 1 then
        PathRainOfStarsAA({caster = caster, target = target, ability = caster.combat_system_ability, rainOfStarsChance = 100})
    end
    if disaster == 2 then
        BlizzardTalent(caster, target, true)
    end
    if disaster == 3 then
        IceStormProc(caster, true)
    end
    if disaster == 4 then
        PathStormStrikeProc( caster, target, false, false, true, true)
    end
    if disaster == 5 then
        EpidemicProc(caster, target, true)
    end
    if disaster == 6 then
        TyphoonProc( caster, target, true )
    end
end

function IceStormProc( caster, ignoreInnerCD )
    if caster.talents[55] <= 0 then
        return
    end
    local combat_ability = caster.combat_system_ability
    if combat_ability then
        local bolts = 5
        if not ignoreInnerCD then
            caster.ice_storm_cd = true
        end
        for i=1, bolts do
            Timers:CreateTimer(0.4*i, function()
                if i == bolts and not ignoreInnerCD then
                    caster.ice_storm_cd = false
                end
                local target = FindClosestEnemy({caster = caster, radius = 750})
                if target then
                    local projectile = "particles/units/heroes/hero_lich/lich_chain_frost.vpcf"
                    if caster:HasModifier("modifier_pathbuff_036") then
                        projectile = "particles/lich_chain_frostfire.vpcf"
                    end
                    EmitSoundOn("hero_Crystal.preAttack", caster)
                    local info = {
                        Target = target,
                        Source = caster,
                        Ability = combat_ability,
                        EffectName = projectile, --"particles/units/heroes/hero_winter_wyvern/wyvern_splinter.vpcf",
                        bDodgeable = true,
                        bProvidesVision = true,
                        iMoveSpeed = 900,
                        iVisionRadius = 300,
                        iVisionTeamNumber = caster:GetTeamNumber(),
                        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_HITLOCATION
                    }
                    ProjectileManager:CreateTrackingProjectile( info )
                end
            end)
        end
        local target = FindClosestEnemy({caster = caster, radius = 750})
        if target then
            OnNaturalDisasterProcced( caster, target, 3 )
        end
    end
end

function EpidemicProc( caster, target, alwaysProc )
    if caster.talents[96] <= 0 then
        return
    end
    local chance = 2 + caster.talents[96]
    local aoe = 300
    local dur = 3
    if math.random(1,100) <= chance and not caster.epidemic_cooldown then
        local inner_cd = 1 * GetInnerCooldownFactor(caster)
        if not alwaysProc then
            caster.epidemic_cooldown = true
        end
        local buffevent = { caster = caster, target = target, ability = caster.combat_system_ability, aoe = aoe, targetpos = 1, buff = "modifier_plaguedot", dur = dur, settickrate = 1}
        ApplyBuffAOE(buffevent)
        local particle = ParticleManager:CreateParticle("particles/econ/items/effigies/status_fx_effigies/jade_base_statue_destruction_generic_d.vpcf", PATTACH_POINT_FOLLOW, target)
        ParticleManager:ReleaseParticleIndex(particle)
        if not alwaysProc then
            Timers:CreateTimer(inner_cd,function()
                caster.epidemic_cooldown = nil
            end)
        end
        OnNaturalDisasterProcced( caster, target, 5 )
    end
end

function CountAbilitiesWithLevel( hero, level )
    local count = 0
    for i = 0, COverthrowGameMode.heroAbilityCount do
        local ability = hero:GetAbilityByIndex(i)
        if ability and not ability:IsPassive() and ability:GetLevel() == level then
            count = count + 1
        end
    end
    return count
end

function CountMutationEffects( hero )
    local count = 0
    if hero:HasModifier("modifier_talent_enrage") then
        count = count + 1
    end
    if hero:HasModifier("modifier_talent_invul") then
        count = count + 1
    end
    if hero:HasModifier("modifier_path_from_shadows") then
        count = count + 1
    end
    if hero:HasModifier("modifier_path_shadowform") then
        count = count + 1
    end
    if hero:HasModifier("modifier_stormcrow") then
        count = count + 1
    end
    if hero:HasModifier("modifier_crowfall") then
        count = count + 1
    end
    return count
end

function GiantsOnCooldown(hero)
    return (hero:HasModifier("modifier_moltengiant_cd") and hero:HasModifier("modifier_stormgiant_cd") and hero:HasModifier("modifier_arcanegiant_cd"))
end

function OnPurgeProcs(caster, target, ability)
    if caster.talents then
        if caster.talents[144] > 0 then
            HealUnit({caster = caster, target = caster, ability = ability, heal = 0, percenthp = 15 * caster.talents[144] })
            Timers:CreateTimer(0.25, function()
                HealUnit({caster = caster, target = target, ability = ability, heal = 0, percenthp = 15 * caster.talents[144] })
            end)
        end
    end
end

function HeroHasNeutralItem( hero, item )
    local slotItem = hero:GetItemInSlot(16)
    if slotItem and slotItem:GetName() == item and slotItem.heroOwner and slotItem.heroOwner == hero then
        return true
    end
    return false
end

function GetFlatCritChance(caster)
    local critchance = 0
    if HeroHasNeutralItem(caster, "item_neutral_7") then
        critchance = critchance + 10
    end
    if caster.talents then
        if caster.talents[152] > 0 then
            critchance = critchance + caster.talents[152]
        end
    end
    return critchance
end

function ResetAllCooldowns( hero )
    for i=0, COverthrowGameMode.heroAbilityCount do
        local ability = hero:GetAbilityByIndex(i)
        if ability and not ability:IsPassive() then
            ability:EndCooldown()
        end
    end
end

function FixNetworkQuantization( event )
    local caster = event.caster
    local boundsMin = 0
    local boundsMax = 16100
    local pos = caster:GetAbsOrigin()
    local outsideBounds = pos[1] < boundsMin or pos[1] > boundsMax or pos[2] < boundsMin or pos[2] > boundsMax or pos[3] < -1000 or pos[3] > 1000
    if outsideBounds then
        caster:SetAbsOrigin(Vector(boundsMax / 2, boundsMax / 2, 0))
        --print("fix quant")
    end
end

function FixNetworkQuantizationByKnockBack( event )
    --local caster = event.caster
    --caster.forceimune =  true
end

function GetInnerCooldownFactor( caster )
    local factor = 1
    if caster.talents then
        if caster.talents[157] > 0 then
            factor = factor * (1 - 0.1 * caster.talents[157])
        end
    end
    return factor
end

function OnBossKilled()
    local all = HeroList:GetAllHeroes()
    local hero
    for i=1, #all do
        hero = all[i]
        if hero.talents and hero.talents[161] > 0 then
            ApplyBuff({caster = hero, target = hero, dur = 20 * hero.talents[161], buff = "modifier_killingSpree", ability = hero.combat_system_ability})
            if hero:HasModifier("modifier_killer") then
                ApplyBuff({caster = hero, target = hero, dur = 20 * hero.talents[161], buff = "modifier_killingSpree2", ability = hero.combat_system_ability})
            end
        end
    end
end

function CastMarkSpell(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    local spell = event.spell
    local duration = event.buffduration
    if GetLevelOfAbility(caster, "ench5") >= 3 then
        duration = duration + 2
    end
    if spell == 4 then
        ApplyBuff({caster = caster, target = target, dur = duration, buff = "modifier_mol", ability = ability})
        if ability:GetLevel() >= 4 and caster ~= target then
            if not caster.markLifeSwapDone then
                caster.markLifeSwapDone = 0
            end
            local baseDst = (Entities:FindByName( nil, "team_base_1" ):GetAbsOrigin() - caster:GetAbsOrigin()):Length()
            local casterLives = caster:GetModifierStackCount("modifier_pvelives", nil)
            local targetLives = target:GetModifierStackCount("modifier_pvelives", nil)
            local difference = casterLives - targetLives
            if baseDst <= 2500 and difference ~= 0 and caster.markLifeSwapDone < 2 then
                caster.markLifeSwapDone = caster.markLifeSwapDone + 1
                AddLivesToHero(caster, -difference)
                AddLivesToHero(target, difference)
                if math.random(1,100) <= 50 then
                    EmitSoundOn("abaddon_abad_kill_03", target)
                else
                    EmitSoundOn("abaddon_abad_lasthit_09", target)
                end

                local offset = Vector(0,0,75)
                local particle = ParticleManager:CreateParticle( "particles/econ/items/monkey_king/arcana/death/mk_spring_arcana_death_souls_line.vpcf", PATTACH_WORLDORIGIN, nil)
                ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin() + offset)
                ParticleManager:SetParticleControl(particle, 4, target:GetAbsOrigin() + offset)
                ParticleManager:ReleaseParticleIndex(particle)
                particle = ParticleManager:CreateParticle( "particles/econ/items/monkey_king/arcana/death/mk_spring_arcana_death_souls_line.vpcf", PATTACH_WORLDORIGIN, nil)
                ParticleManager:SetParticleControl(particle, 0, target:GetAbsOrigin() + offset)
                ParticleManager:SetParticleControl(particle, 4, caster:GetAbsOrigin() + offset)
                ParticleManager:ReleaseParticleIndex(particle)
                EmitGlobalSound("Item.GlimmerCape.Activate")

            end
        end
    end
    if spell == 5 then
        ApplyBuff({caster = caster, target = target, dur = duration, buff = "modifier_mod", ability = ability})
    end
    if spell == 6 then
        ApplyBuff({caster = caster, target = target, dur = duration, buff = "modifier_mop", ability = ability})
        if ability:GetLevel() >= 2 then
            ApplyBuff({caster = caster, target = target, dur = duration, buff = "modifier_mop2", ability = ability})
        end
        if ability:GetLevel() >= 3 then
            ReduceCooldown({caster = caster, amount = 3, ability = ability, chooseabilityname = "ench4" })
            ReduceCooldown({caster = caster, amount = 3, ability = ability, chooseabilityname = "ench5" })
        end
    end
    if GetLevelOfAbility(caster, "ench6") >= 4 then
        AddSpellhaste(caster, 50, 5)
    end
    if GetLevelOfAbility(caster, "ench4") >= 2 then
        HealUnit({caster = caster, target = target, heal = target:GetMaxHealth() * 0.1, ability = ability})
    end
end

function AddPhasedToSummon( event )
    local hero = event.target
    hero:SetHullRadius(0)
    hero:RemoveModifierByName("modifier_phased_lua")
    hero:AddNewModifier(hero, event.ability, "modifier_phased_lua",
        {
            Duration = event.duration
        }
    )
end

function GetAttackDamageFromBaseStat( hero )
    local primary = hero:GetPrimaryAttribute()
    if primary == 0 then
        return GetStrengthCustom(hero)
    end
    if primary == 1 then
        return GetAgilityCustom(hero)
    end
    if primary == 2 then
        return GetIntellectCustom(hero)
    end
    return 0
end

function SwordStormInit(event)
    event.caster.swordStormCrits = 0
end

function AddSwordStormCrit(caster)
    caster.swordStormCrits = caster.swordStormCrits + 1
    if caster.swordStormCrits > 25 then
        caster.swordStormCrits = 25
    end
    print(caster.swordStormCrits)
end

function SniperAAProcs(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster:HasModifier("modifier_npc_dota_hero_sniper2") and GetLevelOfAbility(caster, "Bear") <= 0 then
        local cost = ability:GetManaCost(-1) / 2
        if caster:GetMana() >= cost then
            EnergyCost({caster = caster, cost = cost, pay = true})
            ability:ApplyDataDrivenModifier(caster, target, "modifier_proc_sniper", nil)
        end
    end
end

function Symbiosis(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster:HasModifier("modifier_npc_dota_hero_furion2") then
        local target = FindClosestAlly(caster, caster:GetAbsOrigin(), 900, false)
        if target then
            ApplyBuff({caster = caster, target = target, dur = 10, buff = "modifier_symbiosos_fur", ability = ability})
            local particle = ParticleManager:CreateParticle( "particles/econ/items/monkey_king/arcana/death/mk_spring_arcana_death_souls_line.vpcf", PATTACH_WORLDORIGIN, nil)
            ParticleManager:SetParticleControl(particle, 0, caster:GetAbsOrigin())
            ParticleManager:SetParticleControl(particle, 4, target:GetAbsOrigin())
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end
end

function PlatedClassItem2(event)
    local caster = event.caster
    local ability = event.ability
    if caster:HasModifier("modifier_npc_dota_hero_plated2") then
        ApplyBuff({caster = caster, target = caster, dur = 3, buff = "modifier_rrod", ability = ability})
    end
end

function IgniteProc(event)
    local caster = event.caster
    local ability = event.ability
    if ability:GetLevel() >= 4 then
        if not caster.igniteProc then
            caster.igniteProc = 0
        end
        caster.igniteProc = caster.igniteProc + 1
        if caster.igniteProc >= 2 then
            caster.igniteProc = 0
            ability:ApplyDataDrivenModifier(caster, caster, "modifier_activewarlock", nil)
            event.amount = 100
            EmitSoundOn("Item.MoonShard.Consume", caster)
            ReduceCooldown(event)
        end
    end
end

function CryOfThunder(event)
    local caster = event.caster
    local ability = caster:FindAbilityByName("Ghost4")
    if caster:HasModifier("modifier_class_ghost2") then
        local totem = caster.stormfuryTotem
        if totem and not totem:IsNull() and totem:IsAlive() then
            ability:ApplyDataDrivenModifier(caster, totem, "modifier_proc_cry_of_thunder", nil)
        end
    end
end

function BlackGrimoire(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster:HasModifier("modifier_class_warlock2") then
        ApplyBuffStack({caster = caster, target = target, ability = ability, dur = 5, max = 20, buff = "modifier_black_grimoire"})
    end 
end

function ShapeshiftMonkey(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster:HasModifier("modifier_class_ursa2") then
        caster.ursaModel = caster:GetModelName()
        caster:SetModel("models/items/lone_druid/bear/tarzan_and_kingkong_spirit/tarzan_and_kingkong_spirit.vmdl")
        caster:SetOriginalModel("models/items/lone_druid/bear/tarzan_and_kingkong_spirit/tarzan_and_kingkong_spirit.vmdl")
        caster:SetModelScale(1.15)
        caster.inMonkeyKingForm = true
    end 
end

function ShapeshiftMonkeyEnd(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    caster.inMonkeyKingForm = false
    if caster.ursaModel then
        caster:SetModel(caster.ursaModel)
        caster:SetOriginalModel(caster.ursaModel)
        caster:SetModelScale(0.8)
    end
end


function PlagueFormCheck(event)
    local caster = event.caster
    local ability = event.ability
    if caster:HasModifier("modifier_class_pudge2") and GetLevelOfAbility(caster, "unholy_5") < 1 and GetLevelOfAbility(caster, "unholy_4") < 1 then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_plague_form", {Duration = 10})
    end 
end

function PlagueForm(event)
    local caster = event.caster
    local ability = event.ability
    caster.pudgeModel = caster:GetModelName()
    caster:SetModel("models/items/undying/flesh_golem/incurable_pestilence_golem/incurable_pestilence_golem.vmdl")
    caster:SetOriginalModel("models/items/undying/flesh_golem/incurable_pestilence_golem/incurable_pestilence_golem.vmdl")
    --caster:SetModelScale(1.15)
    local bonus = 0.01
    caster.plagueFormBonus = bonus
    for i=1, 10 do
        Timers:CreateTimer(i, function()
            if caster:HasModifier("modifier_plague_form") then
                bonus = bonus * 2
                caster.plagueFormBonus = bonus
            end
        end)
    end
end

function PlagueFormEnd(event)
    local caster = event.caster
    local ability = event.ability
    caster.plagueFormBonus = 0
    if caster.pudgeModel then
        caster:SetModel(caster.pudgeModel)
        caster:SetOriginalModel(caster.pudgeModel)
        --caster:SetModelScale(0.8)
    end
end

function CorruptedCoilProc(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster:HasModifier("modifier_class_skele2") then
        ApplyBuff({caster = caster, target = target, ability = ability, dur = 0.1, max = 20, buff = "modifier_proc_coil"})
        local enemies = FindUnitsInRadius( caster:GetTeamNumber(), caster:GetOrigin(), caster, 900, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC, 0, 0, false )
        local count = 0
        if #enemies > 0 then
            for _,enemy in pairs(enemies) do
                count = count + 1
                if enemy ~= nil and ((enemy:GetUnitLabel()=="hero") or (enemy:GetUnitLabel()==pet) or (enemy:GetUnitLabel()=="tower")) then
                    Timers:CreateTimer(count * 0.5, function()
                        ability:ApplyDataDrivenModifier(caster, enemy, "modifier_proc_coil", {Duration = 0.05})
                    end)
                end
            end
        end
    end 
end

function ShadowPriestFormCheck(event)
    local caster = event.caster
    local ability = event.ability
    if caster:HasModifier("modifier_class_ds2") then
        ability:ApplyDataDrivenModifier(caster, caster, "modifier_shadow_form_ds", {Duration = 30})
    end 
end

function ShapeshiftShadowPriest(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    caster.dsModel = caster:GetModelName()
    caster:SetModel("models/items/enigma/eidolon/enigma_seer_of_infinity_space_eidolon/enigma_seer_of_infinity_space_eidolon.vmdl")
    caster:SetOriginalModel("models/items/enigma/eidolon/enigma_seer_of_infinity_space_eidolon/enigma_seer_of_infinity_space_eidolon.vmdl")
    caster:SetModelScale(1.25)
end

function ShapeshiftShadowPriestEnd(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster.dsModel then
        caster:SetModel(caster.dsModel)
        caster:SetOriginalModel(caster.dsModel)
        caster:SetModelScale(1)
    end
end

function FrostknightCheck(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster:HasModifier("modifier_class_sven2") and caster:GetModifierStackCount("modifier_froststr", nil) >= 5 and not caster.svenModel then
        caster.svenModel = caster:GetModelName()
        caster:SetModel("models/items/undying/flesh_golem/frostivus_2018_undying_accursed_draugr_golem/frostivus_2018_undying_accursed_draugr_golem.vmdl")
        caster:SetOriginalModel("models/items/undying/flesh_golem/frostivus_2018_undying_accursed_draugr_golem/frostivus_2018_undying_accursed_draugr_golem.vmdl")
        --caster:SetModelScale(1.15)
    end 
end

function FrostknightEnd(event)
    local caster = event.caster
    local target = event.target
    local ability = event.ability
    if caster.svenModel then
        caster:SetModel(caster.svenModel)
        caster:SetOriginalModel(caster.svenModel)
    end
    --caster:SetModelScale(1.15)
    caster.svenModel = nil
end

function EarthErruption(event)
    local caster = event.caster
    local ability = event.ability
    local delay = event.delay
    local aoe = 300
    event.numbertargets = event.count
    local targets = COverthrowGameMode:RandomXHeroes(event)
    if not targets then
        targets = {FindClosestHero(caster)}
        if not targets then
            return
        end
    end
    local targetPos = {}
    for i=1, #targets do
        local particle = ParticleManager:CreateParticle("particles/items_fx/abyssal_blink_end.vpcf", PATTACH_ABSORIGIN, targets[i])
        ParticleManager:SetParticleControl(particle, 0, targets[i]:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
        targetPos[i] = targets[i]:GetAbsOrigin()
        particle = ParticleManager:CreateParticle("particles/items4_fx/meteor_hammer_spell_embers.vpcf", PATTACH_ABSORIGIN, targets[i])
        ParticleManager:SetParticleControl(particle, 3, targetPos[i])
        ParticleManager:ReleaseParticleIndex(particle)
    end
    Timers:CreateTimer(delay / 3, function()
        for i=1, #targets do
            local particle = ParticleManager:CreateParticle("particles/items_fx/abyssal_blink_end.vpcf", PATTACH_ABSORIGIN, targets[i])
            ParticleManager:SetParticleControl(particle, 0, targetPos[i])
            ParticleManager:ReleaseParticleIndex(particle)
            particle = ParticleManager:CreateParticle("particles/items4_fx/meteor_hammer_spell_embers.vpcf", PATTACH_ABSORIGIN, targets[i])
            ParticleManager:SetParticleControl(particle, 3, targetPos[i])
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end)
    Timers:CreateTimer(delay * 2 / 3, function()
        for i=1, #targets do
            local particle = ParticleManager:CreateParticle("particles/items_fx/abyssal_blink_end.vpcf", PATTACH_ABSORIGIN, targets[i])
            ParticleManager:SetParticleControl(particle, 0, targetPos[i])
            ParticleManager:ReleaseParticleIndex(particle)
            particle = ParticleManager:CreateParticle("particles/items4_fx/meteor_hammer_spell_embers.vpcf", PATTACH_ABSORIGIN, targets[i])
            ParticleManager:SetParticleControl(particle, 3, targetPos[i])
            ParticleManager:ReleaseParticleIndex(particle)
        end
    end)
    Timers:CreateTimer(delay, function()
        EmitGlobalSound("DOTA_Item.Overwhelming_Blink.Activate")
        for i=1, #targets do
            local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_leshrac/leshrac_split_earth.vpcf", PATTACH_ABSORIGIN, targets[i])
            ParticleManager:SetParticleControl(particle, 0, targetPos[i])
            ParticleManager:SetParticleControl(particle, 1, Vector(300,0,0))
            ParticleManager:ReleaseParticleIndex(particle)
            local ev = {caster = caster, target_points = {targetPos[i]}, ability = ability, damage = 0, difficultyscalelinear = 1000, aoe = aoe, targeteffect = "blood", stun = 7 }
            DamageAOE(ev)
        end
    end)
end

function FlameErruption(event)
    local caster = event.caster
    local ability = event.ability
    local delay = event.delay
    local aoe = 100
    local duration = 15
    local tickRate = 0.8
    local tickAmount = duration / tickRate
    local flameSpeedPerTick = 100 * tickRate
    event.numbertargets = event.count
    local targets = COverthrowGameMode:RandomXHeroes(event)
    if not targets then
        targets = {FindClosestHero(caster)}
        if not targets then
            return
        end
    end
    for i=1, #targets do
        local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_warlock/warlock_rain_of_chaos_start_meteor_flame.vpcf", PATTACH_POINT_FOLLOW, targets[i])
        ParticleManager:SetParticleControl(particle, 0, targets[i]:GetAbsOrigin())
        ParticleManager:SetParticleControl(particle, 1, targets[i]:GetAbsOrigin())
        ParticleManager:ReleaseParticleIndex(particle)
    end
    Timers:CreateTimer(delay, function()
        local flamePositions = {}
        for i=1, #targets do
            local targetIndex = i
            flamePositions[i] = targets[targetIndex]:GetAbsOrigin()
            for tick=1, tickAmount do
                local tickIndex = tick
                Timers:CreateTimer(tickRate * tick, function()
                    local directionFromFlameToHero = (targets[targetIndex]:GetAbsOrigin() - flamePositions[targetIndex]):Normalized()
                    flamePositions[targetIndex] = flamePositions[targetIndex] + directionFromFlameToHero * flameSpeedPerTick
                    local particle = ParticleManager:CreateParticle("particles/units/heroes/hero_warlock/warlock_rain_of_chaos_start_meteor_flame.vpcf", PATTACH_POINT_FOLLOW, targets[targetIndex])
                    ParticleManager:SetParticleControl(particle, 0, flamePositions[targetIndex])
                    ParticleManager:SetParticleControl(particle, 1, flamePositions[targetIndex])
                    ParticleManager:ReleaseParticleIndex(particle)
                    local ev = {caster = caster, target_points = {flamePositions[targetIndex]}, ability = ability, damage = 0, difficultyscalelinear = (50 * tickIndex - 45), aoe = aoe, targeteffect = "blood"}
                    DamageAOE(ev)
                end)
            end
        end
    end)
end

function SpellbookLearn(event)
    local caster = event.caster
    local ability = event.ability
    local itemAbilityName = ability:GetName()
    local itemAbilityNameLength = string.len(itemAbilityName)
    local newAbilityName = string.sub(itemAbilityName, 16, itemAbilityNameLength)

    --is ability allowed for hero?
    if not IsAbilityAllowedForHero(caster, newAbilityName) then
        return
    end

    LearnMasteryAbility(caster, newAbilityName)

    --remove item
    local itemSlot = ability:GetItemSlot()
    local item = caster:GetItemInSlot(itemSlot)
    if item then
        UTIL_Remove(item)
    end
end

function LearnMasteryAbility(caster, newAbilityName)
    --remove previously learned ability
    local masteryAbilityLevel = 1
    if caster.masteryAbility then
        masteryAbilityLevel = caster.masteryAbility:GetLevel()
        caster:RemoveAbilityByHandle(caster.masteryAbility)
    end

    --add ability
    local newAbility = caster:AddAbility(newAbilityName)
    newAbility:SetLevel(masteryAbilityLevel)
    caster.masteryAbility = newAbility

    --swap ability to 7th slot
    local abilityIn7thSlot = caster:GetAbilityByIndex(6)
    if abilityIn7thSlot and abilityIn7thSlot ~= newAbility then
        local abilityIn7thSlotWasActive = abilityIn7thSlot:IsActivated()
        caster:SwapAbilities(newAbilityName, abilityIn7thSlot:GetName(), true, abilityIn7thSlotWasActive)
    end
end

function IsAbilityAllowedForHero(hero, abilityName)
    local name = hero:GetName()
    if (name == "npc_dota_hero_lina" or name == "npc_dota_hero_crystal_maiden" or name == "npc_dota_hero_invoker") and (abilityName == "mage_1" or abilityName == "mage_1") then
        return true
    end
    return false
end

--todo: 
-- save ability in db
-- load ability from db and assign 1 skill point?

function WarriorStanceProc(event)
    local caster = event.caster
    local ability = event.event_ability
    local baseAbility = caster:FindAbilityByName("warrior_1")
    if ability and (ability:GetName() == "Shield_Reflect" or ability:GetName() == "WarriorCharge" or ability:GetName() == "Terror_Shout" or ability:GetName() == "Terror_ShoutFury" or ability:GetName() == "Terror_ShoutProt") then
        local myevent = { caster = caster, target = caster, dur = 10, buff = "modifier_swordboard", ability = baseAbility, addstacks = 1, max = 10}
        ApplyBuffStack(myevent)
    end
end

function WarriorBerserkerRage(event)
    local caster = event.caster
    local ability = event.event_ability
    local baseAbility = caster:FindAbilityByName("warrior_2")
    if ability and (ability:GetName() == "Sword_Storm" or ability:GetName() == "fury5" or ability:GetName() == "Protect5") then
        local stacks = caster:GetHealth() * 100 / caster:GetMaxHealth()
        if stacks >= 1 then
            HealUnit({caster = caster, target = caster, heal = 0, percenthp = stacks / 2, ability = baseAbility})
            local myevent = { caster = caster, target = caster, dur = 8, buff = "modifier_berserkerrage", ability = baseAbility, addstacks = stacks, max = stacks}
            ApplyBuffStack(myevent)
        end
    end
end

function AbilityAutoCast(event)
    local caster = event.caster
    local target = event.target
    local ability = caster:GetAbilityByIndex(0)
    local ability2 = caster:GetAbilityByIndex(1)

    local abilityToCast = ability
    if ability2:GetCooldownTimeRemaining() <= 0 and ability2:GetLevel() > 0 then
        abilityToCast = ability2
    end

    Timers:CreateTimer(0.05, function()
        local order = 
        {
            UnitIndex = caster:entindex(),
            OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
            AbilityIndex = abilityToCast:GetEntityIndex(), 
            Queue = false,
            TargetIndex = target:entindex()
        }

        ExecuteOrderFromTable(order)
    end)
end

function DivineSphereTakeDamage(event)
    local caster = event.caster
    HealUnit({caster = caster, target = caster, heal = 0, percenthp = 5, ability = event.ability})
    RestoreMana({caster = caster, percent = 1, amount = 5})
end